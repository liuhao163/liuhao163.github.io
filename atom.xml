<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuhao163.github.io</title>
  
  <subtitle>杂七杂八</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuhao163.github.io/"/>
  <updated>2023-01-07T14:25:04.451Z</updated>
  <id>https://liuhao163.github.io/</id>
  
  <author>
    <name>Liu hao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RUST学习-生命周期</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://liuhao163.github.io/RUST学习-生命周期/</id>
    <published>2023-01-07T22:05:25.000Z</published>
    <updated>2023-01-07T14:25:04.451Z</updated>
    
    <content type="html"><![CDATA[<p>  RUST的生命周期是指RUST的编译器用来处理悬垂引用的规则</p><p>  什么是悬垂引用：指生命周期外的变量，引用了本生命周期外的数据，因为这时候被引用的数据在离开被引用的作用域会被回收掉，导致最终引用了一个空值，而RUST的编译器是不允许这种行为产生的</p><p>  RUST对函数生命周期的检查是通过一个组件引用检查器实现的</p><h2 id="几种引用的说明"><a href="#几种引用的说明" class="headerlink" title="几种引用的说明"></a>几种引用的说明</h2><p>  见下面函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于res离开函数largest就被回收掉了所以也无法编译通过会报错：cannot return reference to local variable <code>res</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(x: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="built_in">String</span>::from(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  largest是无法编译通过的会报错:missing lifetime specifier，因为返回值的生命周期无法判断返回的是a还是b，导致编译错误，解决方案需要手动声明函数引用的生命周期，注意泛型里的’a</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的泛型-声明周期"><a href="#函数的泛型-声明周期" class="headerlink" title="函数的泛型+声明周期"></a>函数的泛型+声明周期</h2><p>  生命周期是特殊的泛型需要这么声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;<span class="symbol">'a</span>, T: <span class="built_in">PartialOrd</span>&gt;(x: &amp;<span class="symbol">'a</span> T, y: &amp;<span class="symbol">'a</span> T) -&gt; &amp;<span class="symbol">'a</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RUST省略生命周期的方案"><a href="#RUST省略生命周期的方案" class="headerlink" title="RUST省略生命周期的方案"></a>RUST省略生命周期的方案</h2><p>  我们在编写函数一般不会手动指定生命周期那么，RUST是如何来推断出函数的生命周期呢，主要是遵循以下规则:</p><p>  首先RUST的函数分为输入生命周期（引用参数），和输出生命周期（返回值）,如果通过输入生命周期无法推断出输出生命周期就会报错，那么如何推导出输出生命周期呢需要遵循以下三个原则：</p><ol><li>如果没有手动指定生命周期，且有多个引用参数，则每个引用参数有不同的生命周期</li><li>如果只有一个输入生命周期，则可以把当前生命周期赋予输出生命周期</li><li>如果是一个函数即第一个参数是&amp;self或者&amp;mut self，则可以把&amp;self或者&amp;mut self的输入生命周期赋予给输出生命周期</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  RUST的生命周期是指RUST的编译器用来处理悬垂引用的规则&lt;/p&gt;
&lt;p&gt;  什么是悬垂引用：指生命周期外的变量，引用了本生命周期外的数据，因为这时候被引用的数据在离开被引用的作用域会被回收掉，导致最终引用了一个空值，而RUST的编译器是不允许这种行为产生的&lt;/p&gt;

      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-trait</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-trait/"/>
    <id>https://liuhao163.github.io/RUST学习-trait/</id>
    <published>2023-01-05T17:06:32.000Z</published>
    <updated>2023-01-05T09:16:14.187Z</updated>
    
    <content type="html"><![CDATA[<p>  rust的trait很想是java的interface</p><h3 id="如何定义、实现一个trait"><a href="#如何定义、实现一个trait" class="headerlink" title="如何定义、实现一个trait"></a>如何定义、实现一个trait</h3><p>通过关键字pub trait XXX{}，trait里定义的方法如果没有默认实现，可以没有方法体，那么所有实现该trait的strut的必须实现该方法，如果提供默认方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义trait 并且定义了trait的函数，给出了默认实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">//默认实现类似于Java的Abstact模板类</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize_auther</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span>.to_string();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"(Read mor form &#123;&#125;...)"</span>, &amp;<span class="keyword">self</span>.sumarize_auther());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现该trait其中NewsArticle和Tweet都实现了Summary这个trait</p><ul><li>需要注意的是如果要实现trait，必须满足trait或者类型是在当前pakcage下定义的【为了安全防止你的代码别别人破坏或者别人破坏你的代码】</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> auther: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现trait</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"&#123;&#125;,by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.auther, <span class="keyword">self</span>.location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"&#123;&#125;:&#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> news_article = &amp;NewsArticle &#123;</span><br><span class="line">        headline: <span class="built_in">String</span>::from(<span class="string">"头条"</span>),</span><br><span class="line">        location: <span class="built_in">String</span>::from(<span class="string">"北京"</span>),</span><br><span class="line">        auther: <span class="built_in">String</span>::from(<span class="string">"ericliu"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"学习RUST的trait"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"新闻摘要：&#123;&#125;"</span>, news_article.sumarize());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"新闻 break_info：&#123;&#125;"</span>, news_article.break_info());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweet = &amp;Tweet &#123;</span><br><span class="line">        username: <span class="string">"ericliu"</span>.to_string(),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"学习RUST的trait"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"推文摘要：&#123;&#125;"</span>, tweet.sumarize());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"推文 break_info：&#123;&#125;"</span>, tweet.break_info());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="trait-bound"><a href="#trait-bound" class="headerlink" title="trait bound"></a>trait bound</h3><p>  我们在定义方法如果用到泛型的时候可以通过trait bound的概念对泛型进行一些定义，类似java中的<t extends xxx>这种用法,看例子</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get_largest &#123;&#125;"</span>,get_largest(<span class="built_in">vec!</span>[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">100</span>,-<span class="number">100</span>,<span class="number">200</span>]));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get_largest2 &#123;&#125;"</span>,get_largest2(<span class="built_in">vec!</span>[<span class="string">"hello"</span>.to_string(),<span class="string">"world"</span>.to_string(),<span class="string">"a"</span>.to_string()]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有实现了PartialOrd的泛型所指的类型T</span></span><br><span class="line"><span class="comment">//T实现了Copy的Trait，一般指对象声明在Stack上否则let mut res = v[0];会报错Cannet move</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_largest</span></span>&lt;T:<span class="built_in">PartialOrd</span>+<span class="built_in">Copy</span>&gt;(v: <span class="built_in">Vec</span>&lt;T&gt;) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> res = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> v.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> res &lt; item &#123;</span><br><span class="line">            res = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有实现了PartialOrd的泛型所指的类型T</span></span><br><span class="line"><span class="comment">//T实现了Copy的Trait，一般指对象声明在Stack上否则let mut res = v[0];会报错Cannet move</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_largest2</span></span>&lt;T:<span class="built_in">PartialOrd</span>+<span class="built_in">Clone</span>&gt;(v: <span class="built_in">Vec</span>&lt;T&gt;) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> res = v[<span class="number">0</span>].clone();</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> v.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> res &lt; item.clone() &#123;</span><br><span class="line">            res = item.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait可以对泛型的实现进行限制"><a href="#trait可以对泛型的实现进行限制" class="headerlink" title="trait可以对泛型的实现进行限制"></a>trait可以对泛型的实现进行限制</h3><p>  该场景主要用于加强某些trait的行为，比如说让所有实现了traitA的类型具有B的功能，具体实现方法见下面，典型的例子是rust标准库中实现了Display的函数都实现了ToString这个trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BreakNews</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">break_info</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过trait限制泛型的类型：给所有实现Summary的泛型实现break_info</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Summary&gt; BreakNews <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">break_info</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"break_info :&#123;&#125;"</span>, <span class="keyword">self</span>.sumarize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  rust的trait很想是java的interface&lt;/p&gt;
&lt;h3 id=&quot;如何定义、实现一个trait&quot;&gt;&lt;a href=&quot;#如何定义、实现一个trait&quot; class=&quot;headerlink&quot; title=&quot;如何定义、实现一个trait&quot;&gt;&lt;/a&gt;如何定义、实现
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-集合</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88/"/>
    <id>https://liuhao163.github.io/RUST学习-集合/</id>
    <published>2023-01-04T09:44:14.000Z</published>
    <updated>2023-01-05T09:05:37.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vec"><a href="#vec" class="headerlink" title="vec"></a>vec</h2><p>  类似于java类型的List和golang的切片</p><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><p>俩种方法一种是Vec::new，一种是vec!宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>vec.push(v);</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>  索引访问和match访问，索引访问会出现数组越界的painc，而match返回值是Option,因为有None的存在所以不会出现数组月觉的patinc</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"out of index 100 &#123;&#125;"</span>,v[<span class="number">100</span>]);<span class="comment">//panicked at 'index out of bounds: the len is 4 but the index is 100'</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(v)=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get this element is &#123;&#125;"</span>,v)&#125;,</span><br><span class="line">    <span class="literal">None</span>=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get out of index"</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(v)=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get this element is &#123;&#125;"</span>,v)&#125;,</span><br><span class="line">    <span class="literal">None</span>=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get  out of index"</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历vector，第一次遍历用可变应用可以修改里面的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v1=<span class="built_in">vec!</span>[<span class="number">100</span>,<span class="number">50</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v1&#123;</span><br><span class="line">    *i=*i+<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v1&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index,i) <span class="keyword">in</span> v1.iter().enumerate()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"index &#123;&#125; v &#123;&#125;"</span>, index,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>rust在处理字符串时候常用&amp;str和String俩种类型，其中&amp;str是字符串字面值，String是标准库提供的</p><p>常用函数/宏</p><ul><li>String::from将str构造成String</li><li>format!通过占位符”{}”,格式化</li><li>String实际上是char类型的数组，所以可以采用切片方式访问即:&amp;s4[0..4]，</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s=<span class="string">"hello"</span>;<span class="comment">//这是&amp;str类型</span></span><br><span class="line"><span class="keyword">let</span> s1=<span class="built_in">String</span>::from(<span class="string">"Hello"</span>);<span class="comment">//这是string</span></span><br><span class="line"><span class="keyword">let</span> s2=<span class="built_in">String</span>::from(<span class="string">" World!"</span>);</span><br><span class="line"><span class="keyword">let</span> s4=<span class="built_in">format!</span>(<span class="string">"&#123;&#125;&#123;&#125;"</span>,s1,s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,&amp;s4[<span class="number">0</span>..<span class="number">4</span>]);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s4.chars()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="创建方法-1"><a href="#创建方法-1" class="headerlink" title="创建方法"></a>创建方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> hash_map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉链方法，需要显示制定类型</span></span><br><span class="line"><span class="keyword">let</span> hash_map: HashMap&lt;_, _&gt; = keys.iter().zip(values).collect();</span><br></pre></td></tr></table></figure><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p>insert</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash_map.insert(<span class="string">"blue"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//entry可以做到没有在插入</span></span><br><span class="line">hash_map.entry(<span class="built_in">String</span>::from(<span class="string">"yellow"</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>get</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> hash_map.get(<span class="string">"yellow"</span>) &#123;</span><br><span class="line">       <span class="literal">Some</span>(v) =&gt; <span class="built_in">println!</span>(<span class="string">"match Some &#123;&#125;"</span>, v),</span><br><span class="line">       <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"key empty"</span>),</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span> hash_map&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>,k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vec&quot;&gt;&lt;a href=&quot;#vec&quot; class=&quot;headerlink&quot; title=&quot;vec&quot;&gt;&lt;/a&gt;vec&lt;/h2&gt;&lt;p&gt;  类似于java类型的List和golang的切片&lt;/p&gt;
&lt;h3 id=&quot;创建方法&quot;&gt;&lt;a href=&quot;#创建方法&quot; class
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-代码组成基本结构</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E6%88%90%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>https://liuhao163.github.io/RUST学习-代码组成基本结构/</id>
    <published>2023-01-04T09:29:54.000Z</published>
    <updated>2023-01-05T09:05:37.915Z</updated>
    
    <content type="html"><![CDATA[<p>  rust的代码组成结构分为package-&gt;cratio-&gt;module</p><p>  每个rust的程序都包含入口文件main.rs,模块导入文件lib.rs</p><h2 id="rust的包导入use关键字"><a href="#rust的包导入use关键字" class="headerlink" title="rust的包导入use关键字"></a>rust的包导入use关键字</h2><p>  在rs文件顶端用use关键字可以导入依赖，另外rust的函数、strut、method默认都是私有的，如果在别的模块和文件需要使用要显示的在定义处加pub</p><p>  pub use的用法:re-export重导出</p><ul><li>因为 lib.rs里有pub use front_of_hosting::hosting</li><li>所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</li><li>也可以写相对路径my_project::front_of_hosting::hosting</li><li>也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</li></ul><p>lib.rs</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::serving::take_order;</span><br></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> my_project::eat_at_restaurant;</span><br><span class="line"><span class="keyword">use</span> my_project::front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::hosting <span class="keyword">as</span> pub_hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::take_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**\</span></span><br><span class="line"><span class="comment">    pub use的用法:re-export重导出</span></span><br><span class="line"><span class="comment">    - 因为 lib.rs里有pub use front_of_hosting::hosting</span></span><br><span class="line"><span class="comment">    - 所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</span></span><br><span class="line"><span class="comment">    - 也可以写相对路径my_project::front_of_hosting::hosting</span></span><br><span class="line"><span class="comment">    - 也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pub_hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义mod"><a href="#定义mod" class="headerlink" title="定义mod"></a>定义mod</h2><p>  我们在开发过程中需要自己定义mod,rust对于mod的定义有特殊的犯法，如下：</p><ol><li>在lib.rs里声明mod front_of_hosting;注意这里是;</li><li>按照crate树状结构创建同名的.rs文件这里是front_of_hosting.rs</li><li>如果mod存在嵌套子mod的情况，比如这里front_of_hosting嵌套了serving和hosting，则在父mod的rs文件同样声明子mod，这里是mod hosting;和mod serving;注意这里是;</li><li>创建父mod文件夹，这里是front_of_hosting文件夹，在父mod文件夹里创建子mod的同名.rs文件\</li><li>在同名的mod的rs文件中编写代码</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  rust的代码组成结构分为package-&amp;gt;cratio-&amp;gt;module&lt;/p&gt;
&lt;p&gt;  每个rust的程序都包含入口文件main.rs,模块导入文件lib.rs&lt;/p&gt;
&lt;h2 id=&quot;rust的包导入use关键字&quot;&gt;&lt;a href=&quot;#rust的包导入
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-代码组织形式package、crate、mod</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8Fpackage%E3%80%81crate%E3%80%81mod/"/>
    <id>https://liuhao163.github.io/RUST学习-代码组织形式package、crate、mod/</id>
    <published>2022-12-27T23:28:58.000Z</published>
    <updated>2022-12-27T15:42:57.574Z</updated>
    
    <content type="html"><![CDATA[<p>  rust代码组织分为package、crate、mod</p><p>  rust代码出于安全性考虑声明的函数、mod、默认都是私有的，如果想导出需要在他们前面加上关键字“pub”</p><p>  在别的文件如果想引用mod或者函数需要使用use关键字</p><h2 id="mod声明和内容独立成文件"><a href="#mod声明和内容独立成文件" class="headerlink" title="mod声明和内容独立成文件"></a>mod声明和内容独立成文件</h2><pre><code>mod独立成文件，需要按照crate树结构创建同名的mo文件</code></pre><p>  1.在lib.rs里声明mod front_of_hosting;注意这里是;<br>  2.按照crate树状结构创建同名的.rs文件这里是front_of_hosting.rs<br>  3.如果mod存在嵌套子mod的情况，比如这里front_of_hosting嵌套了serving和hosting，则在父mod的rs文件同样声明子mod，这里是mod hosting;和mod serving;注意这里是;<br>  4.创建父mod文件夹，这里是front_of_hosting文件夹，在父mod文件夹里创建子mod的同名.rs文件\<br>  5.在同名的mod的rs文件中编写代码</p><p>lib.rs 声明父类mod</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> front_of_hosting;</span><br></pre></td></tr></table></figure><p>front_of_hosting.rs,这里声明了俩个子mod</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure><p>front_of_hosting\hosting.rs 实现mod hosting</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"add_to_waitlist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"seat_at_table"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>front_of_hosting\serving.rs 实现mod rust</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h2><p>  默认的use是私有的，在别的文件是无法使用这个use的，如果想使用需要在use前面也加上关键字，</p><p>  一般pub use多用于重导出的场景，即:re-export</p><p>   比如我们又一个mod的路径是 crate::my_project::front_of_hosting::hosting，我们在使用他的地方都需要“use my_project::front_of_hosting::hosting”，有没有简单的导出方法呢，是有的见下面</p><ul><li>因为 lib.rs里有pub use front_of_hosting::hosting</li><li>所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</li><li>也可以写相对路径my_project::front_of_hosting::hosting</li><li>也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</li></ul><p>lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> front_of_hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::hosting;</span><br></pre></td></tr></table></figure><p>  main.rs<br>  见这里use my_project::front_of_hosting::hosting 和 use my_project::hosting as pub_hosting;【为了避免重名起了个别名】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> my_project::front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::hosting <span class="keyword">as</span> pub_hosting;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    pub_hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  rust代码组织分为package、crate、mod&lt;/p&gt;
&lt;p&gt;  rust代码出于安全性考虑声明的函数、mod、默认都是私有的，如果想导出需要在他们前面加上关键字“pub”&lt;/p&gt;
&lt;p&gt;  在别的文件如果想引用mod或者函数需要使用use关键字&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-枚举</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E6%9E%9A%E4%B8%BE/"/>
    <id>https://liuhao163.github.io/RUST学习-枚举/</id>
    <published>2022-12-26T15:47:02.000Z</published>
    <updated>2023-01-05T09:05:37.917Z</updated>
    
    <content type="html"><![CDATA[<p>  枚举在rust语言里是一个很强大的数据结构</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><p>  和strut很类似，关键字是enum，同时我们也能为枚举里每个值增加不同的成员，和方法，见下面的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),<span class="comment">//ipv4是4个0-255的数字</span></span><br><span class="line">    V6(<span class="built_in">String</span>),<span class="comment">//ipv6是一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> IpAddrKind &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125; <span class="comment">//枚举的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法见下面</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ip_v4 = IpAddrKind::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ip_v6 = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br><span class="line">    ip_v4.call();</span><br><span class="line">    ip_v6.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h2><p>  rust类似于其他编程语言开关语句（switch–case）的语法结构是match，/match必须穷举所有可能性，如果值关注几个分支，则需要_通配符，即 _ =&gt; (),</p><p>  如果只助理一个分支则可以用if let，见下面，这种方式写的代码更少，缩进更少，也使用更少末班，使用if let放弃了穷举的可能，和match相比是简洁和穷尽的取舍</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">0u8</span>;</span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" zero"</span>); &#125;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" one"</span>); &#125;</span><br><span class="line">        <span class="number">2</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" two"</span>); &#125;</span><br><span class="line">        _ =&gt; (),<span class="comment">//忽略其他 类似switch</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这个例子plus_one对Option枚举里的值+1并且返回，有俩个分支一个None一个是Some，这里我们输出非None，这里可以搭配else使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我们想输出None这种分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">None</span> = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one NONE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何访问枚举的成员"><a href="#如何访问枚举的成员" class="headerlink" title="如何访问枚举的成员"></a>如何访问枚举的成员</h2><p>  可以用上面的if let和match</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Match访问成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">vlue_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Dime =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Quarter(State) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Quarter from State:&#123;:?&#125;"</span>, State);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//if let访问成员变量</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vlue_in_cents函数如何访问State成员</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Coin result &#123;&#125;"</span>, vlue_in_cents(Coin::Quarter(State::Alabama)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a>Option枚举</h2><p>  Option<t>枚举是很特殊的一个枚举类型，他包含Some<t>和None俩个值，其中None是用来处理null这种情况的，因为RUST里没有NULL。</t></t></p><p>  见下面的plus_one函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(input: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> input &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(v) =&gt; <span class="literal">Some</span>(v + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//如果只助理一个分支则可以用if let，见下面，这种方式写的代码更少，缩进更少，也使用更少末班，使用if let放弃了穷举的可能，和match相比是简洁和穷尽的取舍</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这个例子plus_one对Option枚举里的值+1并且返回，有俩个分支一个None一个是Some，这里我们输出非None，这里可以搭配else使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我们想输出None这种分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">None</span> = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one NONE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  枚举在rust语言里是一个很强大的数据结构&lt;/p&gt;
&lt;h2 id=&quot;定义枚举&quot;&gt;&lt;a href=&quot;#定义枚举&quot; class=&quot;headerlink&quot; title=&quot;定义枚举&quot;&gt;&lt;/a&gt;定义枚举&lt;/h2&gt;&lt;p&gt;  和strut很类似，关键字是enum，同时我们也能为枚举里
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-strut</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-strut/"/>
    <id>https://liuhao163.github.io/RUST学习-strut/</id>
    <published>2022-12-25T22:25:21.000Z</published>
    <updated>2023-01-05T09:05:37.915Z</updated>
    
    <content type="html"><![CDATA[<p> rust的类型（结构体）定义是通过strut定义</p><h2 id="strut定义"><a href="#strut定义" class="headerlink" title="strut定义"></a>strut定义</h2><p>   见下面，在使用的时候，需要给所有的成员赋值，有一个简写的更新语法。</p><p>   在声明struts时候，如果strut可变需要声明为mut，如果strut声明为mut，它所有的成员都是mut的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//声明一个strut,</span></span><br><span class="line">    <span class="keyword">let</span> imt_user1=User&#123;</span><br><span class="line">        user_name:<span class="built_in">String</span>::from(<span class="string">"lh"</span>),</span><br><span class="line">        email:<span class="built_in">String</span>::from(<span class="string">"lh@heyi.com"</span>),</span><br><span class="line">        sign_in_account:<span class="literal">false</span>,</span><br><span class="line">        active:<span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//struts的更新语法 注意..imt_user1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user2=User&#123;</span><br><span class="line">       user_name:<span class="built_in">String</span>::from(<span class="string">"lh2"</span>),</span><br><span class="line">        email:<span class="built_in">String</span>::from(<span class="string">"lh2@heyi.com"</span>),</span><br><span class="line">        ..imt_user1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    user_name:<span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    sign_in_account:<span class="built_in">bool</span>,</span><br><span class="line">    active:<span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tuple-strut"><a href="#tuple-strut" class="headerlink" title="tuple strut"></a>tuple strut</h2><p>  元祖结构体，可以对元祖声明称一个结构体，见下面,使用方法如下，可以通过元祖方式访问下标</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> black=Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> origin=Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"black.0 &#123;&#125;"</span>,black.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"origin.2 &#123;&#125;"</span>,origin.<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br></pre></td></tr></table></figure><h2 id="strut的输出"><a href="#strut的输出" class="headerlink" title="strut的输出"></a>strut的输出</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">//这里表示该数组可以通过&#123;:?&#125; &#123;:#?&#125;打印</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,rect);<span class="comment">//要加#[derive(Debug)]</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>,rect);<span class="comment">//&#123;:#?&#125;比&#123;:?&#125;更易读</span></span><br></pre></td></tr></table></figure><h2 id="strut的方法和函数"><a href="#strut的方法和函数" class="headerlink" title="strut的方法和函数"></a>strut的方法和函数</h2><p>  函数的定义，和实现在impl块内，一个strut可以有多个impl块</p><p>  strut的method:第一个参数为&amp;self，调用方式&lt;strut实例名&gt;.&lt;method的Name&gt;</p><p>  strut的函数：第一个参数非&amp;self,调用方式&lt;strut的名称&gt;::&lt;func的name&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">//关联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(width:<span class="built_in">u32</span>,length:<span class="built_in">u32</span>)-&gt;Rectangle&#123;</span><br><span class="line">        <span class="keyword">return</span> Rectangle&#123;</span><br><span class="line">            width,length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size:<span class="built_in">u32</span>)-&gt;Rectangle&#123;</span><br><span class="line">        <span class="keyword">return</span> Rectangle&#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mut_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area1</span></span>(<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>,other:&amp;Rectangle)-&gt;<span class="built_in">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width&gt;other.width &amp;&amp; <span class="keyword">self</span>.length&gt;other.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意：strut的方法调用，第一个参数可以是self，&amp;self,&amp;mut self，name在调用的时候自动帮你加上&amp;，&amp;mut 注意如果是rect这时候会触发实例的所有权move</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rect = Rectangle &#123;</span><br><span class="line">    width: <span class="number">50</span>,</span><br><span class="line">    length: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"method : &#123;&#125;"</span>, rect.area());<span class="comment">//rect自动加上了 &amp;</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"method : &#123;&#125;"</span>, rect.mut_area());<span class="comment">//因为是&amp;mut self,所以rect声明为mut，调用时候自动加上了&amp;mut</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mut_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area1</span></span>(<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>,other:&amp;Rectangle)-&gt;<span class="built_in">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width&gt;other.width &amp;&amp; <span class="keyword">self</span>.length&gt;other.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; rust的类型（结构体）定义是通过strut定义&lt;/p&gt;
&lt;h2 id=&quot;strut定义&quot;&gt;&lt;a href=&quot;#strut定义&quot; class=&quot;headerlink&quot; title=&quot;strut定义&quot;&gt;&lt;/a&gt;strut定义&lt;/h2&gt;&lt;p&gt;   见下面，在使用的时候，需要给
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>RUST学习-所有权</title>
    <link href="https://liuhao163.github.io/RUST%E5%AD%A6%E4%B9%A0-%E6%89%80%E6%9C%89%E6%9D%83/"/>
    <id>https://liuhao163.github.io/RUST学习-所有权/</id>
    <published>2022-12-24T17:36:53.000Z</published>
    <updated>2023-01-05T09:05:37.916Z</updated>
    
    <content type="html"><![CDATA[<p>  本章会讲解rust的核心特性，所有权</p><p>  程序运行时候都必须管理他们使用内存的方式<br>    – java,go通过gc来管理内存<br>    – c++ c通过显示的分配和释放内存来管理<br>    –rust用一套所有权机制来管理，编译器咋编译时候检查的规则。因为在编译时检查所以在运行时候没有任何回收内存的开销</p><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ol><li>每个值都有一个变量，这个变量是这个值的所有者</li><li>每个值同时只能有一个所有者</li><li><p>当所有者超出作用域时候该值会被删除</p><p>代码实例</p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s在离开main作用域时候会通过drop（）函数使其失效变量会立即交回给系统</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s=<span class="built_in">String</span>::from(<span class="string">"hello"</span>)  ;</span><br><span class="line">s.push_str(<span class="string">",world"</span>);</span><br></pre></td></tr></table></figure><h2 id="通过string说明所有权"><a href="#通过string说明所有权" class="headerlink" title="通过string说明所有权"></a>通过string说明所有权</h2><p>  s1在Stack上保存了份数据ptr,len,capaciry，其中ptr是heap上保存的数据的地址<br>  s2在Stack上复制了份s1的数据ptr,len,capaciry，其中ptr是heap上保存的数据的地址<br>  当s1,s2都离开作用域时候会通过drop释放堆内存数据，这时候会引起bug double free，rust为了解决这个问题引入了move的概念</p><p>  move的原理：<br>  rust的所有权机制的解法：第一不会复制heap上的数据，第二由于s1赋值给了s1，那么s1堆内存的引用会失效，s1离开作用域不会释放任何数据，当然在作用域中s1不能再被使用。</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> s1=<span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// let s2=s1;</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;",s1); //这里会报错value borrowed here after move</span></span><br></pre></td></tr></table></figure><p>  clone的概念：相比于move连heap的值都copy过来这时候 s1是可以用的</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s3=s1.clone();</span><br></pre></td></tr></table></figure><h2 id="Stack上的所有权问题"><a href="#Stack上的所有权问题" class="headerlink" title="Stack上的所有权问题"></a>Stack上的所有权问题</h2><p>  Stack上的赋值：copy.比如整数，<br>  Rust提供了Copy trait，当一个类型实现了Copy trait，那么旧的变量在赋值后依然可用；Drop trait 如果类型实现了该trait，就不能在实现Copy trait了</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y=x;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>,x); <span class="comment">//这时候x是可用的</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  本章会讲解rust的核心特性，所有权&lt;/p&gt;
&lt;p&gt;  程序运行时候都必须管理他们使用内存的方式&lt;br&gt;    – java,go通过gc来管理内存&lt;br&gt;    – c++ c通过显示的分配和释放内存来管理&lt;br&gt;    –rust用一套所有权机制来管理，编译器咋编译
      
    
    </summary>
    
      <category term="rust" scheme="https://liuhao163.github.io/categories/rust/"/>
    
      <category term="基础" scheme="https://liuhao163.github.io/categories/rust/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="rust" scheme="https://liuhao163.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>&#39;安全基本知识-加密&#39;</title>
    <link href="https://liuhao163.github.io/%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-%E5%8A%A0%E5%AF%86/"/>
    <id>https://liuhao163.github.io/安全基本知识-加密/</id>
    <published>2022-09-21T23:12:36.000Z</published>
    <updated>2022-09-21T15:17:41.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ol><li>对称加密：首选AES-GCM-256</li><li>非对称加密：首选RSA 2048如果选择ECC首选ECC 多用于对称加密秘钥的传输</li><li>单向散列：首选HMAC-SHA256，无论使用那种算法都需要加盐</li><li>消息认证：首选HMAC-SHA256，因为它能实现消息认证，和完整性保证</li></ol><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><ol><li>首选TLS1.2，新业务推荐直接使用TLS1.3及以上版本</li></ol><h2 id="口令标准"><a href="#口令标准" class="headerlink" title="口令标准"></a>口令标准</h2><ol><li>能够与SSO集成的建议继承SSO，并且配合SSO实现双因子认证或者动态口令</li><li>使用静态口令场景应该符合<ol><li>不使用默认口令</li><li>不使用通用口令</li><li>口令长度不小于14位</li><li>应包含大写、消息、符号、字母、数字</li><li>用户口令<ol><li>不小于8位</li><li>应包含大写、消息、符号、字母、数字</li><li>建议不上传用户口令，用户侧用慢速散列发给服务端，服务端通过加盐配合HMAS-SHA256存储</li></ol></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>使用运维提供的组件清单中的服务</li><li>禁止使用FTP、Telnet等不安全的服务q</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;加密算法&quot;&gt;&lt;a href=&quot;#加密算法&quot; class=&quot;headerlink&quot; title=&quot;加密算法&quot;&gt;&lt;/a&gt;加密算法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对称加密：首选AES-GCM-256&lt;/li&gt;
&lt;li&gt;非对称加密：首选RSA 2048如果选择ECC首选ECC
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="安全" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E5%AE%89%E5%85%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>JAVA的并发包:Lock和Conidtion</title>
    <link href="https://liuhao163.github.io/JAVA%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8C%85-Lock%E5%92%8CConidtion/"/>
    <id>https://liuhao163.github.io/JAVA的并发包-Lock和Conidtion/</id>
    <published>2022-09-21T15:23:46.840Z</published>
    <updated>2022-09-21T15:24:11.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="再造管程的意义"><a href="#再造管程的意义" class="headerlink" title="再造管程的意义"></a>再造管程的意义</h2><p>  java的管程的关键字是synchronized，在1.6后对管程做了升级，引入了偏向锁，轻量级锁的概念，性能几乎和Lock相近。然而在某些场景还是没法取到Lock。<br>  主要集中synchronized如下的几个痛点</p><ol><li>无法主动响应中断：在synchronzed代码块中，如果已经获取了资源a,在获取b失败后，就直接进入了阻塞，无法主动响应中断，这时候遇到死锁我们是无法处理的；</li><li>无法设置过期时间：synchronzed无法设置过期时间;</li><li>无法在非阻塞情况下竞争锁资源：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="lock的原理"><a href="#lock的原理" class="headerlink" title="lock的原理"></a>lock的原理</h2><p>我们以ReentrantLock为例子，类似管程，每个资源都一个等待队列。它是用一个双向链表实现的等待队列，同时每个链表的节点包含一个volatile的变量state作为锁标记位：0-release,1-lock。在调用lock/unlock方法中会通过cas修改volatile来实现state的变化。他是如何来保证在上锁解锁时候的可见性的呢？我们用下面的代码说明<br>rtl.lock上锁–&gt;之后value+=1–&gt;解锁,他们在并发场景下根据HB原则.</p><ol><li>顺序原则：线程1中：rtl.lock （HB于） value+=1 ；value+=1（HB于）rtl.unlock()</li><li>volatile的原则：此情况是针对线程1的rtl.unlock已经修改state成功但是由于可见性线程2的rtl.lock也申请锁的时候是否会失败？答案是不会，因为但当线程1的rtl.unlock修改state()和线程2的lock修改sate()发生冲突时候，由于rlt.lock需要先读取state，根据volatile的原则，写HB于读，所以unlock一定HB于lock，这时候lock一定读到的是最新的值</li><li>传递性原则：由于线程1的value+=1（HB于）rtl.unlock()，所以线程1的value+=1一定（HB于）于线程2的rtl.lock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    rtl.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value+=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 保证锁能释放</span></span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock的特点"><a href="#lock的特点" class="headerlink" title="lock的特点"></a>lock的特点</h2><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>lock和synchronized一样都是可重入锁：即同一个线程在获取锁之后，可以重复获取锁资源。（不可重入锁：即在此尝试获取锁资源会进入阻塞）</p><h2 id="公平锁和非公平数锁"><a href="#公平锁和非公平数锁" class="headerlink" title="公平锁和非公平数锁"></a>公平锁和非公平数锁</h2><p>lock可以实现贡公平锁，如：ReentrantLock的构造方法,见下面代码，具体可以看Sync的代码，如果是非公平锁，有可能最后获取资源的反而最先释放。详细可以去看<br>ReentrantLock内部类Sync的tryAcquire俩种实现。其中FairSync里有一个判断hasQueuedPredecessors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock中的等待通知机制-Condition"><a href="#Lock中的等待通知机制-Condition" class="headerlink" title="Lock中的等待通知机制-Condition"></a>Lock中的等待通知机制-Condition</h2><p>管程中最主要的一个功能就是wait的等待通知机制。那么lock的等待通知机制则是Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等同于 object.wait()</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等同于 object.notify() object.notifyAll();</span></span><br><span class="line">    condition.signal();</span><br><span class="line">    condition.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作异步转同步"><a href="#操作异步转同步" class="headerlink" title="操作异步转同步"></a>操作异步转同步</h2><p>有些操作本身是异步的，但是我们在使用中需要同步的场景，比如dubbo中我们的客户端通过tcp发送数据给服务端后，我们需要接收到返回值才能继续处理请求。而tcp本身就是异步的。这时候就需要同步转异步操作是如何实现的呢,见DefaultFeature，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object ret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待结果转同步</span></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                condition.await(<span class="number">1000L</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ret = response;</span><br><span class="line">            <span class="comment">//在别的线程获取结果后异步通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock的最佳实践"><a href="#lock的最佳实践" class="headerlink" title="lock的最佳实践"></a>lock的最佳实践</h2><p>永远只用于锁要修改的成员表变量<br>永远只在访问可变的成员标量加锁<br>永远不要在调用其他对象的方法加锁—因为你不确定他内部是如何实现的</p><p>推荐阅读：</p><p>Doug Lea《Java 并发编程：设计原则与模式》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;再造管程的意义&quot;&gt;&lt;a href=&quot;#再造管程的意义&quot; class=&quot;headerlink&quot; title=&quot;再造管程的意义&quot;&gt;&lt;/a&gt;再造管程的意义&lt;/h2&gt;&lt;p&gt;  java的管程的关键字是synchronized，在1.6后对管程做了升级，引入了偏向锁，轻量级
      
    
    </summary>
    
      <category term="java" scheme="https://liuhao163.github.io/categories/java/"/>
    
      <category term="并发" scheme="https://liuhao163.github.io/categories/java/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java" scheme="https://liuhao163.github.io/tags/java/"/>
    
      <category term="并发" scheme="https://liuhao163.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="aqs" scheme="https://liuhao163.github.io/tags/aqs/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://liuhao163.github.io/dubbo/index/"/>
    <id>https://liuhao163.github.io/dubbo/index/</id>
    <published>2022-09-21T15:03:02.192Z</published>
    <updated>2022-09-21T15:03:02.192Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MyBatisy源码-概述</title>
    <link href="https://liuhao163.github.io/MyBatisy%E6%BA%90%E7%A0%81-%E6%A6%82%E8%BF%B0/"/>
    <id>https://liuhao163.github.io/MyBatisy源码-概述/</id>
    <published>2022-06-15T13:19:19.000Z</published>
    <updated>2022-09-21T15:03:02.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  mybatis在国内是是java-web开发里非常重要的框架，通过xml配置的mappr对数据库进行了orm映射，降低程序对数据库访问的开发难度。</p><p>  希望通过阅读mybatis源码可以了解orm框架都有哪些角色，每个角色的边界是什么</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>  作用：加载配置文件活着注解。</p><p>  关键类：Configuration：该对象加载了配置里的数据源、mappr的映射即“MappedStatement”，并且缓存到内存中</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><pre><code>作用：关键类：MappedStatement</code></pre><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><pre><code>作用：关键类：Executor</code></pre><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><pre><code>作用：关键类：</code></pre><ol><li>StatementHandler</li><li>ParamenterHandler</li><li>ResultSetHandler</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;  mybatis在国内是是java-web开发里非常重要的框架，通过xml配置的mappr对数据库进行了orm映射，降低程序对数据库访问的
      
    
    </summary>
    
      <category term="java" scheme="https://liuhao163.github.io/categories/java/"/>
    
      <category term="mybatis" scheme="https://liuhao163.github.io/categories/java/mybatis/"/>
    
    
      <category term="java" scheme="https://liuhao163.github.io/tags/java/"/>
    
      <category term="orm" scheme="https://liuhao163.github.io/tags/orm/"/>
    
      <category term="mybatis" scheme="https://liuhao163.github.io/tags/mybatis/"/>
    
      <category term="源码" scheme="https://liuhao163.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>状态机</title>
    <link href="https://liuhao163.github.io/%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>https://liuhao163.github.io/自动机/</id>
    <published>2022-05-22T16:47:08.000Z</published>
    <updated>2022-09-21T15:03:02.372Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷题lc8写一个string–&gt;int的函数，结题思路是用限自动机的方案</p><ol><li>穷举有几种数字状态“ ”,”+/-“,”0-9”,”其他字符”，对应的 start、signin_number、end</li><li>穷举每种状态之间转化关系</li><li>遇到每种字符后，处理每种状态的逻辑</li></ol><h2 id="源码如下："><a href="#源码如下：" class="headerlink" title="源码如下："></a>源码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Integer.MIN_VALUE);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().myAtoi(<span class="string">"123213213213213211234"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Automation automation=<span class="keyword">new</span> Automation();</span><br><span class="line">        <span class="keyword">return</span> automation.cal(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Automation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> String curState = <span class="string">"start"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Automation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            initStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                parseChar(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sign * (<span class="keyword">int</span>) res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//穷举当前状态和下一个状态的对应关系</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//' '、+/-、0-9、other"</span></span><br><span class="line">            map.put(<span class="string">"start"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"start"</span>, <span class="string">"sign"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"sign"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"innumber"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"end"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理每种对应关系</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            String state = map.get(curState)[getNextState(c)];</span><br><span class="line">            <span class="keyword">if</span> (state.equals(<span class="string">"innumber"</span>)) &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">                res = sign == <span class="number">1</span> ? Math.min(res, (<span class="keyword">long</span>) Integer.MAX_VALUE) : Math.min(res, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(<span class="string">"sign"</span>)) &#123;</span><br><span class="line">                sign = c == <span class="string">'-'</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curState = state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextState</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当我们的系统复杂度到一定程度的时候，对象的状态分支会很多，我们可以选择用if，else来解决，但是最后往往会写出一堆几乎无法维护的屎山。那么我们可以将对象抽象成一个个状态，特殊情况实际上就是状态之间的转换。</p><p>比如上题，就是有限的状态之间的转换。<br><img src="/自动机/img0.png" alt="avator"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近刷题lc8写一个string–&amp;gt;int的函数，结题思路是用限自动机的方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;穷举有几种数字状态“ ”,”+/-“,”0-9”,”其他字符”，对应的 start、signin_number、end&lt;/li&gt;
&lt;li&gt;穷举每种状态之间转化关系&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liuhao163.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="https://liuhao163.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="设计模式" scheme="https://liuhao163.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="算法" scheme="https://liuhao163.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://liuhao163.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ebpf学习-初探ebpf</title>
    <link href="https://liuhao163.github.io/ebpf%E5%AD%A6%E4%B9%A0-%E5%88%9D%E6%8E%A2ebpf/"/>
    <id>https://liuhao163.github.io/ebpf学习-初探ebpf/</id>
    <published>2022-03-11T16:02:05.000Z</published>
    <updated>2022-09-21T15:03:02.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ebpf是什么"><a href="#ebpf是什么" class="headerlink" title="ebpf是什么"></a>ebpf是什么</h2><p>  Linux内核一直是实现监视/可观察性，网络和安全性的理想场所。不幸的是，这通常是不切实际的，因为它需要更改内核源代码或加载内核模块，并导致彼此堆叠的抽象层。 eBPF是一项革命性的技术，可以在Linux内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。通过使Linux内核可编程，基础架构软件可以利用现有的层，从而使它们更加智能和功能丰富，而无需继续为系统增加额外的复杂性层。</p><p>  eBPF导致了网络，安全性，应用程序配置/跟踪和性能故障排除等领域的新一代工具的开发，这些工具不再依赖现有的内核功能，而是在不影响执行效率或安全性的情况下主动重新编程运行时行为。</p><p>  如果直接解释eBPF，有点不明所以。那我们就看看有哪些基于eBPF的工程，这些工程或许你已经知道，或是已经经常使用，也许你会明白eBPF距离我们并不遥远。</p><h2 id="基于eBPF的项目"><a href="#基于eBPF的项目" class="headerlink" title="基于eBPF的项目"></a>基于eBPF的项目</h2><ol><li><p>bcc<br>BCC是用于创建基于eBPF的高效内核跟踪和操作程序的工具包，其中包括一些有用的命令行工具和示例。 BCC简化了用C进行内核检测的eBPF程序的编写，包括LLVM的包装器以及Python和Lua的前端。它还提供了用于直接集成到应用程序中的高级库。</p></li><li><p>bpftrace<br>bpftrace是Linux eBPF的高级跟踪语言。它的语言受awk和C以及DTrace和SystemTap等以前的跟踪程序的启发。 bpftrace使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p></li><li><p>Cilium<br>Cilium是一个开源项目，提供基于eBPF的联网，安全性和可观察性。它是从头开始专门设计的，旨在将eBPF的优势带入Kubernetes的世界，并满足容器工作负载的新可伸缩性，安全性和可见性要求。</p></li><li><p>Falco<br>Falco是一种行为活动监视器，旨在检测应用程序中的异常活动。 Falco在eBPF的帮助下审核Linux内核层的系统。它使用其他输入流（例如容器运行时度量标准和Kubernetes度量标准）丰富了收集的数据，并允许连续监视和检测容器，应用程序，主机和网络活动。</p></li><li><p>Katran<br>Katran是一个C ++库和eBPF程序，用于构建高性能的第4层负载平衡转发平面。 Katran利用Linux内核中的XDP基础结构来提供用于快速数据包处理的内核功能。它的性能与NIC接收队列的数量成线性比例，并且使用RSS友好的封装转发到L7负载平衡器。</p></li><li><p>Sysdig</p><p>Sysdig是提供深层系统可见性的简单工具，并具有对容器的原生支持。<br>其他基于eBPF技术的项目还有很多，比如kubectl-trace ，ply 等，这里不再赘述。</p></li></ol><h2 id="一个简单的DEMO"><a href="#一个简单的DEMO" class="headerlink" title="一个简单的DEMO"></a>一个简单的DEMO</h2><p> 下面我们写一个简单的demo来展示下开发一个ebpf程序需要哪些步骤，这里我们采用Cilium/ebpf库进行开发，因为ebpf的用户态代码可以用golang开发。:P</p><p> 程序是通过ebpf的tracepoint监听syscalls/sys_enter_execve，在执行该方法时候获取pid和commd。通过ebpf的map将pid和commd传到用户态。</p><h3 id="step-1-环境搭建"><a href="#step-1-环境搭建" class="headerlink" title="step.1 环境搭建"></a>step.1 环境搭建</h3><p>系统配置： Ubuntu 20.04.4<br>系统依赖： llvm，clang-10.0.0-4ubuntu1，还有linux的kernel这里源码在路径（/kernel-src），golang环境</p><h3 id="step-2-编写ebpf的kernel侧的程序-c代码"><a href="#step-2-编写ebpf的kernel侧的程序-c代码" class="headerlink" title="step.2 编写ebpf的kernel侧的程序-c代码"></a>step.2 编写ebpf的kernel侧的程序-c代码</h3><ol><li>编写代码并且用下面命令将代码变成bpf_program.o<br>clang -O2 -target bpf -c bpf_program.c -I/kernel-src/tools/testing/selftests/bpf  -o bpf_program.o</li><li>将bpf_program.o文件copy到golang程序下</li></ol><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义c的结构，将pid和comm封装到该结构体，将该结构体通过tracker_map传递给用户态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_data_t</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    <span class="keyword">char</span> comm[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ebpf的map</span></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> tracker_map </span>= &#123;</span><br><span class="line">        .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="keyword">sizeof</span>(struct <span class="keyword">event_data_t</span>),</span><br><span class="line">        .max_entries = <span class="number">2048</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ebpf程序挂载点，</span></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_data_t</span> <span class="title">evt</span> = &#123;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    __u64 id = bpf_get_current_pid_tgid();</span><br><span class="line">    evt.pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    bpf_get_current_comm(&amp;evt.comm, <span class="keyword">sizeof</span>(evt.comm));</span><br><span class="line">    bpf_map_update_elem(&amp;tracker_map, &amp;index, &amp;evt, BPF_ANY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><h3 id="step3用户态侧代码-golang的代码"><a href="#step3用户态侧代码-golang的代码" class="headerlink" title="step3用户态侧代码-golang的代码"></a>step3用户态侧代码-golang的代码</h3><ul><li>编写go代码</li><li>执行go build ./</li><li>执行go程序，这里是go-tools</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapKey <span class="keyword">uint32</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ebpf标签的说明</span></span><br><span class="line"><span class="comment">// BpfProg对应的是c程序中的bSEC(tracepoinst/...)的方法名</span></span><br><span class="line"><span class="comment">// TrackerMap对应的c程序中的SEC(map)</span></span><br><span class="line"><span class="keyword">type</span> bpfPrograms <span class="keyword">struct</span> &#123;</span><br><span class="line">BpfProg    *ebpf.Program <span class="string">`ebpf:"bpf_prog"`</span></span><br><span class="line">TrackerMap *ebpf.Map     <span class="string">`ebpf:"tracker_map"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *bpfPrograms)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := p.BpfProg.Close()</span><br><span class="line">err = p.TrackerMap.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段类型，对应c程序中的event_data_t类型，注意Comm是uint8</span></span><br><span class="line"><span class="keyword">type</span> EventData <span class="keyword">struct</span> &#123;</span><br><span class="line">Pid  <span class="keyword">uint32</span></span><br><span class="line">Comm [<span class="number">20</span>]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EventData)</span> <span class="title">CommHex</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ba := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> e.Comm &#123;</span><br><span class="line">ba = <span class="built_in">append</span>(ba, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(ba)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadTestEbpf</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> err := rlimit.RemoveMemlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载c编译出来的.o文件的相对路径,这个地址一定不能出错</span></span><br><span class="line">spec, err := ebpf.LoadCollectionSpec(<span class="string">"ebpf/bpf_program.o"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值obj</span></span><br><span class="line">obj := bpfPrograms&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := spec.LoadAndAssign(&amp;obj, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> obj.Close()</span><br><span class="line"></span><br><span class="line">tp, err := link.Tracepoint(<span class="string">"syscalls"</span>, <span class="string">"sys_enter_execve"</span>, obj.BpfProg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tp.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read loop reporting the total amount of times the kernel</span></span><br><span class="line"><span class="comment">// function was entered, once per second.</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">log.Println(<span class="string">"Waiting for events.."</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//c的结构体序列化成bytes（value）</span></span><br><span class="line"><span class="keyword">if</span> err := obj.TrackerMap.Lookup(&amp;mapKey, &amp;value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"reading map: %v"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> event EventData</span><br><span class="line"><span class="comment">//c的结构体序列化成golang的喜爱那个并且打印出来</span></span><br><span class="line"><span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(value), binary.LittleEndian, &amp;event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"parsing perf event: %s"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"pid:%v,comm:%v"</span>, event.Pid, event.CommHex())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序入口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ebpf.LoadTestEbpf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3，运行查看效果"><a href="#step3，运行查看效果" class="headerlink" title="step3，运行查看效果"></a>step3，运行查看效果</h3><ul><li>在终端1上运行：./go-tools</li><li>在中断2上输入任何指令</li><li>查看终端1的输出</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">03</span>/<span class="number">11</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">26</span> reading <span class="keyword">map</span>: lookup: key does not exist</span><br><span class="line"><span class="number">2022</span>/<span class="number">03</span>/<span class="number">11</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">30</span> pid:<span class="number">60184</span>,comm:sshd</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ebpf是什么&quot;&gt;&lt;a href=&quot;#ebpf是什么&quot; class=&quot;headerlink&quot; title=&quot;ebpf是什么&quot;&gt;&lt;/a&gt;ebpf是什么&lt;/h2&gt;&lt;p&gt;  Linux内核一直是实现监视/可观察性，网络和安全性的理想场所。不幸的是，这通常是不切实际的，因
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="工具" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ebpf" scheme="https://liuhao163.github.io/tags/ebpf/"/>
    
      <category term="内核编程" scheme="https://liuhao163.github.io/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C语言" scheme="https://liuhao163.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>用antlr开发一个简单的规则引擎</title>
    <link href="https://liuhao163.github.io/%E7%94%A8antlr%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
    <id>https://liuhao163.github.io/用antlr开发一个简单的规则引擎/</id>
    <published>2022-03-11T16:01:00.000Z</published>
    <updated>2022-09-21T15:03:02.283Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang源码学习-sync.Map</title>
    <link href="https://liuhao163.github.io/Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sync-Map/"/>
    <id>https://liuhao163.github.io/Go语言源码学习-sync-Map/</id>
    <published>2021-12-15T11:20:52.000Z</published>
    <updated>2022-09-21T15:03:02.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>  位于sync包中，主要解决map的线程安全的问题，适用于读多写少的场景。</p><h2 id="sync-Map的原理"><a href="#sync-Map的原理" class="headerlink" title="sync.Map的原理"></a>sync.Map的原理</h2><p>  内部持有俩个map，一个是read，类型是atomic.Value实际类型是【map[interface{}]<em>entry】，一个是dirty类型是map【[interface{}]</em>entry】。</p><p>  其中read主要解决无数据竞争的情况下数据的快速访问，它通过cas进行快速的读写操作；一旦出现数据的竞争，就会用到dirty，dirty里面保存read里所有非nil的值【通过状态来表示unexpunged】，当出现竞争后数据会写到dirty而不是read中。</p><p>  数据的访问路径大致是：</p><ul><li>读，先从read里找，read里没有，去dirty里找，如果miss过一定的阈值【dirty的长度】时候，将dirty和read交换，交换后dirty置为nil；</li><li><p>写，先判断key是否存在，如果存在且不为expunaged，先通过cas写快速返回，否则有如下分支：</p><ul><li>如果key是expunaged，说明key之前被删除了，但是dirty没有，unexpunaged之后同步修改read和dirty</li><li>如果key不存在于read，但是存在于dirty修改dirty</li><li>如果key不存在与read和dirty，初始化dirty【如果需要】，数据写入dirty</li></ul><p>因为数据在并发写的时候一旦发生竞争还是会用到锁，并发写的时候的锁是不可避免的。所以sync.Map适用于读多写少数据冲突不那么复杂的场景</p></li></ul><h2 id="sync-Map的源码分析"><a href="#sync-Map的源码分析" class="headerlink" title="sync.Map的源码分析"></a>sync.Map的源码分析</h2><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex <span class="comment">//锁 用来保护read、dirty的并发控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read包含部分map的内容，他是atomic.Value类型的用来解决并发访问的安全的问题，在读的场景不需要加锁，而在写的场景需要mu的控制</span></span><br><span class="line">read atomic.Value <span class="comment">// readOnly </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dirty访问要在mu的保护下进行，他包含所有的readOnly里non-expunged的数据</span></span><br><span class="line"><span class="comment">// 在read中标记为Expunged的entries不会被存储在dirt中，如果一个在read中存在的key被标记为expunged,他需要先unexpunged在保存在dirty中</span></span><br><span class="line"><span class="comment">// 如果dirty是nil，当下一次修改map的时候需要初始化dirty，初始化的方式是将read的不为exunped的value都copy到dirty中</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器，当从read读取数据时候miss回增加该值，打到一定的阈值，即miss&gt;=len(dirty)的时候回触发dirty和read的互换</span></span><br><span class="line">misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read中的值</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 一个标记为，默认是false，true说明readOnly的m和dirty已经同步过了，即dirty不为nil了，在Store操作中，dirtyLocked函数调用后会置为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 封装了指向value值的指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If p == nil, the entry has been deleted and m.dirty == nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry</span></span><br><span class="line"><span class="comment">// is missing from m.dirty.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span></span><br><span class="line"><span class="comment">// != nil, in m.dirty[key].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An entry can be deleted by atomic replacement with nil: when m.dirty is</span></span><br><span class="line"><span class="comment">// next created, it will atomically replace nil with expunged and leave</span></span><br><span class="line"><span class="comment">// m.dirty[key] unset.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An entry's associated value can be updated by atomic replacement, provided</span></span><br><span class="line"><span class="comment">// p != expunged. If p == expunged, an entry's associated value can be updated</span></span><br><span class="line"><span class="comment">// only after first setting m.dirty[key] = e so that lookups using the dirty</span></span><br><span class="line"><span class="comment">// map find the entry.</span></span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记位当entry.p=expunged说明，该对象在read中被删除，标记了expunged的key不会出现在dirty中。</span></span><br><span class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;))</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">//从read中获取readOnly，如果key存在，通过cas修改不为expunged的值，成功后快速返回</span></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改失败通过锁进行鬓发保护</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)<span class="comment">//双重检查</span></span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="comment">//key存在于read但是状态是expunged，cas修改成nil，同步dirty和readOnly的值，</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line"><span class="comment">//走到这里说明dirty已经被初始化了，见m.dirtyLocked()里e.tryExpungeLocked()这一步</span></span><br><span class="line">m.dirty[key] = e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cas保存value</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">//key存在于dirty</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//!read.amended说明dirty为空初始化dirty，将read中不为expunged值写入dirty，见下面</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">m.dirtyLocked()</span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改dirty的值</span></span><br><span class="line">m.dirty[key] = newEntry(value)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">m.dirty[k] = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="comment">//优先读取read</span></span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="comment">//key不存在但是dirty已经初始化，这里需要锁来保护并发冲突</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)<span class="comment">//双重检查</span></span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="comment">//从dirty里取</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="comment">//超过阈值交换dirty和read,并且dirty置为nil，见下面</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载value</span></span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">e.<span class="built_in">delete</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sync-Map&quot;&gt;&lt;a href=&quot;#sync-Map&quot; class=&quot;headerlink&quot; title=&quot;sync.Map&quot;&gt;&lt;/a&gt;sync.Map&lt;/h2&gt;&lt;p&gt;  位于sync包中，主要解决map的线程安全的问题，适用于读多写少的场景。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="golang" scheme="https://liuhao163.github.io/categories/golang/"/>
    
      <category term="源码学习" scheme="https://liuhao163.github.io/categories/golang/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="golang" scheme="https://liuhao163.github.io/tags/golang/"/>
    
      <category term="源码学习" scheme="https://liuhao163.github.io/tags/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal如何在子线程传递</title>
    <link href="https://liuhao163.github.io/ThreadLocal%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92/"/>
    <id>https://liuhao163.github.io/ThreadLocal如何在子线程传递/</id>
    <published>2021-11-01T20:37:23.000Z</published>
    <updated>2022-09-21T15:03:02.191Z</updated>
    
    <content type="html"><![CDATA[<p>主线程如何向自己创建的子线程传递ThreadLocal值，只需要创建InheritableThreadLocal值,实现原理如下：</p><p>InheritableThreadLocal覆写了它三个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程时候，会调用该方法,见下面init</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Map时候，返回的是t.inheritableThreadLocals，见ThreadLocal操作值</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createMap时候，返回的是t.inheritableThreadLocals，见ThreadLocal操作值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>见子线程初始化过程,初始化时候如果当前线程inheritableThreadLocals不为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//这里初始的是this.inheritableThreadLocals</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocal.createInheritedMap会调用ThreadLocalMap(ThreadLocalMap parentMap)方法，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里调用InheritableThreadLocal覆写的childValue，返回的是parent的value，将parent的值copy到子线程中</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么inheritableThreadLocals它什么时候不为空呢，见下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在set值时候判断ThreadLocalMap为空，调用InheritableThreadLocal.getMap方法返回当前线程的t.inheritableThreadLocals，否则初始化t.inheritableThreadLocals</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取的是t.inheritableThreadLocals的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除值实际上删除的t.inheritableThreadLocals</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主线程如何向自己创建的子线程传递ThreadLocal值，只需要创建InheritableThreadLocal值,实现原理如下：&lt;/p&gt;
&lt;p&gt;InheritableThreadLocal覆写了它三个方法:&lt;/p&gt;
&lt;figure class=&quot;highlight jav
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="工具" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="https://liuhao163.github.io/tags/java/"/>
    
      <category term="并发" scheme="https://liuhao163.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="案例分析" scheme="https://liuhao163.github.io/tags/%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>坑-下载文件，丢失文件格式和后缀</title>
    <link href="https://liuhao163.github.io/%E5%9D%91-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%A2%E5%A4%B1%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%90%8E%E7%BC%80/"/>
    <id>https://liuhao163.github.io/坑-下载文件，丢失文件格式和后缀/</id>
    <published>2021-10-11T15:19:51.000Z</published>
    <updated>2022-09-21T15:03:02.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>将记录导出成excel供下载，生成xlsl以后下载文件会丢失文件格式，curl链接情况如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bogon:~ liuhaoeric$ curl -vvv https:<span class="comment">//xxxxxx.xlsx -output xxxxx.xlsx </span></span><br><span class="line">.....</span><br><span class="line">&lt; Content-Disposition: inline; filename=<span class="string">"xxxxx"</span> <span class="comment">//上传时候需制定filename这就是下载的文件名，如果filename未制定文件后缀名下载就会丢失文件格式</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上传时候指定filename时候xxxxx.xlsx</p><p>在curl发现代码已经变为如下所示，问题解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; Content-Disposition: inline; filename=<span class="string">"xxxxx.xlsx"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;将记录导出成excel供下载，生成xlsl以后下载文件会丢失文件格式，curl链接情况如下&lt;/p&gt;
&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="工具" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>SSL的请求过程</title>
    <link href="https://liuhao163.github.io/SSL%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <id>https://liuhao163.github.io/SSL的请求过程/</id>
    <published>2021-08-13T15:22:02.000Z</published>
    <updated>2022-09-21T15:03:02.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>  公钥即证书：由服务端传递给客户端，用于客户端的CA证书校验合法性；非对称加密clientKey；<br>  CA证书：内置于系统中用于校验公钥的合法性<br>  私钥：服务端保存，用于非对称解密clientKey<br>  clientKey：公钥验证通过后由浏览器生成clientKey通过对称加密和服务端进行交互</p><h2 id="发送请求的过程"><a href="#发送请求的过程" class="headerlink" title="发送请求的过程"></a>发送请求的过程</h2><ol><li>浏览器发送请求给服务端，这时候端口是443；</li><li>服务端返回公钥【证书】给客户端；</li><li>浏览器通过系统内置的CA证书验证证书的合法性，如果不合法请求终止；</li><li>浏览器生成clientKey明文，并且用公钥加密clientKey，发送密文的clientKey给服务端；</li><li>服务端得到加密过的公钥，用私钥解密，获取明文clientKey；</li><li>浏览器用clientKey通过对称加密方式通信：<ol><li>浏览器通过clientKey加密请求，发送给服务端；</li><li>服务端通过clientKey解密请求，并且将响应用clientKey加密发给浏览器；</li><li>浏览器接到密文响应，用clientKey解密；</li></ol></li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/SSL的请求过程/img.png" alt="avator"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;名词解释&quot;&gt;&lt;a href=&quot;#名词解释&quot; class=&quot;headerlink&quot; title=&quot;名词解释&quot;&gt;&lt;/a&gt;名词解释&lt;/h2&gt;&lt;p&gt;  公钥即证书：由服务端传递给客户端，用于客户端的CA证书校验合法性；非对称加密clientKey；&lt;br&gt;  CA证书：内
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="工具" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="协议、知识积累" scheme="https://liuhao163.github.io/tags/%E5%8D%8F%E8%AE%AE%E3%80%81%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何保证缓存和数据库的数据一致</title>
    <link href="https://liuhao163.github.io/%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/"/>
    <id>https://liuhao163.github.io/如何保证缓存和数据库的数据一致/</id>
    <published>2021-06-25T00:00:00.000Z</published>
    <updated>2022-09-21T15:03:02.226Z</updated>
    
    <content type="html"><![CDATA[<p>  本篇文章主要讨论常见的集中缓存的使用方案，以及如何解决数据和缓存的一致性</p><h2 id="常见的缓存模式"><a href="#常见的缓存模式" class="headerlink" title="常见的缓存模式"></a>常见的缓存模式</h2><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache-Aside Pattern"></a>Cache-Aside Pattern</h3><p>我们常见的缓存方案，可以说我们大部分都采用这种方案，见下面:</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Aside Pattern.jpg" alt="avator"></p><h3 id="Read-Through-Write-through（读写穿透）"><a href="#Read-Through-Write-through（读写穿透）" class="headerlink" title="Read-Through/Write through（读写穿透）"></a>Read-Through/Write through（读写穿透）</h3><p>本质上和Cache-Aside Pattern类似，只是在程序和缓存中增加了一层Cache Provider，读写如果未命中由Cache Proxy来负责和缓存交互。减少程序开发的复杂性，需要中间件支持</p><h4 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h4><p><img src="/如何保证缓存和数据库的数据一致/Read-Through.jpg" alt="avator"></p><h4 id="Write-through"><a href="#Write-through" class="headerlink" title="Write through"></a>Write through</h4><p><img src="/如何保证缓存和数据库的数据一致/Write-Through.jpg" alt="avator"></p><h3 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h3><p>和Read-Through/Write through类似，区别是Write behind模式下，数据都是写到Cache Provider，由Cache Provider异步的刷到数据库中，听着是不是很熟悉，对Mysql的WAL异步刷盘就是这种模式</p><p><img src="/如何保证缓存和数据库的数据一致/Write-Behind.jpg" alt="avator"></p><h2 id="如何保证缓存和数据库的数据一致"><a href="#如何保证缓存和数据库的数据一致" class="headerlink" title="如何保证缓存和数据库的数据一致"></a>如何保证缓存和数据库的数据一致</h2><p>这里是以常见的Cache-Aside Pattern来讨论，正确操作缓存的姿势是</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Update.jpg" alt="avator"></p><p>这里要注意俩点</p><h3 id="不是更新缓存而是要删除缓存"><a href="#不是更新缓存而是要删除缓存" class="headerlink" title="不是更新缓存而是要删除缓存"></a>不是更新缓存而是要删除缓存</h3><p>如果更新缓存不是删除缓存在并发场景下会出现脏数据里有如下：</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Update-Dirty.jpg" alt="avator"></p><ol><li>线程A先发起一个写操作，第一步先更新数据库</li><li>线程B再发起一个写操作，第二步更新了数据库</li><li>由于网络等原因，线程B先更新了缓存</li><li>线程A更新缓存。</li></ol><p>这时DB是B操作后的数据，缓存是A操作的数据</p><h3 id="要先操作数据库而不是先操作缓存"><a href="#要先操作数据库而不是先操作缓存" class="headerlink" title="要先操作数据库而不是先操作缓存"></a>要先操作数据库而不是先操作缓存</h3><p>如果先操作缓存不是先操作数据库会在并发场景下会出现脏数据里有如下：</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Write-Dirty.jpg" alt="avator"></p><ol><li>线程A发起一个写操作，第一步del cache</li><li>此时线程B发起一个读操作，cache miss</li><li>线程B继续读DB，读出来一个老数据</li><li>然后线程B把老数据设置入cache</li><li>线程A写入DB最新的数据</li></ol><p>这时DB是A操作后的数据，缓存是B操作后的数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  本篇文章主要讨论常见的集中缓存的使用方案，以及如何解决数据和缓存的一致性&lt;/p&gt;
&lt;h2 id=&quot;常见的缓存模式&quot;&gt;&lt;a href=&quot;#常见的缓存模式&quot; class=&quot;headerlink&quot; title=&quot;常见的缓存模式&quot;&gt;&lt;/a&gt;常见的缓存模式&lt;/h2&gt;&lt;h3 id=
      
    
    </summary>
    
      <category term="经验积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
      <category term="项目积累" scheme="https://liuhao163.github.io/categories/%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/%E9%A1%B9%E7%9B%AE%E7%A7%AF%E7%B4%AF/"/>
    
    
      <category term="缓存" scheme="https://liuhao163.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="数据一致性" scheme="https://liuhao163.github.io/tags/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
</feed>
