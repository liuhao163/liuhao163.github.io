<hr>
<p>title: Mysql是如何保证数据不丢失的<br>date: 2019-02-02 00:00:00</p>
<h2 id="categories-Mysql-Mysql基础"><a href="#categories-Mysql-Mysql基础" class="headerlink" title="categories: [Mysql,Mysql基础]"></a>categories: [Mysql,Mysql基础]</h2><h1 id="Mysql是如何保证数据不丢失的"><a href="#Mysql是如何保证数据不丢失的" class="headerlink" title="Mysql是如何保证数据不丢失的"></a>Mysql是如何保证数据不丢失的</h1><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><ol>
<li>事务执行过程中binlog写入到binlog cache,事务提交时写入到binlog文件中。</li>
<li>事务的原子性决定这无论事务有多大，binlogcahe都要一次性完整的写入到binlog文件中，写入方式如下：<ol>
<li>系统为每个binlog_cache开辟了一片内存（每个线程都有一个），参数是blong_cache_size,超过这个阈值的会保存在临时文件中</li>
<li>事务提交时候，出于性能的考虑回将bionlog_cache都write到文件系统的page_cache中，在通过fsync刷新到磁盘文件中。如下图所示是binlog的同步机制。</li>
</ol>
</li>
</ol>
<p>如图：<br><img src="/images/mysql/binglog_写入.png" alt="avatar"></p>
<ul>
<li>只有fsnyc刷盘这不操作才会占用IOPS。</li>
<li>write和fsync的时机是用binglog_sync参数来控制的<ul>
<li>=0 每次事务提交时候都只write不sync</li>
<li>=1 每次事务提交都sync</li>
<li>=N（N&gt;1） 每次事务提交都write，积攒到N时候才会fsync</li>
</ul>
</li>
</ul>
<p>在IO出现瓶颈时候我们可以设置一个较大的值来提升性能（个人不是很推荐做，如果出现这种情况建议从业务考虑优化数据库）</p>
<h2 id="redolog的写入机制"><a href="#redolog的写入机制" class="headerlink" title="redolog的写入机制"></a>redolog的写入机制</h2><p>redolog从写入到最终写入到磁盘中会经历如下的阶段：写入redolog-buffer中–&gt;在事务提交、或者一定时机（见下面）下：redolog-buffer写入到文件系统的pagecache(write)–&gt;文件系统pagecache写入到磁盘中(fsnyc)，这样的操作的意义是为了提高mysql的吞吐的，具体的机制见下面：</p>
<p><img src="/images/mysql/redolog_3种状态.png" alt="avatar"></p>
<ol>
<li>一个事务会产生很多条redolog如果每次直接持久化磁盘会消耗大量的磁盘IO，所以redolog会先写入redolog-buffer中，之后在write文件系统的到pagecache中，这俩步是内存操作很快。</li>
<li>是否会影响数据的持久化，比如mysql在事务进行中crash了，这时候redolog-buffer中的数据丢失怎么办？答案是由于事物没有提交，所以事物会进行回滚。</li>
<li>redolog-buffer持久化的条件和机制：<ol>
<li>受参数innodb_flush_log_at_tx_commit的控制：<ol>
<li>=0：每次提交都只停留在redolog-buffer中；</li>
<li>=1：每次提交都会持久化到磁盘中；</li>
<li>=2：每次提交都只会写入到文件的pagecache中；</li>
</ol>
</li>
<li>innodb后台会有一个线程每秒一次，会把redolog-buffer中的日志，调用write写到pagecahe中，在fsync到磁盘中；</li>
<li>其他场景触发redolog的持久化<ol>
<li>当redolog-buffer占到了innodb_log_buffer_size的一半时候，会调用write将buffer中的log写入到文件系统的pagecache中</li>
<li>另一种是并行事物提交时候，如果innodb_flush_log_at_tx_commit设置为1时候会，即时当前事物没有commit，也会将redolog写入到文件系统中。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="双1设置"><a href="#双1设置" class="headerlink" title="双1设置"></a>双1设置</h3><p>即：binlogsnyc=1，innodb_flush_log_at_tx_commit也设置为1。<br>  由于innodb的事物提交redolog和binlog是2PC。<br>     所以当redolog在prepare时候，为了故障恢复一定会持久化一次，所以这时候需要fsync到磁盘中。<br>     binlog在进行fsync到磁盘中<br>     这时候事物在redolog在commit时候，mysql由于有奔溃恢复机制和后台线程每秒轮训一次刷盘会认为redolog没有必要在fsync一次到磁盘了，只会写入到文件的pagecache中。</p>
<h3 id="gourp-commit机制"><a href="#gourp-commit机制" class="headerlink" title="gourp commit机制"></a>gourp commit机制</h3><p>一个事物的提交由于redolog和binglog都要持久化，磁盘IO还是很大Mysql是如何优化这部分呢。这里mysql采用了组提交（group commit）的方式。<br>如图所示：<br><img src="/images/mysql/group_commit机制.png" alt="avatar"></p>
<ul>
<li>首先介绍下LSN(log sequence number)，一个单调递增的序号，用来对应redolog的一个个写入点。当然也会写入到数据页中，用于flush脏盘时候避免重复执行（不在讨论范围内）</li>
<li>如图，当3个事务同时都写完redolog-buffer 并且处于prepare阶段时候，这时候就构成了一个gourp<ol>
<li>第一个先到达的trx1，成为组里的leader，LSN=50;</li>
<li>等trx1开始写盘时候，组里已经有其他俩个事物，这时候LSN=160;</li>
<li>trx1开始写盘，所有lsn&lt;160的日志都会被写入到磁盘中；</li>
<li>trx3,trx4就可以直接返回了；</li>
</ol>
</li>
</ul>
<p>所以在并发事物中，当写完redolog，越晚调用fsync，带的log越多性能也就越好；mysql在这方法采用的是拖时间的策略，即:在双1配置下<br>  redolog-prepare(write)–&gt;binglog(write)–&gt;redolog-prepare(fsync)–&gt;binlog(fsnyc)–&gt;redolog commit(write)</p>
<p>如图：<br><img src="/images/mysql/redolog_binlog_groupcommit.png" alt="avatar"></p>
<ul>
<li>如上图所示，由于redolog在write和fsnyc中有一个binlog-write的过程，所以在持久化磁盘时候你可以带上更多的log；</li>
<li>另外：binlog也可以采用组提交，只不过由于这俩个阶段间隔短可能没有redolog那么明显<ul>
<li>binlog的gruop commit的参数如下：<ul>
<li>binlog_group_commit_sync_delay:表示延迟多少微妙后就会调用fsnyc</li>
<li>binlog_gourp_commit_sync_no_delay_count:表示累计多少次后才调用fsync</li>
<li>俩个参数是or的关系，不过如果binlog_group_commit_sync_delay设置为0，binlog_gourp_commit_sync_no_delay_count就无效了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>综上所述：</p>
<ul>
<li>mysql的WAL机制是由于redolog和binlog都是顺序写，保证了高吞吐；</li>
<li>同时采用了组提交的方式，来减少了IOPS;</li>
</ul>
