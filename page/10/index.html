<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="励志当好厨子的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="liuhao163.github.io">
<meta property="og:url" content="https://liuhao163.github.io/page/10/index.html">
<meta property="og:site_name" content="liuhao163.github.io">
<meta property="og:description" content="励志当好厨子的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liuhao163.github.io">
<meta name="twitter:description" content="励志当好厨子的程序员">



  <link rel="alternate" href="/atom.xml" title="liuhao163.github.io" type="application/atom+xml">




  <link rel="canonical" href="https://liuhao163.github.io/page/10/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>liuhao163.github.io – 杂七杂八</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liuhao163.github.io</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">杂七杂八</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>Sitemap</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Spring源码-带着问题学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Spring源码-带着问题学习/" class="post-title-link" itemprop="url">Spring源码-带着问题学习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-12-01 01:01:34" itemprop="dateCreated datePublished" datetime="2019-12-01T01:01:34Z">2019-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/spring/源码/" itemprop="url" rel="index"><span itemprop="name">源码</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>spring可以说是java有史以来最为庞大，应用最为广泛的框架，在看源码之前应该先立足于某一点在逐步发散到面。本文主要是整理观看spring源码前/中遇到的问题，以便于读代码更有针对性</p>
<h2 id="spring的IOC和AOP"><a href="#spring的IOC和AOP" class="headerlink" title="spring的IOC和AOP"></a>spring的IOC和AOP</h2><p>问题：</p>
<ol>
<li>Spring容器中的Bean的生命周期是什么？</li>
<li>对应的PostProcessor什么时候执行？有什么作用</li>
<li>BeanDefinition的架构以及spring的设计思想</li>
<li>BeanFactory和ApplicationContext的关系是什么？他们的作用是什么？</li>
<li>ApplicationContext的构造函数都做了什么？<ol>
<li>scan/register做了什么事？</li>
<li>refresh做了什么事？</li>
<li>refresh的详细的流程，对照着bean的生命周期看</li>
</ol>
</li>
<li>AnnotationConfigUtils.registerAnnotationConfigProcssors做什么用的？</li>
<li>Spring的自动装配策略是什么（byType–&gt;Primary–&gt;Propity–&gt;ByName）具体见<a href="https://www.jb51.net/article/157767.htm" target="_blank" rel="noopener">临时链接</a></li>
<li>ClassPathBeanDefinitionScanner、AnnotatedBeanDefinitionReader的作用 <a href="/Spring源码-类扫描器-ClassPathBeanDefinitionScanner">Spring源码-类扫描器-ClassPathBeanDefinitionScanner</a></li>
<li>为什么@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解这些注解能注册到容器中<a href="/Spring源码-实现自定义注解">Spring源码-实现自定义注解</a></li>
<li>Spring如何实现自定义注解，它是怎么实现的(CommponentScan，inculudFilter)</li>
<li>Resource到BeanDefiniton的过程相关的问题，从resource–&gt;SimpleMetadataReader–&gt;BeanDefinition（since 2020-01-28）<ol>
<li>SimpleMetadataReader的作用是什么？</li>
<li>需要用到的spring-io中的ResourceLoader需要明确是做什么用的</li>
<li>SimpleMetadataReader构造方法中用到了spring-asm是做什么用的</li>
<li>Lookup注解干什么用的</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/RoketMq源码学习-八-延迟队列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/RoketMq源码学习-八-延迟队列/" class="post-title-link" itemprop="url"> RoketMq源码学习-八-延迟队列</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-30 17:49:11" itemprop="dateCreated datePublished" datetime="2019-11-30T17:49:11Z">2019-11-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/" itemprop="url" rel="index"><span itemprop="name">消息队列</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/rocketmq/" itemprop="url" rel="index"><span itemprop="name">rocketmq</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/消息队列/rocketmq/源码学习/" itemprop="url" rel="index"><span itemprop="name">源码学习</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在业务中我们发送定时消息等会用到，延迟队列，rocketmq内置了该功能，帮我实现这种延迟队列。实现很简单</p>
<h2 id="实现方式、原理"><a href="#实现方式、原理" class="headerlink" title="实现方式、原理"></a>实现方式、原理</h2><ol>
<li>生成者发送消息时候为消息设置setDelayTimeLevel，mq不能自己指定延时时间而只能采用系统设置好的level</li>
<li>broker在putmessage时候会将message的real-topic备份，然后将message放到SCHEDULE_TOPIC_XXXX这个topic中，根据delayLevel制定不同的queueId。</li>
<li>ScheduleMessageService会启动timer定期扫描各个delayLevel的Queue，已经到执行时间的message在将SCHEDULE_TOPIC_XXXX的message移到real-topic中。</li>
</ol>
<p>缺点：由于是一个timer在扫描SCHEDULE_TOPIC_XXXX下所有queue的消息，如果消息积压过多于可能造成消息的发送延迟。可以考虑每个level用一个线程取扫描（不过也要考虑线程切换的成本导致频繁切换反而降低性能）</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>producer发送消息，设置level</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTimeLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.putProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL, String.valueOf(level));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><h4 id="broker处理putMessage"><a href="#broker处理putMessage" class="headerlink" title="broker处理putMessage"></a>broker处理putMessage</h4><ol>
<li>CommitLog.putMessage保存信息会将真实的topic的备份放到指定队列</li>
<li>DefaultMessageStore的ReputMessage在写CounmeQueue的时候会计算DeliverTime并且写入到tagCode中</li>
</ol>
<p>见代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//消息不是事物类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//延时消息--将消息投递到</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId 将消息设置成topic</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ConsumeQueue存储消息信息时候会将tagCode设置为发送的日期</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 生成重放消息重放调度请求，-1-失败，0-到文件尾，1-正常</span></span><br><span class="line">    DispatchRequest dispatchRequest =</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatchRequest <span class="title">checkMessageAndReturnSize</span><span class="params">(java.nio.ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">boolean</span> checkCRC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">final</span> <span class="keyword">boolean</span> readBody)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// Timing message processing 延时消息将tagsCode设置为时间戳，</span></span><br><span class="line">            &#123;</span><br><span class="line">                String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">                <span class="keyword">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> delayLevel = Integer.parseInt(t);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                        delayLevel = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//计算DeliverTimestamp</span></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        tagsCode = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,</span><br><span class="line">                                storeTimestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="ScheduleMessageService"><a href="#ScheduleMessageService" class="headerlink" title="ScheduleMessageService"></a>ScheduleMessageService</h4><p>  level的个数的设置由MessageStoreConfig的messageDelayLevel决定。rocketmq只能按照这个设置来决定消息的延迟时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化：BrokerController在initialize()时候初始化DefaultMessageStore，DefaultMessageStore会初始化ScheduleMessageService，ScheduleMessageService负责定时任务的check和调度。</li>
<li>load加载配置：BrokerController在initialize()会调用DefaultMessageStore的load，在该方法中会调用ScheduleMessageService的load,关键代码如下</li>
<li><p>启动：在BrokerController.start后，随着DefaultMessageStore的start而启动。</p>
<p>加载配置的过程</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DefaultMessageStore的关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduleMessageService的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    <span class="comment">//初始化配置的DelayLevel</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseDelayLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Long&gt; timeUnitTable = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</span><br><span class="line">    timeUnitTable.put(<span class="string">"s"</span>, <span class="number">1000L</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"m"</span>, <span class="number">1000L</span> * <span class="number">60</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"h"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"d"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    String levelString = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] levelArray = levelString.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelArray.length; i++) &#123;</span><br><span class="line">            String value = levelArray[i];</span><br><span class="line">            <span class="comment">//1h--&gt;ch=h,tu=1000L * 60 * 60</span></span><br><span class="line">            String ch = value.substring(value.length() - <span class="number">1</span>);</span><br><span class="line">            Long tu = timeUnitTable.get(ch);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化maxDelayLevel</span></span><br><span class="line">            <span class="keyword">int</span> level = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="keyword">this</span>.maxDelayLevel) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maxDelayLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1h--&gt;1</span></span><br><span class="line">            <span class="keyword">long</span> num = Long.parseLong(value.substring(<span class="number">0</span>, value.length() - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">long</span> delayTimeMillis = tu * num;</span><br><span class="line">            <span class="comment">//put levelIndex,1*1000L * 60 * 60</span></span><br><span class="line">            <span class="keyword">this</span>.delayLevelTable.put(level, delayTimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"parseDelayLevel exception"</span>, e);</span><br><span class="line">        log.info(<span class="string">"levelString String = &#123;&#125;"</span>, levelString);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>start</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历delayLevelTable，找到每个level的offset,然后异步的启动DeliverDelayedMessageTimerTask去检查</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">        Integer level = entry.getKey();</span><br><span class="line">        Long timeDelay = entry.getValue();</span><br><span class="line">        Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">            offset = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//关键代码，每个level和offset会创建一个DeliverDelayedMessageTimerTask，第一次FIRST_DELAY_TIME（1s后执行）</span></span><br><span class="line">            <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>DeliverDelayedMessageTimerTask没有采用for/while循环这种来保证扫描delayQueue的实时性，而是每次根据处理Messagge的结果在启动一</li>
<li>DeliverDelayedMessageTimerTask来控制频次、和保证实时性。在DeliverDelayedMessageTimerTask的run方法中调用executeOnTimeup这个是主要逻辑</li>
<li>由于延期消息是队列，所以相同粒度的延期信息一定是按照顺序写入到队列中的。所以如果当前消息没到发布时间，后面所有消息就都没到发布时间。具体见下面代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据delayLevel找到制定的consumerQueue</span></span><br><span class="line">    ConsumeQueue cq =</span><br><span class="line">        ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">            delayLevel2QueueId(delayLevel));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line">    <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//步骤1，在consumerQueue中根据偏移量找到这条消息的索引信息</span></span><br><span class="line">        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">        <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取cqExtUnit</span></span><br><span class="line">                ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">                    <span class="comment">//tagsCode-在conumeQueue持久化时候已经变味了DeliverTimestamp</span></span><br><span class="line">                    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">                            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">                            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                                tagsCode, offsetPy, sizePy);</span><br><span class="line">                            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//步骤2，计算过期时间</span></span><br><span class="line">                    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//修正deliverTimestamp,如果deliverTimestamp&gt;now+delayMills说明过期了</span></span><br><span class="line">                    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line"></span><br><span class="line">                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> countdown = deliverTimestamp - now;</span><br><span class="line">                    <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//到期了开始投递消息</span></span><br><span class="line">                        MessageExt msgExt =</span><br><span class="line">                            ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">                                offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//修改realTopic，发送消息</span></span><br><span class="line">                                MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt);</span><br><span class="line">                                PutMessageResult putMessageResult =</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore</span><br><span class="line">                                        .putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//发送成功后，继续处理下一条消息</span></span><br><span class="line">                                <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span></span><br><span class="line">                                    &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">//发送失败，10sec后在开始下一轮扫描</span></span><br><span class="line">                                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                                    log.error(</span><br><span class="line">                                        <span class="string">"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;"</span>,</span><br><span class="line">                                        msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                                        <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                            nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                        nextOffset);</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                log.error(</span><br><span class="line">                                    <span class="string">"ScheduleMessageService, messageTimeup execute error, drop it. msgExt="</span></span><br><span class="line">                                        + msgExt + <span class="string">", nextOffset="</span> + nextOffset + <span class="string">",offsetPy="</span></span><br><span class="line">                                        + offsetPy + <span class="string">",sizePy="</span> + sizePy, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//消息没到期，创建Task扫描一次该消息，延期countdown防止无谓的计算</span></span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                            <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset),</span><br><span class="line">                            countdown);</span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// end of for</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列所有消息都扫描结束后，100L后开启下一轮扫描</span></span><br><span class="line">                <span class="comment">//由于延期消息是队列，所以相同粒度的延期信息一定是按照顺序写入到队列中的。所以如果当前消息没到发布时间，后面所有消息就都没到发布时间。具体见下面代码</span></span><br><span class="line">                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(</span><br><span class="line">                    <span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                bufferCQ.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end of if (bufferCQ != null)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; cqMinOffset) &#123;</span><br><span class="line">                failScheduleOffset = cqMinOffset;</span><br><span class="line">                log.error(<span class="string">"schedule CQ offset invalid. offset="</span> + offset + <span class="string">", cqMinOffset="</span></span><br><span class="line">                    + cqMinOffset + <span class="string">", queueId="</span> + cq.getQueueId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of if (cq != null)</span></span><br><span class="line"></span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">        failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JAVA内存模型与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JAVA内存模型与线程/" class="post-title-link" itemprop="url">JAVA内存模型与线程</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-18 16:04:54" itemprop="dateCreated datePublished" datetime="2019-11-18T16:04:54Z">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  是对之前java并发的一个补充。：P</p>
<p>  java的操作都是将数据从主内存加载到工作内存去做操作，为了保证线程的安全归定了几个原子性操作。</p>
<h2 id="java的几个原子性操作"><a href="#java的几个原子性操作" class="headerlink" title="java的几个原子性操作"></a>java的几个原子性操作</h2><ul>
<li>read：主内存，将数据从主内存传输到工作内存，以便load使用</li>
<li>load：工作内存，将read的变量副本放入到工作内存中</li>
<li>assign：工作内存，赋值操作。将执行引擎（jvm）中的值赋值给变量。</li>
<li>use：工作内存，把工作内存中的值传递给执行引擎。</li>
<li>store：工作内存，将数据传输到主内存中，以便write操作使用</li>
<li>write：主内存，将数据写入到主内存中。</li>
<li>lock：主内存，将变量标识为线程独占</li>
<li>unlock：主内存，释放锁标记，标识变量变为共享状态。</li>
</ul>
<p>几个规定</p>
<ul>
<li>read和load，store和write成对出现，并且先后顺序不能改变</li>
<li>assign必须在load之后，且assign之后必须写会主内存，且加载到内存的变量必须assign</li>
<li>use、store之前必须assign，load</li>
<li>lock操作后工作内存会被清空</li>
<li>unlock必须在lock之后，且unlock必须等待变量别写会主内存。</li>
</ul>
<h2 id="保证线程安全的3个要点"><a href="#保证线程安全的3个要点" class="headerlink" title="保证线程安全的3个要点"></a>保证线程安全的3个要点</h2><ul>
<li>原子性：8个原子操作</li>
<li>可见性：voltile、final、synchrozied可以保证</li>
<li>顺序性：voltile、synchrozied</li>
</ul>
<h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><p>1:1模型：使用内核线程，实现简单，但是无法支持高并发因为内核态和用户态消耗大，并且由于是1：1无法支持高并发。<br>1:N：使用用户线程，可支持高并发，但是调度等实现难度大。<br>N:M：用户线程用于并发，内核线程用于调度。综合上面俩种优缺点。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>new:new一个线程<br>run:执行start<br>block:synchronized<br>wait:没有参数的wait<br>time_waiting:有参数的wait和sleep</p>
<h2 id="jvm的锁优化"><a href="#jvm的锁优化" class="headerlink" title="jvm的锁优化"></a>jvm的锁优化</h2><p>由于锁需要从用户态转到内核态作为控制，所以采用如下几种优化方案。</p>
<ul>
<li>锁消除：通过逃逸分析发现没有变量逃逸的情况，会去掉锁。</li>
<li>锁粗化：如果多一个对象反复加锁、解锁会考虑合并</li>
<li>偏向锁：如果当前线程获取锁，复制markword,markword修改锁标记位，以及获取锁线程的线程ID；</li>
<li>轻量级锁：如果遇到竞争，复制markword，markword修改锁标记位，以及锁的lockrecord地址。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的编译优化-后期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的编译优化-后期/" class="post-title-link" itemprop="url">JVM的编译优化-后期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-17 10:45:28" itemprop="dateCreated datePublished" datetime="2019-11-17T10:45:28Z">2019-11-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  JIT(java in time complier)，即为了提高热点代码效率将代码编译成本地代码。</p>
<h2 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h2><p>  HotSpot采用的是解释器与编译器共存。</p>
<p>  解释器可以发挥编译优势，省去编译成本地代码的时间，直接运行；编译器把反复执行的代码编译成本地代码提高执行效率。同时如果编译器的优化比较激进发现编译后的结果不成立可以通过解释器退回到之前状态。</p>
<p>  解释器和编译器这种搭配方式称为混合模式。可以通过-Xint来控制</p>
<h2 id="俩个编译器ClientComplier和ServerComplier"><a href="#俩个编译器ClientComplier和ServerComplier" class="headerlink" title="俩个编译器ClientComplier和ServerComplier"></a>俩个编译器ClientComplier和ServerComplier</h2><p>ClientComplier注重编译速度，ServerComplier注重编译的质量。HotSpot在JDK1.7时代默认采用分层编译</p>
<ul>
<li>C0：解释执行</li>
<li>C1：将字节码编译成本地代码，简单的优化。</li>
<li>C2：会启用一些耗时优化。</li>
</ul>
<h2 id="出发条件"><a href="#出发条件" class="headerlink" title="出发条件"></a>出发条件</h2><p>HotSpot采用基于计数器的方式。</p>
<ul>
<li>方法的重复调用<ul>
<li>条件：重复一定次数（方法调用计数器控制）</li>
<li>方式：调用次数+1.触发阈值后发送编译请求。编译完成后替换方法地址</li>
<li>半衰周期：当一段时间没到阈值会，方法调用计数器会衰减一半</li>
<li>默认值：client:1500,server:10000</li>
</ul>
</li>
<li>循环体的调用：OSR(on stack replacement)栈上替换，发生在运行时的方法栈<ul>
<li>条件：重复一定次数（回边计数器）</li>
<li>方式：以方法为单位如果，每一次循环回边计数器都+1，如果回边计数器和方法调用计数器超过一定数值后发送编译请求。（这时候重新调整计数器以便继续循环）编译完成后替换方法地址</li>
</ul>
</li>
</ul>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>后台编译</p>
<p><img src="/JVM的编译优化-后期/clientcomiler.png" alt="client-compile"></p>
<p>具体的HIR LIR我也没太看明白以后看编译原理在不上:P</p>
<h2 id="编译优化的技术"><a href="#编译优化的技术" class="headerlink" title="编译优化的技术"></a>编译优化的技术</h2><p>编译代码比解释代码优化，一方面是没有虚拟接解释代码的消耗，一方面是所有的代码优化措施都集中在JIT上。</p>
<h3 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h3><p><img src="/JVM的编译优化-后期/jit优化技术.png" alt="jit优化技术"><br><img src="/JVM的编译优化-后期/jit优化技术2.png" alt="jit优化技术"></p>
<h3 id="公共子表达式优化"><a href="#公共子表达式优化" class="headerlink" title="公共子表达式优化"></a>公共子表达式优化</h3><p>比如程序有俩个b<em>c和c</em>b，javac不会进行优化，java则会优化成E=b*c,然后代码使用E</p>
<h3 id="异常消除"><a href="#异常消除" class="headerlink" title="异常消除"></a>异常消除</h3><p>NullPointer，ArrayIndexOutOfBounds等异常信息，在运行时如果不优化每次判断都会带来开销，所以jit会对齐进行优化，消除这些隐式的判断。而且会根据Profile收集到的信息进行“智能”优化。比如一个对象经常为空的情况就不回采用try catch的优化。</p>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>由于JAVA是面向对象的，很对方法是虚方法，为了优化就采用CHA，如果是虚方法会去查询有几个版本如果只有一个版本会进行内联，如果继承关系发生改变，比如动态代码，这时候要退回解释执行。如果发现多个版本还会采用Inline Cache来尝试内联</p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>栈上分配、同步消除、标量替换</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的编译优化-前期/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的编译优化-前期/" class="post-title-link" itemprop="url">JVM的编译优化-前期</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-15 15:46:02" itemprop="dateCreated datePublished" datetime="2019-11-15T15:46:02Z">2019-11-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JAVA是将类文件编译后生成操作码交给解释器执行，所以是解释性语言。</p>
<h2 id="面向栈的指令集和面向寄存器的指令集"><a href="#面向栈的指令集和面向寄存器的指令集" class="headerlink" title="面向栈的指令集和面向寄存器的指令集"></a>面向栈的指令集和面向寄存器的指令集</h2><p>  java是通过操作码将数据压入/弹出到操作栈中进行操作，所以是面向栈的，而还有一种流派是直接生成本地代码调用寄存器的指令，<br>  俩者的区别。</p>
<ul>
<li>面向栈：便于移植，代码简单，由于不依赖寄存器，支持寄存器不支持的功能。由于执行指令多所以性能差</li>
<li>面向寄存器：不便于移植，功能依赖于CPU等硬件。性能好</li>
</ul>
<h2 id="javac编译的过程"><a href="#javac编译的过程" class="headerlink" title="javac编译的过程"></a>javac编译的过程</h2><p><img src="/JVM的编译优化/javac编译过程.png" alt="编译过程"></p>
<p>源码如下</p>
<p><img src="/JVM的编译优化/javac编译过程的主题代码.png" alt="编译过程"></p>
<h3 id="解析文件和添加符号表"><a href="#解析文件和添加符号表" class="headerlink" title="解析文件和添加符号表"></a>解析文件和添加符号表</h3><ul>
<li>词法、语法分析：通过词法分析器和语法分析器生成抽象语法树</li>
<li>输入到符号表：将语法树种的在javac源码就是enterTree过程，符号表是一个kv的数据结构，用于收集符号以及变量，在语义校验阶段用于校验语法和产生中间代码，目标代码生成阶段是分配符号内存的依据</li>
</ul>
<h3 id="注解处理器处理注解"><a href="#注解处理器处理注解" class="headerlink" title="注解处理器处理注解"></a>注解处理器处理注解</h3><p>JDK1.5之后支持了注解，实际上是一个个的语法插件，会对语法树进行读取、修改，如果对语法树进行修改，需要重新解析文件和添加符号表，称为Round。也就是图上的回环</p>
<h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><ul>
<li>标注检查：检查变量是否已经声明，类型与赋值类型是否匹配。</li>
<li>数据及控制流分析：进一步对语法和语义做检查。注意局部变量设置为final的语义检查是在编译器的，因为局部变量没有该final的常量标志位，所以在编译后是否声明称final没有区别。</li>
<li>解语法糖：泛型、自动装箱、拆箱等都需要在编译阶段还原。</li>
<li>字节码生成：<ul>
<li>实例构造器init方法和类构造器clinit方法添加到语法树，将调用父类的实例构造器等方法收敛到这俩个方法中</li>
<li>优化操作：将String的添加等操作改为StringBuffer.append</li>
</ul>
</li>
</ul>
<h2 id="JAVA语法糖详解"><a href="#JAVA语法糖详解" class="headerlink" title="JAVA语法糖详解"></a>JAVA语法糖详解</h2><h3 id="泛型和类型擦除"><a href="#泛型和类型擦除" class="headerlink" title="泛型和类型擦除"></a>泛型和类型擦除</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM虚拟机执行引擎/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM虚拟机执行引擎/" class="post-title-link" itemprop="url">JVM虚拟机执行引擎</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-12 16:57:31" itemprop="dateCreated datePublished" datetime="2019-11-12T16:57:31Z">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>java的执行引擎是虚拟机自己提供的，所以更加灵活可以支持应将不支持的指令集。（对硬件指令集的封装 :P）</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>  jvm执行方法调用的数据结构，一个方法从开始执行到结束执行是一次入栈出栈的过程。<br>  在便宜Class文件时候局部变量表占用内存的大小和栈帧深度都已经决定好了。<br>  一个方法执行调用链会很长，只有当前的线程中调用栈栈顶的栈帧才能被执行，该栈帧被称为当前栈帧（Current Frame）对应的方法是当前方法(Current Method),栈帧结构如图：</p>
<p><img src="/JVM虚拟机执行引擎/framestack.png" alt="栈帧结构]">  </p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>  总共有byte、short、int、short、boolean、float、refrence、returnAddress  8种。</p>
<p>  在编译期就在方法的Code属性max_locals就决定了大小。局部变量表的大小单位是Slot,虚拟机规定者byte、short、int、boolean、refrence、returnAddress 数据类型可以用32位或者更小的空间存储，即4byte。如果是64位系统采用8byte但是需要用数据补齐等方式让其看起来是32位的。<br>  long、double则采用64位空间存储即8byte，注意这里虽然是用俩个32位空间存储但是因为是局部变量，但是是建立在线程的栈上没有共享问题是线程安全的。<br>  refrence要遵循俩个协议</p>
<ol>
<li>能找到堆中对象的数据起始位置</li>
<li><p>能找到方法去中Class类的位置</p>
<p>参数值到参数变量列表的转换，如果不是static方法，局部变量表第0位给隐藏变量“this”，参数分别占第1~n位。剩下的会分配给方法内生命的局部变量。局部变量的slot可以重用。</p>
<p>导致的一个“坑”是假如当前的变量后面不需要了，如果后面没有对变量的声明，修改局部变量，在方法执行期间gc是不会回收该局部变量，所以有一些比较耗内存的变量在用完了后，会“a=null”，加速gc的回收</p>
<p>局部变量不赋值是不能使的，因为没有向static变量有个准备阶段赋0值</p>
</li>
</ol>
<h3 id="操作栈"><a href="#操作栈" class="headerlink" title="操作栈"></a>操作栈</h3><p>  后入先出，保存栈帧运行时候的数据，比如运算操作，方法调用等，实际上方法的执行就是操作栈不同的入栈/出栈。最大值在方法的属性Code规定的max_stack中在编译时候操作栈的深度就规定好了。栈元素的数据类型必须与自己吗指令序列严格匹配。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>  栈帧都包含一个指向运行时常量池中，该栈帧所对应的方法的引用，用于在运行时将一些符号应用初始化成直接引用的操作。</p>
<h3 id="接口返回地址"><a href="#接口返回地址" class="headerlink" title="接口返回地址"></a>接口返回地址</h3><ol>
<li>Nomal Method Invocation Completion。即正常的方法</li>
<li>Abrupt Method Invocation Completion。即出现异常的返回</li>
</ol>
<p>无论何种返回都会退回到上层调用者的位置，正常返回有可能将返回值给调用者，调用者会将返回值压入自己的操作栈中。异常返回无返回值。</p>
<p>方法的推出等同于当前的栈帧出栈，同时把返回值压入调用者的操纵栈，修改PC指向方法调用的后面一条指令</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用有5个指令</p>
<p>invokestatic:静态方法<br>invokespecial：构造方法，私有方法，父类方法<br>invokevirtual：调用所有的虚方法<br>invokeinterface：调用接口方法，会在运行时制定一个接口的实现类<br>invokedynmatic：运行时动态解析所应用的方法–这是用户设计的应到方法决定的</p>
<h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><p>只在编译期就能决定，且不会在运行时修改的方法，这里指invokestatic、invokespecial指令调用的方法，还有final的方法。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>由于java面向对象特性中的多态，导致编译器无法决定使用哪个版本需在运行期指定方法版本的方法。</p>
<p>类A a=new B()。B是A的子类或者接口实现类，那么A是静态类型，B是真实类型。即父类、接口是静态类型，实现类、子类是真实类型。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>如果方法的版本取决于类的静态类型，我们称为静态分派。主要场景用于重载见下面的方法。发生在编译阶段，因为在编译时候只能确认静态版本，但是在实际调用中我们只能通过真是的类型去推断选择一个合理版本</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>如果确认方法的版本去介于类的动态类型，我们称为动态分派。主要场景用于重写。原理是当我们在方法中声明一个对象时候，会把对象的实际数据（引用）压入操作栈，当需要调用方法时候，取出来的是实际数据调用的就是实际数据的方法版本。发生在运行期。</p>
<h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>当一个方法有俩个宗树的静态、动态分派时候就是多分派。</p>
<p>jvm实现动态分派的方法</p>
<p>由于动态分派需要在class元数据中分析查找方法，为了提高性能，jvm在方法区简历了vtable(虚方法表)，当调用指令invokeinterface时候会直接通过vtable的索引查找需要的方法版本</p>
<h3 id="vtable–virtual-interface"><a href="#vtable–virtual-interface" class="headerlink" title="vtable–virtual interface"></a>vtable–virtual interface</h3><p>虚方法表，由于动态分派非常频繁，jvm为了提高性能，在方法区为类创建了虚方法表，虚方法表保存的是类方法的真实地址，如果遇到没重写父类的方法地址就是父类的地址。一般在类加载的链接阶段，当类初始化0值完成方法表也初始化完成</p>
<h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言主要是通过java.lang.invoke包支持。他和反射的区别是，发射时模拟类的创建和调用过程，而invoke模拟的是操作码</p>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>java的执行引擎是基于操作栈的，解释执行。与其相对的还有编译执行如图：</p>
<p><img src="/public/JVM虚拟机执行引擎/编译原理.png" alt="编译原理.png"></p>
<p>java的解释器和解释执行在jvm中，抽象语法树之前的步骤都独立于jvm虚拟机，所以java是半独立解释性语言。</p>
<h3 id="基于栈或者基于寄存器"><a href="#基于栈或者基于寄存器" class="headerlink" title="基于栈或者基于寄存器"></a>基于栈或者基于寄存器</h3><ul>
<li>基于寄存器的优缺点：优点：直接操作寄存器，不直接操作内存，CPU执行性能高性能高。缺点：由于直接在寄存器操作依赖硬件移植性差</li>
<li>基于栈的优缺点：优点：移植性好，通过操作栈不直接操作寄存器，代码更为紧凑，简单。缺点：效率比基于寄存器低</li>
</ul>
<h3 id="解释执行过程"><a href="#解释执行过程" class="headerlink" title="解释执行过程"></a>解释执行过程</h3><p>将数据先push到操作栈中在pop到局部变量表，在从局部变量表load数据计算然后push到操作栈中。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/java类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java类加载机制/" class="post-title-link" itemprop="url">java类加载机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-10 20:40:51" itemprop="dateCreated datePublished" datetime="2019-11-10T20:40:51Z">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  JAVA类是在运行时进行转载的，这种动态机制虽然降低了些许性能，但是使用起来更加灵活。相比编译时候需要连接的语言C++等来说。<br>  类加载过程分为：加载-验证-准备-解析-初始化-使用-卸载。其中加载、验证、初始化的开始顺序是固定，但是解析有可能放在初始化后面。并且他们也有可能是交叉进行的。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>  jvm对加载没有强制的规定，但是对类的初始化有了强制的规定。即对一个类的主动引用，主动因为指的是一下5中情况。</p>
<ol>
<li>new对象、调用对象的static属性(final除外因为final直接进入了运行时常量池)、调用对象的static方法。</li>
<li>初始化一个类时候发现父类没有初始化要对父类进行初始化</li>
<li>main方法所以在的类</li>
<li>反射时候如果发现类没有初始化</li>
<li><p>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（实际上是因为第一条的规定）</p>
<p>注意：接口初始化和类很类似也需要初始化父类接口的class对象，不过不需要初始化所有父类接口，只有使用父类时候才会初始化（使用父类接口的常量）。</p>
</li>
</ol>
<h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>  这里只的是类加载的“加载过程”。记载分为3个过程</p>
<ol>
<li>根据类全限定名找到对应外部二进制文件</li>
<li>将二进制文件加载到内存中</li>
<li><p>在方法区创建对应的class类做外部访问数据的接口</p>
<p>几种外部的二级制文件加载方式zip包、网络、运行时、数据库等等<br>注意：数组的加载方式，由虚拟机直接产生。去掉数组的一维，如果是引用类型的话即组件类，该组件类的Classloader加载该类，并且数组类会在组件类的Classloader的的类空间进行标示。如果是int等非引用类型，我们会调用引导类的类加载器。访问方式取决于组件类的访问方式。</p>
</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>  java虚拟机校验类文件的合法性，防止恶意篡改、类错误导致虚拟机或者程序崩溃。主要有以下四个阶段</p>
<ol>
<li>文件格式校验：判断class的魔数、版本等，通过校验后会将二进制流读入到方法区，后续的校验会针对方法区的二进制流进行校验（检查文件）</li>
<li>元数据校验：对字节码元数据进行分析，查看是否有父类，父类是否合法。（检查类）</li>
<li>字节码校验：保证方法体字节码的合法性，比如是否有非法的类型转换、赋值能。jdk1.7后增加了StackMapTable用来保存方法体中初始的状态，校验时候直接通过读取StackMapTable即可（检查方法）</li>
<li>符合引用校验：字段的引用是否合法，是否访问了不存在的字段、方法、以及超过了访问权限等</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>   java虚拟机为类的变量分配内存的过程，这里指的是static修饰的变量因为实例变量会在实例创建时候赋值。对于一般情况变量分配完内存后要赋0值，真实的值保存在&lt;clinit&gt;()方法中，在初始化时候才会赋值。final修饰的变量会在该阶段赋值真实值</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  java将class文件中的符号引用改为直接引用的过程</p>
<p>  字段的解析</p>
<ul>
<li>普通引用比如对于字段N类型C来说，将N交给类的ClassLoader加载C的类型</li>
<li>数组加载数组的ComponentType的类，然后由虚拟机生成数组的直接应用</li>
<li><p>校验范围权限</p>
<p>类方法的解析</p>
</li>
<li><p>检查类的class_index如果是类方法，class_index是接口方法直接抛出java.lang.IncompatibleClassChangeError异常。</p>
</li>
<li>类中有方法的简单名称和描述符返回，否则去父类查找如果有返回，否则去接口查找如果接口有抛异常java.lang.AccessMethodError,如果没有抛出java.lang.NoSuchMethodError</li>
<li><p>检查访问权限</p>
<p>接口方法解析：步骤同上只是不用检查权限</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  在该阶段开始执行java代码（字节码），生成方法&lt;clinit&gt;()。</p>
<ul>
<li>clinit方法是由静态字段和静态代码块共同合并生成，且顺序自上到下</li>
<li>如果有父类，且父类有有静态类和静态字段，父类的clinit方法会先调用</li>
<li>接口因为也可能有静态阶段，接口也可能生成clinit，如果有父类接口，只有用到父类接口的变量才会生成父类接口的clinit方法</li>
</ul>
<p>注意clinit出于线程安全考虑会加锁这就是为什么static代码块只执行一次。如果static里阻塞会阻塞类的创建</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>唯一性：ClassLoader+类=唯一，每个ClassLoader都有自己的类命名空间，这个会影响到instanceOf等结果。</p>
<p>java的classloader分为3种</p>
<ol>
<li>启动类加载器：Bootstrap ClassLoader，由C++编写，java无法直接调用，如果将类委托给该加载器调用改classloader回报异常。用于加载JAVA_HOME/lib以及 -Xbootclasspath对应地址的类并且要符合命名规则，比如rt.jar</li>
<li>扩展类加载器：Extension ClassLoader，由java编写，java可直接调用。JAVA_HOME/ext/lib或者java.ext.dirs指定的类</li>
<li>应用类加载器：Application ClassLoader，由java编写，java可直接调用。classpath中的类，如果不指定自己的classloader他是默认的classloader</li>
</ol>
<p>类加载的双亲委派模型：即类加载器会优先调用父类的加载器，父类加载器会调用直到启动类加载器，之后在调用自己的类加载器。好处在于对于一些系统的类全局只有一个唯一的Class类（受唯一性约束）。顺序是：启动类加载器–&gt;扩展类加载器–&gt;应用类加载器–&gt;自定义类加载器。</p>
<p>这是java建议的使用方法</p>
<p>双亲委派模型的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class＜?＞loadClass(String name,<span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">  Class c=findLoadedClass(name)</span><br><span class="line">  <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>（parent！=<span class="keyword">null</span>）&#123;</span><br><span class="line">          c=parent.loadClass(name,<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          c=findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>（ClassNotFoundException e）&#123;</span><br><span class="line">       <span class="comment">//如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">       <span class="comment">//说明父类加载器无法完成加载请求</span></span><br><span class="line">    &#125; <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">      <span class="comment">//在父类加载器无法加载的时候</span></span><br><span class="line">      <span class="comment">//再调用本身的findClass方法来进行类加载</span></span><br><span class="line">      c=findClass(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JAVA类文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JAVA类文件结构/" class="post-title-link" itemprop="url">JAVA类文件结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-05 20:51:37" itemprop="dateCreated datePublished" datetime="2019-11-05T20:51:37Z">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="class类的结构"><a href="#class类的结构" class="headerlink" title="class类的结构"></a>class类的结构</h2><p>如图，单位是字节u1代表1个字节。</p>
<p><img src="/JAVA类文件结构/class类文件格式.png" alt="avator"></p>
<h2 id="魔术和版本号"><a href="#魔术和版本号" class="headerlink" title="魔术和版本号"></a>魔术和版本号</h2><p>  文件前4个字节代表这是个java文件固定CAFEBABE<br>  第5、6字节代表此版本号，7、8字节代表主版本号，版本号有向下兼容性</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p> 紧接着这就是常量池了，常量池的前俩个字节偏移量是0x00000008,代表常量的个数，和java其他的数据表示方法不一样，常量池下标是从1开始，（比如数字是22，常量21个索引范围是1~21个）常量池有14种数据类型，每一个常量的第一位tag（长度u1）就是它类型，见下图：<br><img src="/JAVA类文件结构/class类结构2.png" alt="avator"></p>
<p> 具体数据个数如下：<br><img src="/JAVA类文件结构/class类结构3.png" alt="avator"></p>
<p>  可以通过javap命令查看类的常量池 javap-verbose TestClass</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>  是一个标志位，标志类是否是public的是interface还是class是否声明为final等，具体如下：</p>
<p><img src="/JAVA类文件结构/class类结构4.png" alt="avator"></p>
<p>  计算方式采用“|”</p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>  类索引、父类索引长度都是8,指向常量表的索引，接口索引是一组指向常量表的索引。<br>  除了Object类，父类索引都不是0。</p>
<h2 id="字段表、方法表集合"><a href="#字段表、方法表集合" class="headerlink" title="字段表、方法表集合"></a>字段表、方法表集合</h2><p>包括了</p>
<ul>
<li>访问标志(access_flags)：public、private等，长度8个字节</li>
<li>名称索引(name_index)：指向常量表</li>
<li>修饰符所以(descripor_index)：用简短方法表述字符比如java.lang.String[]，描述为[Ljava/lang/String</li>
<li>属性集合表count(attribute_count):长度8个字节，代表属性长度</li>
<li><p>属性信息(attribute_info):长度8个字节，数量attribute_count，代表属性信息。方法有固定的属性Code</p>
<p>附：<br>字段表结构<br><img src="/JAVA类文件结构/字段表结构.png" alt="avator"><br>字段access_flags<br><img src="/JAVA类文件结构/字段访问标志位.png" alt="avator"><br>方法表访问标志位<br><img src="/JAVA类文件结构/methodtableacc.png" alt="avator"><br>demo<br><img src="/JAVA类文件结构/zdjgbdemo.png" alt="avator"></p>
</li>
</ul>
<h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>  <img src="/JAVA类文件结构/attrtable1.png" alt="avator"><br>  <img src="/JAVA类文件结构/attrtable2.png" alt="avator"></p>
<h2 id="java的自己码指令"><a href="#java的自己码指令" class="headerlink" title="java的自己码指令"></a>java的自己码指令</h2><p>  jvm的指令码是面试操作栈的，它的指令由1个字节的代码特殊含义的操作码以及后面0到多个操作参数组成。由于操作码是1个字节所以java最多有255个操作码。</p>
<p>  感觉jvm是讲数据读到操作栈中操作，在写回栈帧的局部变量中。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的性能分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的性能分析/" class="post-title-link" itemprop="url">JVM的性能分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-25 16:58:05" itemprop="dateCreated datePublished" datetime="2019-10-25T16:58:05Z">2019-10-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="jvm的常用工具"><a href="#jvm的常用工具" class="headerlink" title="jvm的常用工具"></a>jvm的常用工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>  作用：监视java进程状态的工具</p>
<p>  命令格式：jps [option][hostid]</p>
<p>  参数：<br>-m：输出启动时传给main函数的方法<br>-l：输出主类全名如果是jar包，输出路径<br>-v：输出虚拟机启动时Jvm的参数</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>  作用：监视java进程各种运行状态的信息</p>
<p>  命令格式：jstat[option] vmid [interval][s|ms][count]]</p>
<p>  参数：主要分三类、类装在、垃圾收集、运行期编译状况</p>
<p>-class<br>-gc<br>-gccapacity<br>-gcutil<br>-gccaise<br>-gcnew<br>-gcnewcapacity<br>-gcold<br>-gcoldcapacity<br>-gcpermcapacity<br>-complier<br>-printcompilation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">6.20</span> <span class="number">41.42</span> <span class="number">47.20</span> <span class="number">16</span> <span class="number">0.105</span> <span class="number">3</span> <span class="number">0.472</span> <span class="number">0.577</span></span><br><span class="line"></span><br><span class="line">  s0、s1:survivor</span><br><span class="line">  E:eden区</span><br><span class="line">  O:old区</span><br><span class="line">  M:metaspace</span><br><span class="line">  YGC:minorGc的次数</span><br><span class="line">  YGCT:minorGc的时间</span><br><span class="line">  FGC:FullGC的次数</span><br><span class="line">  FGCT:FullGc的时间</span><br><span class="line">  GCT:的时间</span><br></pre></td></tr></table></figure>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>  作用：查看、修改虚拟机的配置。</p>
<p>  命令格式：jinfo [option] pid</p>
<p>  参数：<br>  -flag &lt;name&gt;         to print the value of the named VM flag<br>  -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag<br>  -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value<br>  -flags               to print VM flags<br>  -sysprops            to print Java system properties</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>  作用：java内存映射工具,可以查询finalize执行队列、java堆和永久代的详细信息、如空间使用率、当前采用的收集器等</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -heap                打印java堆详细的信息<br>    -histo[:live]        打印堆中对象统计信息，Live只统计存活的信息<br>    -clstats             打印Classloder的信息<br>    -finalizerinfo       显示F-Queue中等待Finalizer线程执行finalizer方法的对象<br>    -dump:&lt;dump-options&gt; 生成java堆快照：live只打印存活的对象，如果不指定打印所有对象，format=b二进制格式的文件，file=&lt;file&gt;打印到某个&lt;file&gt;中。eg: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;<br>    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo<br>                         to force a heap dump or histogram when &lt;pid&gt; does not<br>                         respond. The “live” suboption is not supported<br>                         in this mode.<br>    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>  作用：配合jmap分析dump出来的jmap文件，不建议在应用服务器上使用，因为dump文件很大，并且很耗性能，建议在单独的服务器上执行<br>  命令格式：jhat /dumpfile<br>  使用方法：打开浏览器，访问jhat所在服务器的7000端口。查看内存泄漏用OQL工具和Heap Historygram功能</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>  作用：java堆栈跟踪工具，定位java每一个线程当前时刻的执行快照，可以定位到线程运行的状况是否死锁等。</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p>
<h3 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h3><p>  作用：jit生成码反汇编插件，通过jvm设置的参数-XX PrintAssmbly把动态生成的代码还原成汇编代码</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><ul>
<li><p>JConsole</p>
</li>
<li><p>VisualVM</p>
<p>综上，我们可以用jps jstat jinfo查看jvm的信息。jmap、jhat查看堆信息。jstack查看栈信息。我们可以用可视化工具来方便查看上面的信息推荐VisualVM</p>
<p>下载地址： <a href="http://visualvm.java.net/download.html" target="_blank" rel="noopener">http://visualvm.java.net/download.html</a><br>idea可以通过pulgins安装通过简单配置即可实现动态的VisualVM功能</p>
</li>
</ul>
<h2 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h2><h3 id="高性能硬件的场景"><a href="#高性能硬件的场景" class="headerlink" title="高性能硬件的场景"></a>高性能硬件的场景</h3><p>  如果硬件性能较高，我们一般采用俩种方式</p>
<ol>
<li>采用64位虚拟机，设置很大的堆内存</li>
<li><p>采用32位虚拟机，虽然堆内存最大设置4（还受限于平台对进程最大使用内存的限制有可能只有2g，windows平台）我们可以给一台服务器设置多个进程+前端反向代理的方法。</p>
<p>第一种方案我们要注意64位虚拟机往往比32位虚拟机要慢（指针膨胀、内存补齐等需求），另外由于堆内存很大，我们一定要注意大对象导致频繁GC的问题，因为一次fullGC有可能需要停顿10几秒，对于交互多的服务体验会很差</p>
</li>
</ol>
<h3 id="共享缓存导致oom"><a href="#共享缓存导致oom" class="headerlink" title="共享缓存导致oom"></a>共享缓存导致oom</h3><p>  由于共享缓存频繁的写入导致内存oom。需要检查缓存的使用率。</p>
<h3 id="对外内存导致的oom"><a href="#对外内存导致的oom" class="headerlink" title="对外内存导致的oom"></a>对外内存导致的oom</h3><p>  有以下几种对外内存</p>
<p>  DirectMemory:主要用于nio场景，比如内存环境是2G。我们给堆内存分配了1.6G。那么堆外内存最多只能有0.4G不到，如果这时候大量请求过来会导致oom</p>
<p>  线程堆栈：会出现StackOverflowError或者StackOutOfMemoryError</p>
<p>  JNI的调用：由于是native方法所以也是堆外内存</p>
<p>  Socket的读写Buffer：receive和send都有一个buffer分别是37kb和25kb。如果超出了会出现open many file的错误。</p>
<p>  系统线程和gc线程</p>
<h3 id="外部命令导致系统变缓慢"><a href="#外部命令导致系统变缓慢" class="headerlink" title="外部命令导致系统变缓慢"></a>外部命令导致系统变缓慢</h3><p>  比如调用Runtime.getRuntime.exec()执行shell。java是fork了个进程，这个指令很重如果调用的频繁系统的负载会很重，建议采用api的方式。</p>
<h3 id="外部接口超时导致系统崩溃"><a href="#外部接口超时导致系统崩溃" class="headerlink" title="外部接口超时导致系统崩溃"></a>外部接口超时导致系统崩溃</h3><p>  调用远程接口响应较慢导致连接大量被占用，同时对连接没做限制导致了虚拟机崩溃。需要设置超时时间，或者采用生产者消费者异步的方式。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的垃圾回收机制/" class="post-title-link" itemprop="url">JVM的垃圾回收机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-17 19:34:53" itemprop="dateCreated datePublished" datetime="2019-10-17T19:34:53Z">2019-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jvm的内存分为线程独享的线程栈、程序计数器；线程共享的方法区、堆区，线程栈在编译时候就确定好了大小，方法执行完成后自动就可以回收所以是静态的。而方法区、堆区只有在运行时才知道内存分配的大小所以内存回收是动态的。本章主要讨论的是堆和方法区的垃圾回收</p>
<h2 id="对象是否可被回收算法"><a href="#对象是否可被回收算法" class="headerlink" title="对象是否可被回收算法"></a>对象是否可被回收算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>  给对象添加一个引用计数器，当被引用时候引用计数+1，在垃圾回收时候只要应用计数为0就可以回收对象了。算法很简单，弊端是无法解决循环应用问题。<br>  即：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.instance=b;</span><br><span class="line">b.instance=a;</span><br></pre></td></tr></table></figure>
<p>  这时候a和b是无法被回收的。</p>
<h3 id="可达性分析算法-java采用的方式"><a href="#可达性分析算法-java采用的方式" class="headerlink" title="可达性分析算法-java采用的方式"></a>可达性分析算法-java采用的方式</h3><p>我们通过对象GCRoot做可达性分析，如果对象的引用链没有GCRoot对象，说明对象是可以被回收的。jvm中适合做GCRoot对象的有</p>
<ul>
<li>jvm方法栈中的局部变量表中的变量</li>
<li>jvm本地方法栈中的native对象</li>
<li>方法区中的静态变量</li>
<li>方法区中的常量</li>
</ul>
<h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>对象按照应用的按照从强到弱分别如下：</p>
<ul>
<li>强引用：我们new一个对象默认就是强引用。必须等到GcRoot不可达</li>
<li>软引用：SoftReference对象，不管内存是否足够，下一次gc都会回收该对象</li>
<li>弱引用：WeakReference对象，当内存不足时候时候gc会回收弱引用对象</li>
<li>虚引用：PhantomReference，又称幽灵引用，不对对象的生命周期造成影响，get()方法返回的也是null，只在对象被回收时候系统会收到一个通知。使用场景堆外内存回收。系统调用unfase方法申请一块堆外内存，然后在堆中会持有一个虚引用的对象，当该对象被回收时候会清理堆外内存</li>
</ul>
<h2 id="finalize方法以及对象的自救"><a href="#finalize方法以及对象的自救" class="headerlink" title="finalize方法以及对象的自救"></a>finalize方法以及对象的自救</h2><p>  对象被回收需要通过标记、回收两部，第一步先标记可会回收的对象，然后检查对象是否实现了finalize()方法，如果对象实现了finalize方法并且在gc时候没有被系统调用过，则认为是可finalize的，会放在一个优先级比较低的F-Queue队列中，之后会有finalize线程执行finalize()方法，如果这时候把this赋值给别的标量则完成了对象的自救。</p>
<p>  注意:</p>
<ul>
<li>只会执行一次；</li>
<li>finalize的执行由于优先级较低即为不靠谱不推荐使用。比如在finalize方法中执行一些清理操作我们可以放在finnal中执行</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>  永久代的回收效率比较低（类信息、常量、静态变量），主要回收类信息、常量</p>
<p>  回收常量：当该常量没有任何应用</p>
<p>  回收类信息：</p>
<ol>
<li>没有任何该class的实例</li>
<li>该类的ClassLoader被回收</li>
<li>Class没有任何访问、即通过反射创建该Class的元素</li>
</ol>
<h2 id="gc的算法"><a href="#gc的算法" class="headerlink" title="gc的算法"></a>gc的算法</h2><h3 id="mark-swap-标记清理"><a href="#mark-swap-标记清理" class="headerlink" title="mark-swap 标记清理"></a>mark-swap 标记清理</h3><p>标记对象后将需要回收的对象进行销毁、会造成内存碎片，可能导致大对象没法分配</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>年轻代会采用这种算法，jvm认为大量对象是朝生夕死，所以会将内存分为Eden和俩个Survivor空间，默认比例是8:1:1，平时只会用到一个Eden和1个Survivor。当gc时候会将所有对象赋值到没用的那个Survivor空间，然后清掉Eden和原来的Survivor空间。如果剩下的Survivor不足会进入老年代。</p>
<h3 id="mark-compact-标记整理"><a href="#mark-compact-标记整理" class="headerlink" title="mark-compact 标记整理"></a>mark-compact 标记整理</h3><p>标记之后让所有对象向一端移动，超过这个范围的对象会被回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>  从GcRoot找引用链，该操作对时间很敏感，因为这一步操作对数据一致性要求很高，所以在执行时候虚拟机必须要StopTheWorld，否则枚举根节点的结果就不准确了。方法区和堆内存往往都很大，如果都需要分析一遍性能会严重受影响。</p>
<p>  HotSpot采用了OopMap对象，需要虚拟机的解释器和JIT编译器支持，由他们来生成OopMap，把对象偏移量内存放的是什么数据保存起来，gc就很快知道了对象的信息。</p>
<h3 id="安全点-safe-point"><a href="#安全点-safe-point" class="headerlink" title="安全点 safe point"></a>安全点 safe point</h3><p>  虽然OopMap在gc时候能很方便的完成枚举根节点，但是影响OopMap数据的操作很多如果每一步操作都创建OopMap会很耗费内存。为了解决这个问题HotSpot设置了safePoint的概念，只有程序执行到safePoint，才会停止线程开始gc，并且在gc前创建OopMap。即每一个safePoint会生成一个OopMap对象。</p>
<p>  安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。</p>
<p>  现在的问题是在Safe Point让线程们以怎样的机制中断，方案有两种：抢先式中断、主动式中断。</p>
<ul>
<li>抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。</li>
<li>主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。</li>
</ul>
<h3 id="安全区域-safe-region"><a href="#安全区域-safe-region" class="headerlink" title="安全区域 safe region"></a>安全区域 safe region</h3><p>  如果线程没有分配cpu时间，必须线程处于sleep或blocked状态，就无法响应JVM的中断请求，走到安全点去挂起。Safe Region解决了这一问题。</p>
<p>  安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的。当代码执行到安全区域时，首先标识自己已经进入了安全区域，那样如果在这段时间里JVM发起GC，就不用管标示自己在安全区域的那些线程了，在线程离开安全区域时，会检查系统是否正在执行GC，如果是，就等到GC完成后再离开安全区域。</p>
<h2 id="java的垃圾回收器"><a href="#java的垃圾回收器" class="headerlink" title="java的垃圾回收器"></a>java的垃圾回收器</h2><p>HotSpot在jdk1.7之后的所有垃圾回收器，如图：</p>
<p><img src="/JVM的垃圾回收机制/垃圾收集器.png" alt="avator"></p>
<h3 id="Serial垃圾回收器"><a href="#Serial垃圾回收器" class="headerlink" title="Serial垃圾回收器"></a>Serial垃圾回收器</h3><p>  最早的最基本的垃圾回收器，jdk1.3时期新生代唯一的垃圾收集器。会停止jvm所有的工作线程。</p>
<p>  是client模式下，新生代默认的垃圾收集器，因为没有线程交互开销所以在gc过程很高效，如果新生代内存不大，收集一次的耗时是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>  Serial的多线程版本。</p>
<p>  是server模式下首选的新生代垃圾收集器。原因是jdk1.5之后的CMS收集器除了Serial以外只有它能和ParNew配合使用。</p>
<p>  开启CMS后，-XX：+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX：+UseParNewGC选项来强制指定它。</p>
<p>  在单线程或者俩个线程时候由于有线程切换的问题表现不见得比Serial好，他适合线程数或者核数多的场景。默认开启的线程数等于cpu的数量，当然我们也可以通过参数-XX：ParallelGCThreads来控制</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>  更关注系统的吞吐量【运行代码时间/(运行代码时间+垃圾回收时间))】适用于内部计算、和外部没有交互的服务，主要参数：</p>
<ul>
<li>-XX：MaxGCPauseMillis：设置停顿时间，保证垃圾回收时间尽量不超过这个阈值，采用所少新生代空间，会导致垃圾回收更频繁</li>
<li>-XX：GCTimeRatio：垃圾收集时间占总时间的比例。</li>
<li>-XX：+UseAdaptiveSizePolicy：值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数。</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>  Serial的老年版垃圾收集，采用“标记-整理”算法，目前主要用于配合Parallel Scavenge和作为CMS的替代方案。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>  Parallel Scavenge老年版，使用多线程和“标记-整理”算法。适合吞吐量优先的场景。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>  大名鼎鼎的ConcurrentMarkSweep。以获取最短停顿时间为目标的垃圾回收期，试用场景希望停顿时间较短的场景。</p>
<p>  分为四个阶段：</p>
<ol>
<li>初始标记（CMS Initial Mark）：会stop the world。标记GcRoots能直接关联的对象。只做标记所以很快；</li>
<li>并发标记（CMS Concurrrent Mark）：不会stop the world和用户线程一起处理。去做GcRoot Tracing；</li>
<li>重新标记（CMS Remark）：会stop the world。处理初始标记到并发标记过程中新创建的对象，比初始标记长但是这时候创建的对象很少，所以停顿时间可接受；</li>
<li>并发清除（CMS Concurrrent Sweep）：不会stop the world和用户线程一起处理。去做对象的清理操作；</li>
</ol>
<p>如图：</p>
<p><img src="/JVM的垃圾回收机制/CMS收集器.png" alt="avator"></p>
<p>  默认启动线程是(CPU数量+3)/4，所以在CPU核数变高时候CMS占用的线程资源会越来越少。</p>
<p>  缺点：</p>
<ul>
<li>对cpu敏感会占用一部分用户线程，从而cpu负载很高时候导致程序变慢。</li>
<li>CMS无法处理浮动垃圾（即：因为在回收时候会产生的新对象），有可能导致另一次GC。因为在做垃圾回收时候用户线程在工作所以要预留一部分空间给用户线程。默认是92%（since 1.6）</li>
<li>内存碎片问题：由于标记清除会带来内存碎片问题导致明明很大的空间但是无法申请内存，这时候就要进行一次FullGC。<ul>
<li>CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
<li>虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full，然后在来一次压缩的默认是0，每次进行FullGc都压缩。</li>
</ul>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>  面向服务端收集器，特点：</p>
<ul>
<li>并行与并发：充分利用多核cpu,缩短stoptheworld时间。其他收集器需要停顿的它依然可以工作。</li>
<li>分代收集：虽然依然分代，但是g1可以不借助其他收集器独自工作。</li>
<li>空间整合：不会产生碎片。收集后提供规整内存。</li>
<li><p>可预测的停顿：用户可指定消耗在gc上的时间不超过n毫秒</p>
<p>G1不在区分新生代和老年代而是将堆内存分为一些大小相等的Region，Region分为新生代和老年代并且且同一年代的Region不连续的。<br>G1可预测的停顿时间的实现原理是。是内部维护了一个垃圾回收的优先级列表，针对Region内可回收的对象的大小、多少、收益能排序,优先回收收益较大的Region。</p>
<p>G1是如何解决不同Region之间的相互引用的，即新生代的Region引用了老年代的Region，它是通过每个Region持有的RememberSet。当一个Refrence发生写操作时候会生成一个WriteBarrier，暂时中断写操作，如果发现他们俩个处于不同的Region，则通过CardTable将应用信息记录到被引用对象Region的RememberSet，回收时候只需要RemberSet就可以知道准确的引用关系避免了全堆扫描。</p>
<p>G1的垃圾回收步骤</p>
</li>
</ul>
<ol>
<li>初始标记：标记下GcRoots能直接关联的对象，并且修改TAMS(next top at mark start)值，能让下一阶段并发标记时候在正确的region中创建值。需要停顿，但是很短。</li>
<li>并发标记：同cms，可以和工作线程一起运行，进行可达性分析查找存活对象，耗时较长。不需要停顿，可并行执行。</li>
<li>最终标记：修正初始标记到并发标记。从初始标记到最终标记这段时间内创建的对象都会记录到Remember Set Log中，合并到Remember Set中这段时间需要停顿线程，但是可并行执行。</li>
<li>筛选回收：根据用户设置的阈值指定回收计划。这一步理论上是不需要停顿的，但是但是停顿用户线程会增加回收效率。</li>
</ol>
<p>如图：<br><img src="/JVM的垃圾回收机制/G1收集器.png" alt="avator"></p>
<p>  综述：<br>  我们一般ParNew+CMS或者是G1的方案。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>  对象默认分配到eden区，如果开启TLAB会有限直接分配在线程栈中。</p>
<p>  大对象会直接进入老年代，对象大小超过一个PretenureSizeThreshold会直接进入老年代，</p>
<p>  长期存活的对象会晋升入老年代，每次垃圾回收对象的age会+1，如果到了MaxTenuringThreshold(默认值是15)会直接进入老年代。对象的动态年龄规划：当survivor区相同年龄的对象超过了survivor大小的一半，那么大于等于这个年龄的对象都可以直接进入到老年代。</p>
<p>  共同担保机制：当MinorGC发生时候，如果老年代的连续空闲内存空间超过新生代使用的对象的空间即可正常发生MinorGC,否则查看HanleProotionFailure值，如果开启，则会尝试MinorGC，失败后触发FullGC。如果关闭直接进行FullGC</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Liu hao</p>
              <p class="site-description motion-element" itemprop="description">励志当好厨子的程序员</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">229</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/liuhao163" title="GitHub &rarr; https://github.com/liuhao163" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:liu67224657@qq.com" title="E-Mail &rarr; mailto:liu67224657@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu hao</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
