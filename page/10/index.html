<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="励志当好厨子的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="liuhao163.github.io">
<meta property="og:url" content="https://liuhao163.github.io/page/10/index.html">
<meta property="og:site_name" content="liuhao163.github.io">
<meta property="og:description" content="励志当好厨子的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="liuhao163.github.io">
<meta name="twitter:description" content="励志当好厨子的程序员">



  <link rel="alternate" href="/atom.xml" title="liuhao163.github.io" type="application/atom+xml">




  <link rel="canonical" href="https://liuhao163.github.io/page/10/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>liuhao163.github.io – 杂七杂八</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">liuhao163.github.io</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">杂七杂八</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>Sitemap</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/java类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/java类加载机制/" class="post-title-link" itemprop="url">java类加载机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-10 20:40:51" itemprop="dateCreated datePublished" datetime="2019-11-10T20:40:51Z">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  JAVA类是在运行时进行转载的，这种动态机制虽然降低了些许性能，但是使用起来更加灵活。相比编译时候需要连接的语言C++等来说。<br>  类加载过程分为：加载-验证-准备-解析-初始化-使用-卸载。其中加载、验证、初始化的开始顺序是固定，但是解析有可能放在初始化后面。并且他们也有可能是交叉进行的。</p>
<h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>  jvm对加载没有强制的规定，但是对类的初始化有了强制的规定。即对一个类的主动引用，主动因为指的是一下5中情况。</p>
<ol>
<li>new对象、调用对象的static属性(final除外因为final直接进入了运行时常量池)、调用对象的static方法。</li>
<li>初始化一个类时候发现父类没有初始化要对父类进行初始化</li>
<li>main方法所以在的类</li>
<li>反射时候如果发现类没有初始化</li>
<li><p>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（实际上是因为第一条的规定）</p>
<p>注意：接口初始化和类很类似也需要初始化父类接口的class对象，不过不需要初始化所有父类接口，只有使用父类时候才会初始化（使用父类接口的常量）。</p>
</li>
</ol>
<h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>  这里只的是类加载的“加载过程”。记载分为3个过程</p>
<ol>
<li>根据类全限定名找到对应外部二进制文件</li>
<li>将二进制文件加载到内存中</li>
<li><p>在方法区创建对应的class类做外部访问数据的接口</p>
<p>几种外部的二级制文件加载方式zip包、网络、运行时、数据库等等<br>注意：数组的加载方式，由虚拟机直接产生。去掉数组的一维，如果是引用类型的话即组件类，该组件类的Classloader加载该类，并且数组类会在组件类的Classloader的的类空间进行标示。如果是int等非引用类型，我们会调用引导类的类加载器。访问方式取决于组件类的访问方式。</p>
</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>  java虚拟机校验类文件的合法性，防止恶意篡改、类错误导致虚拟机或者程序崩溃。主要有以下四个阶段</p>
<ol>
<li>文件格式校验：判断class的魔数、版本等，通过校验后会将二进制流读入到方法区，后续的校验会针对方法区的二进制流进行校验（检查文件）</li>
<li>元数据校验：对字节码元数据进行分析，查看是否有父类，父类是否合法。（检查类）</li>
<li>字节码校验：保证方法体字节码的合法性，比如是否有非法的类型转换、赋值能。jdk1.7后增加了StackMapTable用来保存方法体中初始的状态，校验时候直接通过读取StackMapTable即可（检查方法）</li>
<li>符合引用校验：字段的引用是否合法，是否访问了不存在的字段、方法、以及超过了访问权限等</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>   java虚拟机为类的变量分配内存的过程，这里指的是static修饰的变量因为实例变量会在实例创建时候赋值。对于一般情况变量分配完内存后要赋0值，真实的值保存在&lt;clinit&gt;()方法中，在初始化时候才会赋值。final修饰的变量会在该阶段赋值真实值</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  java将class文件中的符号引用改为直接引用的过程</p>
<p>  字段的解析</p>
<ul>
<li>普通引用比如对于字段N类型C来说，将N交给类的ClassLoader加载C的类型</li>
<li>数组加载数组的ComponentType的类，然后由虚拟机生成数组的直接应用</li>
<li><p>校验范围权限</p>
<p>类方法的解析</p>
</li>
<li><p>检查类的class_index如果是类方法，class_index是接口方法直接抛出java.lang.IncompatibleClassChangeError异常。</p>
</li>
<li>类中有方法的简单名称和描述符返回，否则去父类查找如果有返回，否则去接口查找如果接口有抛异常java.lang.AccessMethodError,如果没有抛出java.lang.NoSuchMethodError</li>
<li><p>检查访问权限</p>
<p>接口方法解析：步骤同上只是不用检查权限</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  在该阶段开始执行java代码（字节码），生成方法&lt;clinit&gt;()。</p>
<ul>
<li>clinit方法是由静态字段和静态代码块共同合并生成，且顺序自上到下</li>
<li>如果有父类，且父类有有静态类和静态字段，父类的clinit方法会先调用</li>
<li>接口因为也可能有静态阶段，接口也可能生成clinit，如果有父类接口，只有用到父类接口的变量才会生成父类接口的clinit方法</li>
</ul>
<p>注意clinit出于线程安全考虑会加锁这就是为什么static代码块只执行一次。如果static里阻塞会阻塞类的创建</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>唯一性：ClassLoader+类=唯一，每个ClassLoader都有自己的类命名空间，这个会影响到instanceOf等结果。</p>
<p>java的classloader分为3种</p>
<ol>
<li>启动类加载器：Bootstrap ClassLoader，由C++编写，java无法直接调用，如果将类委托给该加载器调用改classloader回报异常。用于加载JAVA_HOME/lib以及 -Xbootclasspath对应地址的类并且要符合命名规则，比如rt.jar</li>
<li>扩展类加载器：Extension ClassLoader，由java编写，java可直接调用。JAVA_HOME/ext/lib或者java.ext.dirs指定的类</li>
<li>应用类加载器：Application ClassLoader，由java编写，java可直接调用。classpath中的类，如果不指定自己的classloader他是默认的classloader</li>
</ol>
<p>类加载的双亲委派模型：即类加载器会优先调用父类的加载器，父类加载器会调用直到启动类加载器，之后在调用自己的类加载器。好处在于对于一些系统的类全局只有一个唯一的Class类（受唯一性约束）。顺序是：启动类加载器–&gt;扩展类加载器–&gt;应用类加载器–&gt;自定义类加载器。</p>
<p>这是java建议的使用方法</p>
<p>双亲委派模型的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class＜?＞loadClass(String name,<span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">  Class c=findLoadedClass(name)</span><br><span class="line">  <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>（parent！=<span class="keyword">null</span>）&#123;</span><br><span class="line">          c=parent.loadClass(name,<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          c=findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>（ClassNotFoundException e）&#123;</span><br><span class="line">       <span class="comment">//如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">       <span class="comment">//说明父类加载器无法完成加载请求</span></span><br><span class="line">    &#125; <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">      <span class="comment">//在父类加载器无法加载的时候</span></span><br><span class="line">      <span class="comment">//再调用本身的findClass方法来进行类加载</span></span><br><span class="line">      c=findClass(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JAVA类文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JAVA类文件结构/" class="post-title-link" itemprop="url">JAVA类文件结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-11-05 20:51:37" itemprop="dateCreated datePublished" datetime="2019-11-05T20:51:37Z">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="class类的结构"><a href="#class类的结构" class="headerlink" title="class类的结构"></a>class类的结构</h2><p>如图，单位是字节u1代表1个字节。</p>
<p><img src="/JAVA类文件结构/class类文件格式.png" alt="avator"></p>
<h2 id="魔术和版本号"><a href="#魔术和版本号" class="headerlink" title="魔术和版本号"></a>魔术和版本号</h2><p>  文件前4个字节代表这是个java文件固定CAFEBABE<br>  第5、6字节代表此版本号，7、8字节代表主版本号，版本号有向下兼容性</p>
<h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p> 紧接着这就是常量池了，常量池的前俩个字节偏移量是0x00000008,代表常量的个数，和java其他的数据表示方法不一样，常量池下标是从1开始，（比如数字是22，常量21个索引范围是1~21个）常量池有14种数据类型，每一个常量的第一位tag（长度u1）就是它类型，见下图：<br><img src="/JAVA类文件结构/class类结构2.png" alt="avator"></p>
<p> 具体数据个数如下：<br><img src="/JAVA类文件结构/class类结构3.png" alt="avator"></p>
<p>  可以通过javap命令查看类的常量池 javap-verbose TestClass</p>
<h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>  是一个标志位，标志类是否是public的是interface还是class是否声明为final等，具体如下：</p>
<p><img src="/JAVA类文件结构/class类结构4.png" alt="avator"></p>
<p>  计算方式采用“|”</p>
<h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>  类索引、父类索引长度都是8,指向常量表的索引，接口索引是一组指向常量表的索引。<br>  除了Object类，父类索引都不是0。</p>
<h2 id="字段表、方法表集合"><a href="#字段表、方法表集合" class="headerlink" title="字段表、方法表集合"></a>字段表、方法表集合</h2><p>包括了</p>
<ul>
<li>访问标志(access_flags)：public、private等，长度8个字节</li>
<li>名称索引(name_index)：指向常量表</li>
<li>修饰符所以(descripor_index)：用简短方法表述字符比如java.lang.String[]，描述为[Ljava/lang/String</li>
<li>属性集合表count(attribute_count):长度8个字节，代表属性长度</li>
<li><p>属性信息(attribute_info):长度8个字节，数量attribute_count，代表属性信息。方法有固定的属性Code</p>
<p>附：<br>字段表结构<br><img src="/JAVA类文件结构/字段表结构.png" alt="avator"><br>字段access_flags<br><img src="/JAVA类文件结构/字段访问标志位.png" alt="avator"><br>方法表访问标志位<br><img src="/JAVA类文件结构/methodtableacc.png" alt="avator"><br>demo<br><img src="/JAVA类文件结构/zdjgbdemo.png" alt="avator"></p>
</li>
</ul>
<h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>  <img src="/JAVA类文件结构/attrtable1.png" alt="avator"><br>  <img src="/JAVA类文件结构/attrtable2.png" alt="avator"></p>
<h2 id="java的自己码指令"><a href="#java的自己码指令" class="headerlink" title="java的自己码指令"></a>java的自己码指令</h2><p>  jvm的指令码是面试操作栈的，它的指令由1个字节的代码特殊含义的操作码以及后面0到多个操作参数组成。由于操作码是1个字节所以java最多有255个操作码。</p>
<p>  感觉jvm是讲数据读到操作栈中操作，在写回栈帧的局部变量中。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的性能分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的性能分析/" class="post-title-link" itemprop="url">JVM的性能分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-25 16:58:05" itemprop="dateCreated datePublished" datetime="2019-10-25T16:58:05Z">2019-10-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="jvm的常用工具"><a href="#jvm的常用工具" class="headerlink" title="jvm的常用工具"></a>jvm的常用工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>  作用：监视java进程状态的工具</p>
<p>  命令格式：jps [option][hostid]</p>
<p>  参数：<br>-m：输出启动时传给main函数的方法<br>-l：输出主类全名如果是jar包，输出路径<br>-v：输出虚拟机启动时Jvm的参数</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>  作用：监视java进程各种运行状态的信息</p>
<p>  命令格式：jstat[option] vmid [interval][s|ms][count]]</p>
<p>  参数：主要分三类、类装在、垃圾收集、运行期编译状况</p>
<p>-class<br>-gc<br>-gccapacity<br>-gcutil<br>-gccaise<br>-gcnew<br>-gcnewcapacity<br>-gcold<br>-gcoldcapacity<br>-gcpermcapacity<br>-complier<br>-printcompilation</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">6.20</span> <span class="number">41.42</span> <span class="number">47.20</span> <span class="number">16</span> <span class="number">0.105</span> <span class="number">3</span> <span class="number">0.472</span> <span class="number">0.577</span></span><br><span class="line"></span><br><span class="line">  s0、s1:survivor</span><br><span class="line">  E:eden区</span><br><span class="line">  O:old区</span><br><span class="line">  M:metaspace</span><br><span class="line">  YGC:minorGc的次数</span><br><span class="line">  YGCT:minorGc的时间</span><br><span class="line">  FGC:FullGC的次数</span><br><span class="line">  FGCT:FullGc的时间</span><br><span class="line">  GCT:的时间</span><br></pre></td></tr></table></figure>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>  作用：查看、修改虚拟机的配置。</p>
<p>  命令格式：jinfo [option] pid</p>
<p>  参数：<br>  -flag &lt;name&gt;         to print the value of the named VM flag<br>  -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag<br>  -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value<br>  -flags               to print VM flags<br>  -sysprops            to print Java system properties</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>  作用：java内存映射工具,可以查询finalize执行队列、java堆和永久代的详细信息、如空间使用率、当前采用的收集器等</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -heap                打印java堆详细的信息<br>    -histo[:live]        打印堆中对象统计信息，Live只统计存活的信息<br>    -clstats             打印Classloder的信息<br>    -finalizerinfo       显示F-Queue中等待Finalizer线程执行finalizer方法的对象<br>    -dump:&lt;dump-options&gt; 生成java堆快照：live只打印存活的对象，如果不指定打印所有对象，format=b二进制格式的文件，file=&lt;file&gt;打印到某个&lt;file&gt;中。eg: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;<br>    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo<br>                         to force a heap dump or histogram when &lt;pid&gt; does not<br>                         respond. The “live” suboption is not supported<br>                         in this mode.<br>    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>  作用：配合jmap分析dump出来的jmap文件，不建议在应用服务器上使用，因为dump文件很大，并且很耗性能，建议在单独的服务器上执行<br>  命令格式：jhat /dumpfile<br>  使用方法：打开浏览器，访问jhat所在服务器的7000端口。查看内存泄漏用OQL工具和Heap Historygram功能</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>  作用：java堆栈跟踪工具，定位java每一个线程当前时刻的执行快照，可以定位到线程运行的状况是否死锁等。</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p>
<h3 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h3><p>  作用：jit生成码反汇编插件，通过jvm设置的参数-XX PrintAssmbly把动态生成的代码还原成汇编代码</p>
<p>  命令格式： jmap [option] &lt;pid&gt;</p>
<p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p>
<h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><ul>
<li><p>JConsole</p>
</li>
<li><p>VisualVM</p>
<p>综上，我们可以用jps jstat jinfo查看jvm的信息。jmap、jhat查看堆信息。jstack查看栈信息。我们可以用可视化工具来方便查看上面的信息推荐VisualVM</p>
<p>下载地址： <a href="http://visualvm.java.net/download.html" target="_blank" rel="noopener">http://visualvm.java.net/download.html</a><br>idea可以通过pulgins安装通过简单配置即可实现动态的VisualVM功能</p>
</li>
</ul>
<h2 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h2><h3 id="高性能硬件的场景"><a href="#高性能硬件的场景" class="headerlink" title="高性能硬件的场景"></a>高性能硬件的场景</h3><p>  如果硬件性能较高，我们一般采用俩种方式</p>
<ol>
<li>采用64位虚拟机，设置很大的堆内存</li>
<li><p>采用32位虚拟机，虽然堆内存最大设置4（还受限于平台对进程最大使用内存的限制有可能只有2g，windows平台）我们可以给一台服务器设置多个进程+前端反向代理的方法。</p>
<p>第一种方案我们要注意64位虚拟机往往比32位虚拟机要慢（指针膨胀、内存补齐等需求），另外由于堆内存很大，我们一定要注意大对象导致频繁GC的问题，因为一次fullGC有可能需要停顿10几秒，对于交互多的服务体验会很差</p>
</li>
</ol>
<h3 id="共享缓存导致oom"><a href="#共享缓存导致oom" class="headerlink" title="共享缓存导致oom"></a>共享缓存导致oom</h3><p>  由于共享缓存频繁的写入导致内存oom。需要检查缓存的使用率。</p>
<h3 id="对外内存导致的oom"><a href="#对外内存导致的oom" class="headerlink" title="对外内存导致的oom"></a>对外内存导致的oom</h3><p>  有以下几种对外内存</p>
<p>  DirectMemory:主要用于nio场景，比如内存环境是2G。我们给堆内存分配了1.6G。那么堆外内存最多只能有0.4G不到，如果这时候大量请求过来会导致oom</p>
<p>  线程堆栈：会出现StackOverflowError或者StackOutOfMemoryError</p>
<p>  JNI的调用：由于是native方法所以也是堆外内存</p>
<p>  Socket的读写Buffer：receive和send都有一个buffer分别是37kb和25kb。如果超出了会出现open many file的错误。</p>
<p>  系统线程和gc线程</p>
<h3 id="外部命令导致系统变缓慢"><a href="#外部命令导致系统变缓慢" class="headerlink" title="外部命令导致系统变缓慢"></a>外部命令导致系统变缓慢</h3><p>  比如调用Runtime.getRuntime.exec()执行shell。java是fork了个进程，这个指令很重如果调用的频繁系统的负载会很重，建议采用api的方式。</p>
<h3 id="外部接口超时导致系统崩溃"><a href="#外部接口超时导致系统崩溃" class="headerlink" title="外部接口超时导致系统崩溃"></a>外部接口超时导致系统崩溃</h3><p>  调用远程接口响应较慢导致连接大量被占用，同时对连接没做限制导致了虚拟机崩溃。需要设置超时时间，或者采用生产者消费者异步的方式。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JVM的垃圾回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JVM的垃圾回收机制/" class="post-title-link" itemprop="url">JVM的垃圾回收机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-17 19:34:53" itemprop="dateCreated datePublished" datetime="2019-10-17T19:34:53Z">2019-10-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jvm的内存分为线程独享的线程栈、程序计数器；线程共享的方法区、堆区，线程栈在编译时候就确定好了大小，方法执行完成后自动就可以回收所以是静态的。而方法区、堆区只有在运行时才知道内存分配的大小所以内存回收是动态的。本章主要讨论的是堆和方法区的垃圾回收</p>
<h2 id="对象是否可被回收算法"><a href="#对象是否可被回收算法" class="headerlink" title="对象是否可被回收算法"></a>对象是否可被回收算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>  给对象添加一个引用计数器，当被引用时候引用计数+1，在垃圾回收时候只要应用计数为0就可以回收对象了。算法很简单，弊端是无法解决循环应用问题。<br>  即：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.instance=b;</span><br><span class="line">b.instance=a;</span><br></pre></td></tr></table></figure>
<p>  这时候a和b是无法被回收的。</p>
<h3 id="可达性分析算法-java采用的方式"><a href="#可达性分析算法-java采用的方式" class="headerlink" title="可达性分析算法-java采用的方式"></a>可达性分析算法-java采用的方式</h3><p>我们通过对象GCRoot做可达性分析，如果对象的引用链没有GCRoot对象，说明对象是可以被回收的。jvm中适合做GCRoot对象的有</p>
<ul>
<li>jvm方法栈中的局部变量表中的变量</li>
<li>jvm本地方法栈中的native对象</li>
<li>方法区中的静态变量</li>
<li>方法区中的常量</li>
</ul>
<h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>对象按照应用的按照从强到弱分别如下：</p>
<ul>
<li>强引用：我们new一个对象默认就是强引用。必须等到GcRoot不可达</li>
<li>软引用：SoftReference对象，不管内存是否足够，下一次gc都会回收该对象</li>
<li>弱引用：WeakReference对象，当内存不足时候时候gc会回收弱引用对象</li>
<li>虚引用：PhantomReference，又称幽灵引用，不对对象的生命周期造成影响，get()方法返回的也是null，只在对象被回收时候系统会收到一个通知。使用场景堆外内存回收。系统调用unfase方法申请一块堆外内存，然后在堆中会持有一个虚引用的对象，当该对象被回收时候会清理堆外内存</li>
</ul>
<h2 id="finalize方法以及对象的自救"><a href="#finalize方法以及对象的自救" class="headerlink" title="finalize方法以及对象的自救"></a>finalize方法以及对象的自救</h2><p>  对象被回收需要通过标记、回收两部，第一步先标记可会回收的对象，然后检查对象是否实现了finalize()方法，如果对象实现了finalize方法并且在gc时候没有被系统调用过，则认为是可finalize的，会放在一个优先级比较低的F-Queue队列中，之后会有finalize线程执行finalize()方法，如果这时候把this赋值给别的标量则完成了对象的自救。</p>
<p>  注意:</p>
<ul>
<li>只会执行一次；</li>
<li>finalize的执行由于优先级较低即为不靠谱不推荐使用。比如在finalize方法中执行一些清理操作我们可以放在finnal中执行</li>
</ul>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>  永久代的回收效率比较低（类信息、常量、静态变量），主要回收类信息、常量</p>
<p>  回收常量：当该常量没有任何应用</p>
<p>  回收类信息：</p>
<ol>
<li>没有任何该class的实例</li>
<li>该类的ClassLoader被回收</li>
<li>Class没有任何访问、即通过反射创建该Class的元素</li>
</ol>
<h2 id="gc的算法"><a href="#gc的算法" class="headerlink" title="gc的算法"></a>gc的算法</h2><h3 id="mark-swap-标记清理"><a href="#mark-swap-标记清理" class="headerlink" title="mark-swap 标记清理"></a>mark-swap 标记清理</h3><p>标记对象后将需要回收的对象进行销毁、会造成内存碎片，可能导致大对象没法分配</p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>年轻代会采用这种算法，jvm认为大量对象是朝生夕死，所以会将内存分为Eden和俩个Survivor空间，默认比例是8:1:1，平时只会用到一个Eden和1个Survivor。当gc时候会将所有对象赋值到没用的那个Survivor空间，然后清掉Eden和原来的Survivor空间。如果剩下的Survivor不足会进入老年代。</p>
<h3 id="mark-compact-标记整理"><a href="#mark-compact-标记整理" class="headerlink" title="mark-compact 标记整理"></a>mark-compact 标记整理</h3><p>标记之后让所有对象向一端移动，超过这个范围的对象会被回收。</p>
<h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>  从GcRoot找引用链，该操作对时间很敏感，因为这一步操作对数据一致性要求很高，所以在执行时候虚拟机必须要StopTheWorld，否则枚举根节点的结果就不准确了。方法区和堆内存往往都很大，如果都需要分析一遍性能会严重受影响。</p>
<p>  HotSpot采用了OopMap对象，需要虚拟机的解释器和JIT编译器支持，由他们来生成OopMap，把对象偏移量内存放的是什么数据保存起来，gc就很快知道了对象的信息。</p>
<h3 id="安全点-safe-point"><a href="#安全点-safe-point" class="headerlink" title="安全点 safe point"></a>安全点 safe point</h3><p>  虽然OopMap在gc时候能很方便的完成枚举根节点，但是影响OopMap数据的操作很多如果每一步操作都创建OopMap会很耗费内存。为了解决这个问题HotSpot设置了safePoint的概念，只有程序执行到safePoint，才会停止线程开始gc，并且在gc前创建OopMap。即每一个safePoint会生成一个OopMap对象。</p>
<p>  安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。</p>
<p>  现在的问题是在Safe Point让线程们以怎样的机制中断，方案有两种：抢先式中断、主动式中断。</p>
<ul>
<li>抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。</li>
<li>主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。</li>
</ul>
<h3 id="安全区域-safe-region"><a href="#安全区域-safe-region" class="headerlink" title="安全区域 safe region"></a>安全区域 safe region</h3><p>  如果线程没有分配cpu时间，必须线程处于sleep或blocked状态，就无法响应JVM的中断请求，走到安全点去挂起。Safe Region解决了这一问题。</p>
<p>  安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的。当代码执行到安全区域时，首先标识自己已经进入了安全区域，那样如果在这段时间里JVM发起GC，就不用管标示自己在安全区域的那些线程了，在线程离开安全区域时，会检查系统是否正在执行GC，如果是，就等到GC完成后再离开安全区域。</p>
<h2 id="java的垃圾回收器"><a href="#java的垃圾回收器" class="headerlink" title="java的垃圾回收器"></a>java的垃圾回收器</h2><p>HotSpot在jdk1.7之后的所有垃圾回收器，如图：</p>
<p><img src="/JVM的垃圾回收机制/垃圾收集器.png" alt="avator"></p>
<h3 id="Serial垃圾回收器"><a href="#Serial垃圾回收器" class="headerlink" title="Serial垃圾回收器"></a>Serial垃圾回收器</h3><p>  最早的最基本的垃圾回收器，jdk1.3时期新生代唯一的垃圾收集器。会停止jvm所有的工作线程。</p>
<p>  是client模式下，新生代默认的垃圾收集器，因为没有线程交互开销所以在gc过程很高效，如果新生代内存不大，收集一次的耗时是可以接受的。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>  Serial的多线程版本。</p>
<p>  是server模式下首选的新生代垃圾收集器。原因是jdk1.5之后的CMS收集器除了Serial以外只有它能和ParNew配合使用。</p>
<p>  开启CMS后，-XX：+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX：+UseParNewGC选项来强制指定它。</p>
<p>  在单线程或者俩个线程时候由于有线程切换的问题表现不见得比Serial好，他适合线程数或者核数多的场景。默认开启的线程数等于cpu的数量，当然我们也可以通过参数-XX：ParallelGCThreads来控制</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>  更关注系统的吞吐量【运行代码时间/(运行代码时间+垃圾回收时间))】适用于内部计算、和外部没有交互的服务，主要参数：</p>
<ul>
<li>-XX：MaxGCPauseMillis：设置停顿时间，保证垃圾回收时间尽量不超过这个阈值，采用所少新生代空间，会导致垃圾回收更频繁</li>
<li>-XX：GCTimeRatio：垃圾收集时间占总时间的比例。</li>
<li>-XX：+UseAdaptiveSizePolicy：值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数。</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>  Serial的老年版垃圾收集，采用“标记-整理”算法，目前主要用于配合Parallel Scavenge和作为CMS的替代方案。</p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>  Parallel Scavenge老年版，使用多线程和“标记-整理”算法。适合吞吐量优先的场景。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>  大名鼎鼎的ConcurrentMarkSweep。以获取最短停顿时间为目标的垃圾回收期，试用场景希望停顿时间较短的场景。</p>
<p>  分为四个阶段：</p>
<ol>
<li>初始标记（CMS Initial Mark）：会stop the world。标记GcRoots能直接关联的对象。只做标记所以很快；</li>
<li>并发标记（CMS Concurrrent Mark）：不会stop the world和用户线程一起处理。去做GcRoot Tracing；</li>
<li>重新标记（CMS Remark）：会stop the world。处理初始标记到并发标记过程中新创建的对象，比初始标记长但是这时候创建的对象很少，所以停顿时间可接受；</li>
<li>并发清除（CMS Concurrrent Sweep）：不会stop the world和用户线程一起处理。去做对象的清理操作；</li>
</ol>
<p>如图：</p>
<p><img src="/JVM的垃圾回收机制/CMS收集器.png" alt="avator"></p>
<p>  默认启动线程是(CPU数量+3)/4，所以在CPU核数变高时候CMS占用的线程资源会越来越少。</p>
<p>  缺点：</p>
<ul>
<li>对cpu敏感会占用一部分用户线程，从而cpu负载很高时候导致程序变慢。</li>
<li>CMS无法处理浮动垃圾（即：因为在回收时候会产生的新对象），有可能导致另一次GC。因为在做垃圾回收时候用户线程在工作所以要预留一部分空间给用户线程。默认是92%（since 1.6）</li>
<li>内存碎片问题：由于标记清除会带来内存碎片问题导致明明很大的空间但是无法申请内存，这时候就要进行一次FullGC。<ul>
<li>CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>
<li>虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full，然后在来一次压缩的默认是0，每次进行FullGc都压缩。</li>
</ul>
</li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>  面向服务端收集器，特点：</p>
<ul>
<li>并行与并发：充分利用多核cpu,缩短stoptheworld时间。其他收集器需要停顿的它依然可以工作。</li>
<li>分代收集：虽然依然分代，但是g1可以不借助其他收集器独自工作。</li>
<li>空间整合：不会产生碎片。收集后提供规整内存。</li>
<li><p>可预测的停顿：用户可指定消耗在gc上的时间不超过n毫秒</p>
<p>G1不在区分新生代和老年代而是将堆内存分为一些大小相等的Region，Region分为新生代和老年代并且且同一年代的Region不连续的。<br>G1可预测的停顿时间的实现原理是。是内部维护了一个垃圾回收的优先级列表，针对Region内可回收的对象的大小、多少、收益能排序,优先回收收益较大的Region。</p>
<p>G1是如何解决不同Region之间的相互引用的，即新生代的Region引用了老年代的Region，它是通过每个Region持有的RememberSet。当一个Refrence发生写操作时候会生成一个WriteBarrier，暂时中断写操作，如果发现他们俩个处于不同的Region，则通过CardTable将应用信息记录到被引用对象Region的RememberSet，回收时候只需要RemberSet就可以知道准确的引用关系避免了全堆扫描。</p>
<p>G1的垃圾回收步骤</p>
</li>
</ul>
<ol>
<li>初始标记：标记下GcRoots能直接关联的对象，并且修改TAMS(next top at mark start)值，能让下一阶段并发标记时候在正确的region中创建值。需要停顿，但是很短。</li>
<li>并发标记：同cms，可以和工作线程一起运行，进行可达性分析查找存活对象，耗时较长。不需要停顿，可并行执行。</li>
<li>最终标记：修正初始标记到并发标记。从初始标记到最终标记这段时间内创建的对象都会记录到Remember Set Log中，合并到Remember Set中这段时间需要停顿线程，但是可并行执行。</li>
<li>筛选回收：根据用户设置的阈值指定回收计划。这一步理论上是不需要停顿的，但是但是停顿用户线程会增加回收效率。</li>
</ol>
<p>如图：<br><img src="/JVM的垃圾回收机制/G1收集器.png" alt="avator"></p>
<p>  综述：<br>  我们一般ParNew+CMS或者是G1的方案。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>  对象默认分配到eden区，如果开启TLAB会有限直接分配在线程栈中。</p>
<p>  大对象会直接进入老年代，对象大小超过一个PretenureSizeThreshold会直接进入老年代，</p>
<p>  长期存活的对象会晋升入老年代，每次垃圾回收对象的age会+1，如果到了MaxTenuringThreshold(默认值是15)会直接进入老年代。对象的动态年龄规划：当survivor区相同年龄的对象超过了survivor大小的一半，那么大于等于这个年龄的对象都可以直接进入到老年代。</p>
<p>  共同担保机制：当MinorGC发生时候，如果老年代的连续空闲内存空间超过新生代使用的对象的空间即可正常发生MinorGC,否则查看HanleProotionFailure值，如果开启，则会尝试MinorGC，失败后触发FullGC。如果关闭直接进行FullGC</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/JAVA虚拟机的内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/JAVA虚拟机的内存管理/" class="post-title-link" itemprop="url">JAVA虚拟机的内存管理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-15 20:27:32" itemprop="dateCreated datePublished" datetime="2019-10-15T20:27:32Z">2019-10-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>见图：</p>
<p><img src="/JAVA虚拟机的内存管理/jvm运行时数据区.png" alt="avator"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>  一块较小的内存空间，当前线程执行字节码的行号计数器，字节码解释器通过修改它来让程序知道分支、跳转、异常处理等逻辑下一条指令去哪里执行。<br>  在多线程环境中，由于当前线程在某一时刻，只会执行线程的一条指令，线程切换之后要恢复到之前程序执行的点。所以程序计数器线程独立的。<br>  如果线程执行的是JAVA方法，该值记录的是虚拟机字节码指令地址。如果是native方法该值是undifined，该区域是jvm中唯一没规定oom的区域</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>  也是线程独有的，生命周期和线程绑定在一起。描述的是JVM的内存模型：每个方法在执行时候会生成一个Stack Frame。存储方法的局部变量表、操作数栈、动态链接、方法出口等。<br>  每一个方法从执行开始到执行完毕都是Stack Frame的一个入栈到出栈的操作。<br>  局部变量表存放：java的几本类型，对象引用、returnAddress等。局部变量表的内存空间在编译时候就确定好了，当进入一个方法中，局部变量表在Stack Frame的大小是确定的不会改变。<br>  如果线程请求的虚拟机栈超过最大深度会报StackOverFlowError异常，虚拟机栈可以动态扩展但是没申请到内存会报OutOfMemoryError异常。（这里是只没打到深度但是内存不足了）</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>  基本上和JAVA虚拟机栈类似这里是指调用的是native方法。会抛出的异常如上。</p>
<h3 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h3><p>  存放对象最大的一块区域，可以是不连续的内存空间。具体针对gc方式可以分为young old metaspace等。后期还有g1回收期，这里暂时不做讨论，所有线程共享。如果内存不足会报OutOfMemoryError异常</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>  我们常说的PermSpace或者MetaSpace。用于存储Java虚拟机的类信息、静态变量、常量、即时编译的代码等。为了和堆区分开也叫（Non heap）。JVM规范对方法去限制很宽松除了内存可以不连续外，还可以不实现gc，方法区的gc主要取决于常量的回收和类的卸载。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>  在jdk1.4之后Java引入了Nio,可以直接通过native函数分配堆外内存 通过DirectByteBuffer进行读取/写入，也会引起OutOfMemoryError</p>
<h3 id="运行时的常量池"><a href="#运行时的常量池" class="headerlink" title="运行时的常量池"></a>运行时的常量池</h3><p>  方法区的一部分，类在编译时产生的常量在加载Class时候会存储在方法区的常量池中，常量池是动态的的比如String的inter()方法会在运行时动态的加入常量池，所以也有可能出现OutOfMemoryError异常</p>
<p>  补充一点：<br>  String s=”liuhao” 是一个常量是编译时候就决定好的，所以java汇总<br>  String s1=”liu”+”hao” 俩个常量相加会进入常量池儿常量池只有一个拷贝，所以s==s1<br>  String s=new String(“liuhao”) 不是常量所以不能放在常量池。<br>  String s1=s1.intern() 将s1的值写入到常量池中,扩充了常量池</p>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="HotSpot的Object的创建"><a href="#HotSpot的Object的创建" class="headerlink" title="HotSpot的Object的创建"></a>HotSpot的Object的创建</h3><p>对象创建的步骤</p>
<ol>
<li>类装载：去常量池中查找Class的符号引用，检查类是否已经被加载、解析、初始化过;</li>
<li>分配内存,依据内存是否完整有俩种分配方式<ol>
<li>指针碰撞：Bump the Pointer，规整的内存空间，Serial,ParNew这种垃圾回收机制会整理内存。将已分配、未分配用一个指针分隔开，分配时候讲指针挪动一个对象的size个位置。</li>
<li>空闲列表: Free List，不规整的内存空间,CMS垃圾回收机制不需要整理内存。维护一个空闲列表，分配时候找到一个空闲的内存空间进行分配。</li>
<li>指针碰撞的线程安全：<ol>
<li>TLAB：每个内存开辟一个独有的小的内存空间默认是Eden区1%，对象会先在TLAB上创建，这样就保证了原子性。虚拟机内部会维护一个refill_waste值，如果对象需要的空间小于TLAB的剩余空间，同时对象的size大于refill_waste，会在堆中创建，如果小于refill_waste则会新申请一个TLAB进行创建。用参数-XX:+UseTLAB开启，默认是开启的</li>
<li>CAS+失败重试，保证分配空间的原子性。</li>
</ol>
</li>
</ol>
</li>
<li>初始化对象，将对象里的属性初始化成零值</li>
<li>设置对象头：元数据信息、Hash值、GC分带年龄等</li>
<li>对象从虚拟机的角度来看已经创建完成，java代码还需要对对象进行init的设置。</li>
</ol>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>  分为对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul>
<li>MarkWord：HashCode、GC年代分龄、锁标记位、线程持有的锁、偏向的线程ID、偏向时间戳。长度32bit or 64bit。<ul>
<li>32bit:HashCode（25bit）、GC年代分龄(4bit)、锁标记位(2bit)、unused(1bit)</li>
<li>64bit:unused(25bit)、HashCode（31bit）、GC年代分龄(4bit)、锁标记位(2bit)、unused(1bit)、block（1bit）</li>
</ul>
</li>
<li>类型指针：类元素的指针告诉虚拟机它是哪个类的实例。如果是数组还需要保存数组的长度</li>
</ul>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>保存对象的真实数据，分配策略是相同宽度的对象会分配在一起，满足这个前提条件下，父类的字段会放在子类之前。</p>
<h4 id="对象填充"><a href="#对象填充" class="headerlink" title="对象填充"></a>对象填充</h4><p>用于对齐对象用，因为要求对象必须是8字节的整数倍，如果不是需要这部分进行填充。</p>
<h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p>  创建对象之后java通过栈上的refrences数据来操作对象实例，JVM没有规定如何具体访问对象有俩种访问方式，通过句柄方式和直接指针方式</p>
<p>  句柄方式:jvm在堆上开辟一块空间作为句柄池，refrence保存的是句柄地址，句柄来负责访问对象一部分指向堆中对象的实例地址，一部分指向方法区的类实例地址。<br>  好处：refrence保存的是稳定的句柄地址，当对象被移动时候refrence不需要改变。（例如gc时候移动对象）<br><img src="/JAVA虚拟机的内存管理/通过句柄访问对象.png" alt="avator"></p>
<p>  直接对象指针：refrence保存的是实例数据的指针。HotSpot采用这种方式<br>  好处：速度快。少一次句柄查找的操作。由于创建对象频繁这一步性能的节省效果很客观。<br><img src="/JAVA虚拟机的内存管理/通过直接指针方式访问对象.png" alt="avator"></p>
<h2 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h2><p>todo</p>
<h3 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h3><p>执行如下程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会出现异常信息</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line"> at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line"> at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line"> at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line"> at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line"> at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line"> at com.ericliu.practice.toy.jvm.oom.HeapOOM.main(HeapOOM.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>
<p>其中Java heap space的表示是堆溢出，可以通过HeapDumpOnOutOfMemoryError导出的文件通过MAT查看（eclipse的插件）</p>
<h3 id="java方法栈和本地方法栈溢出溢出"><a href="#java方法栈和本地方法栈溢出溢出" class="headerlink" title="java方法栈和本地方法栈溢出溢出"></a>java方法栈和本地方法栈溢出溢出</h3><p>会出现StackOverFlowError或者StackOutOfMemeoryError。执行下面代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss160k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length："</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会出现异常信息</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line"> at com.ericliu.practice.toy.jvm.oom.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">13</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>单线程的情况会出现StackOverflowError，通过不断创建线程可能会耗尽内存导致Stack的OOM,这种情况可以通过减少线程或者增大堆内存，或者减少每个线程的内存。</p>
<p>多线程会出现如下异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError：unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure>
<h3 id="方法区和常量池溢出"><a href="#方法区和常量池溢出" class="headerlink" title="方法区和常量池溢出"></a>方法区和常量池溢出</h3><p>1.6执行如下代码，因为1.7采用了MetaSpace所以失效了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现PermGen Space</p>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>可以通过DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">异常：</span><br><span class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError</span><br><span class="line"> at sun.misc.Unsafe.allocateMemory（Native Method）</span><br><span class="line"> at org.fenixsoft.oom.DMOOM.main（DMOOM.java：<span class="number">20</span>）</span><br></pre></td></tr></table></figure>
<p>特征是dump的文件很小。如果发现dump的文件很小同时用了nio可以考虑是这方面的原因。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Redis-源码理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Redis-源码理解/" class="post-title-link" itemprop="url">Redis-源码理解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-11 14:27:15" itemprop="dateCreated datePublished" datetime="2019-10-11T14:27:15Z">2019-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>  所有的Redis对象都有如下的头信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReidsObject</span>&#123;</span></span><br><span class="line">    int4 type; <span class="comment">//类型 4bit</span></span><br><span class="line">    int4 encoding; <span class="comment">//编码方式 4bit</span></span><br><span class="line">    int24 lru; <span class="comment">//lru时间戳 24bit</span></span><br><span class="line">    int32 refcount; <span class="comment">//引用计数如果为0回收 4byte</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指针 8byte</span></span><br><span class="line">&#125;robj</span><br></pre></td></tr></table></figure>
<p>  每一中RedisObject的数据类型对应一个type,但是根据情况可能对应多个encoding</p>
<h2 id="字符串的原理"><a href="#字符串的原理" class="headerlink" title="字符串的原理"></a>字符串的原理</h2><p>  Redis的字符串叫SDS格式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt;&#123;</span></span><br><span class="line">    T capacity; <span class="comment">//容量 1byte</span></span><br><span class="line">    T len; <span class="comment">//实际长度 1byte</span></span><br><span class="line">    byte flags; <span class="comment">//特殊标志位 1byte</span></span><br><span class="line">    byte[] content; <span class="comment">//数组长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  redis的字符串支持修改，为了减少修改的成本会预先申请capacity个长度的byte数组，当数组写入字符串的时候根据len定位。好处如下：</p>
<ul>
<li>当发生追加等操作时候不需要申请新的数组，copy原数组</li>
<li>获取字符串长度时候只需要访问len变量即可，不需要遍历数组</li>
<li><p>len和capacity使用泛型T可以针对长度将变量设置为byte short。对对象用到了极致</p>
<p>redis的字符串在小于44字节的时候encoding是embstr,大于44字节的encoding是raw。如果字符串是embstr，分配内存往往RedisObject和SDS是紧挨着的；如果是raw内存是不连续的；为什么是44个字节，原理如下：</p>
</li>
<li>为什么是44个字节<ul>
<li>SDS除content最少占用ReidsObject占16byte+SDS的3byte(假设这时候content为空)=19byte</li>
<li>由于redis的内存管理工具分配方式是8/16/32/64，由于头文件占据了19空间，所以至少分配32字节。当content+redisObj需要分配64字节,那么content最多存储45字节，减去最后的空字符NULL，剩余44字节。</li>
</ul>
</li>
<li>超过这个阈值Redis会认为对象是个大字符串适合用raw去存</li>
</ul>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>  Redis的hash结构，所有的key-value是一个全局的dict，以及设置了expire的key-value，另外zset的value–score的对应关系也是通过字典结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisDb</span>&#123;</span></span><br><span class="line">dict* dict;</span><br><span class="line">dict* expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    dict *dict   <span class="comment">// value=&gt;score</span></span><br><span class="line">    zskiplist *zsl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  dict采用的rehash策略是渐进式的rehash,防止hash过大rehash影响主流程。采用的hash算法是siphash</p>
<p>  扩容：当元素等于dict数组长度时候会扩容，扩容为原来的2倍，如果遇到bgsave尽量不会去扩容，但是如果当元素打到dict数组的5倍会进行强制扩容<br>  缩容：当元素低于dict数组长度10%会缩容。缩容不会考虑bgsave。</p>
<h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">int32  zlbytes; <span class="comment">//压缩表占用自己数</span></span><br><span class="line">int32  zltail_offset; <span class="comment">//最后一位偏移量用于到这遍历</span></span><br><span class="line">int16 length; <span class="comment">//长度</span></span><br><span class="line">T[] entries; <span class="comment">//元素列表</span></span><br><span class="line">int8 zlend;  <span class="comment">//压缩列表的结束标记，值：0xFF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srtuct entry&#123;</span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen; <span class="comment">//前一个长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">//元素类型编码 小于254时候一个字节，大于254时候5个字节第一个自己是254（0xFE）</span></span><br><span class="line">    optional byte[] contennt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h2><p>当集合set是整数且个数较小时候会考虑使用intset</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&lt;T&gt;&#123;</span></span><br><span class="line">    int32 encoding;</span><br><span class="line">    int32 length;</span><br><span class="line">    <span class="keyword">int</span>&lt;T&gt; content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>list采用这种数据结构是ziplist和linkedlist的整合，将linkedlist按照ziplist分段，时内存更紧凑，每一段在用链表链接起来。</p>
<h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p> zset采用这种方式，优点：快速定位.它的层数是2的64次方。<br> zset的rank的排名是通过zslforward的span对象计算出来的每次插入的时候都会维护这个值，表示当前层到这个节点跳过了多少节点</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Redis-Key的过期策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Redis-Key的过期策略/" class="post-title-link" itemprop="url">Redis-Key的过期策略</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-11 12:38:44" itemprop="dateCreated datePublished" datetime="2019-10-11T12:38:44Z">2019-10-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="key的过期策略"><a href="#key的过期策略" class="headerlink" title="key的过期策略"></a>key的过期策略</h2><h2 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h2><p>  为key设置expire。由于redis是单线程的如果对于过期的key扫描的过多会影响服务的卡顿，所以redis提供了惰性过期和主动扫描过期俩种方案。</p>
<p>  扫描机制，redis会把设置过期时间的key放在内存中，key的扫描过期机制如下：</p>
<ol>
<li>为了防止频繁扫描，redis每秒扫描10次过期的key，明且每次扫描建个是25ms</li>
<li>每次扫描随机取20个key</li>
<li>判断20个key是否过期，并且回收过期key</li>
<li><p>如果过期的key占1/4会重复回收</p>
<p>如果这段时间有大量的key过期，势必会增加扫描频次，同时由于redis的内存管理对数据页的回收，会导致CPU飙升，服务卡顿。</p>
<p>注意：salve没有扫描机制，master过期后会生成一条del的命令给slave执行（如果这时候宕机可能造成数据不一致）。</p>
</li>
</ol>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>  redis本质是内存数据库当内存占用满后，根据maxmemory-policy配置，会有如下几种策略</p>
<ul>
<li>noeviction：默认策略，直接拒绝写服务（del后会执行），不会丢失数据</li>
<li>volatile-lru：对设置expire的key进行淘汰。策略是lru</li>
<li>volatile-ttl：对设置expire的key进行淘汰。策略是ttl</li>
<li>volatile-random：对设置expire的key进行淘汰。策略是随机</li>
<li>allkeys-lru：对所有的key进行淘汰。策略是lru</li>
<li><p>allkeys-random：对所有的key进行淘汰。策略是随机</p>
<p>redis为了节省内存采用了近似lru算法的淘汰机制，是一种懒惰淘汰机制，即当写入操作发现内存已经超过了maxmemory时候，根据maxmemory-policy去allkeys和设置了过期时间的keys中随机取5个key淘汰掉最旧的key。</p>
</li>
</ul>
<h2 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h2><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h3><p>redis如果删除一个key正好这个key是大key，会阻碍业务的执行。redis4.0增加了unlink命令可以将key放到异步队列中由异步线程去消费。</p>
<h3 id="AOF的异步刷盘"><a href="#AOF的异步刷盘" class="headerlink" title="AOF的异步刷盘"></a>AOF的异步刷盘</h3><p>由于AOF需要调用sync，会影响业务。所以AOF的刷盘也会放到一个异步队列和线程中。为了保证效率是独立的一个线程处理</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Redis-运维/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Redis-运维/" class="post-title-link" itemprop="url">redis-运维</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-10 20:12:48" itemprop="dateCreated datePublished" datetime="2019-10-10T20:12:48Z">2019-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis的监控命令和几个重点指标"><a href="#Redis的监控命令和几个重点指标" class="headerlink" title="Redis的监控命令和几个重点指标"></a>Redis的监控命令和几个重点指标</h2><p>info &lt; seciton &gt;命令</p>
<h3 id="查看qps"><a href="#查看qps" class="headerlink" title="查看qps"></a>查看qps</h3><p>  查看redis的qps【info stats】，instantaneous_ops_per_sec 这是qps<br>  查看具体的key redis-cli monitor</p>
<h3 id="查看客户端"><a href="#查看客户端" class="headerlink" title="查看客户端"></a>查看客户端</h3><p>info clients</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Clients</span><br><span class="line">connected_clients:<span class="number">1</span></span><br><span class="line">client_longest_output_list:<span class="number">0</span></span><br><span class="line">client_biggest_input_buf:<span class="number">0</span></span><br><span class="line">blocked_clients:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>拒绝连接数如果过多应该开打链接<br>info stats</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rejected_connections:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><p>info memory</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">used_memory_human:<span class="number">796.36</span>K <span class="comment">//使用</span></span><br><span class="line">used_memory_rss_human:<span class="number">1.26</span>M <span class="comment">//top的数值</span></span><br><span class="line">used_memory_peak_human:<span class="number">877.38</span>K <span class="comment">//峰值</span></span><br><span class="line">total_system_memory_human:<span class="number">251.67</span>G</span><br></pre></td></tr></table></figure>
<h3 id="复制挤压缓冲器"><a href="#复制挤压缓冲器" class="headerlink" title="复制挤压缓冲器"></a>复制挤压缓冲器</h3><p>info replication</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span> <span class="comment">//挤压缓冲区大小</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>info stats</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sync_full:<span class="number">0</span></span><br><span class="line">sync_partial_ok:<span class="number">0</span></span><br><span class="line">sync_partial_err:<span class="number">0</span> <span class="comment">//半同步失败次数如果过多需要增大挤压缓冲区大小</span></span><br></pre></td></tr></table></figure>
<h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><p>指令安全：禁止危险命令</p>
<p>端口安全：不要暴露到公网，同时设置bindIp或者密码，注意设置密码从库也需要密码才能复制</p>
<p>脚本安全：禁止客户输入lua脚本</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Redis-集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Redis-集群/" class="post-title-link" itemprop="url">Redis-集群</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-10 13:32:41" itemprop="dateCreated datePublished" datetime="2019-10-10T13:32:41Z">2019-10-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis的集群遵循的是CAP理论中的AP，因为Redis是出现网络分区的时候，主依然提供写服务，从会采用多中方式追赶主</p>
<h2 id="主从复制和从从复制"><a href="#主从复制和从从复制" class="headerlink" title="主从复制和从从复制"></a>主从复制和从从复制</h2><p>  Redis的主从复制、从从复制是异步复制，从从复制是为了减少主的压力</p>
<h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>Redis主会将涉及到数据修改的命令写入到Buffer中，然后异步传给从库，从库执行命令并且返回偏移量给主，保证俩边的数据一致，buffer采用环状结构，如果buffer满了会覆盖原来的数据。如果出现还没有执行就被覆盖的情况会触发快照复制</p>
<h3 id="快照复制"><a href="#快照复制" class="headerlink" title="快照复制"></a>快照复制</h3><p>  快照复制很耗时。过程如下</p>
<ul>
<li>主先bgsave将快照写入到磁盘。</li>
<li>同步快照给从</li>
<li>从在接收完快照后，先持久化，在Load快照</li>
<li><p>从库开始执行这段时间的增量操作。</p>
<p>如果这段时间buffer又被覆盖了，则继续快照复制，如此恶性循环，所以要选择一个合适的复制buffer</p>
<p>快照复制前会持久化，如果这时候正好需要aof的fsync，则会推迟fsync，影响主的业务。</p>
<p>新加入的从库都需要先执行一遍快照复制。</p>
<p>Redis3.0针对这种情况采用了无盘复制的思路，遍历内存不持久化，直接传递给从库，从库如上面的过程先持久化在load，避免了主库的磁盘IO操作</p>
</li>
</ul>
<h3 id="wait命令"><a href="#wait命令" class="headerlink" title="wait命令"></a>wait命令</h3><p>可以将异步复制改为同步复制，由AP变为CP</p>
<h2 id="redis-sentinel-哨兵机制"><a href="#redis-sentinel-哨兵机制" class="headerlink" title="redis-sentinel 哨兵机制"></a>redis-sentinel 哨兵机制</h2><p>  redis在3.0提供sentinel服务，进行节点的healthCheck。</p>
<p>  客户端通过连接sentinel获取当前的master信息，客户端连接Master。</p>
<p>  如果发现master挂了，哨兵会选举新的Master,同时集群中其他的slave会和新的master开始主从同步任务。当原来的master恢复会变为slave。</p>
<p>  注意：实际上senintel的主从切换是客户端做的。</p>
<h2 id="数据切片"><a href="#数据切片" class="headerlink" title="数据切片"></a>数据切片</h2><h3 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h3><p>  codis-proxy:做请求代理<br>  codis-server:服务存储</p>
<p>  将数据分成1024个slot,数据写入时候proxy会对key做crc32求hash，然后根据槽取模。槽的映射关系会交给zookeeper和etcd这种第三方组件来维护。</p>
<p>  槽的迁移，当发现请求的key正在迁移时候会强制key进行迁移之后在去新的槽去请求。</p>
<p>  支持自动平衡。</p>
<p>  缺点：因为不是官方的方案，所以支持新的特性比较困难，且不支持事物等命令。</p>
<h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>  redis官方集群方案。</p>
<p>  将数据分为16384个slot，每个节点都保留一份slot的配置信息，并且客户端链接时候会获取一份Slot信息，这部分信息持久化到redis-cluster中。</p>
<p>  slot的跳转：当客户端发现请求的数据已经迁移后客户端会收到MOVED &lt; newSlotNum &gt; &lt; ip:port &gt;可以更新客户端的配置，然后去新的server去获取。</p>
<p>  slot的迁移：迁移是以slot为单位进行迁移，当访问到迁移的key时候流程如下：</p>
<ul>
<li>想srcNodeAddr请求，如果key在srcNodeAddr进行操作</li>
<li>如果不在srcNodeAddr，返回-ASKING tragetNodeAddr</li>
<li>向tragetNodeAddr发送不带参数的ASKING节点</li>
<li><p>返回OK，去tragetNodeAddr getKey （目的是ASKING之后告诉tragetNodeAddr下一条指令不能不处理，因为在迁移中理论上tartNode不负责这个key）</p>
<p>redis的key如果是大Key，因为迁移指令是阻塞，会影响到服务。</p>
<p>redis的集群管理是通过Gossip协议的。当一个节点发现另一个节点失联（PFail），它会广播给集群，然后当集群中其他节点收到的该节点失联事件过半数（PFail Count）时候，就标记该节点下线。</p>
<p>另外，redis-cluster的槽位迁移、节点切换都是在客户端做的。</p>
</li>
</ul>
<h2 id="分布式锁的不安全性"><a href="#分布式锁的不安全性" class="headerlink" title="分布式锁的不安全性"></a>分布式锁的不安全性</h2><p>由于主节点宕机客户端无感知，所以当客户端从主节点获取锁后，未同步到从节点这时候发生宕机。锁数据未同步成功发生了主从切换，锁是失效的，如果业务不容忍可以采用redlock机制。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://liuhao163.github.io/Redis-基本原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liu hao">
      <meta itemprop="description" content="励志当好厨子的程序员">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="liuhao163.github.io">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/Redis-基本原理/" class="post-title-link" itemprop="url">Redis-基本原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-10-09 20:35:33" itemprop="dateCreated datePublished" datetime="2019-10-09T20:35:33Z">2019-10-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2022-09-21 15:03:02" itemprop="dateModified" datetime="2022-09-21T15:03:02Z">2022-09-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/redis/" itemprop="url" rel="index"><span itemprop="name">redis</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  redis是单线程的，IO模型采用多路复用</p>
<h2 id="redis的线程模型"><a href="#redis的线程模型" class="headerlink" title="redis的线程模型"></a>redis的线程模型</h2><p>  redis的io是单线程多路复用。</p>
<p>  为客户端关键字关联一个请求队列和响应队列，用于处理请求和响应。</p>
<p>  定时任务采用最小堆的方案，俩个定时任务的间隔时间就是select(timeout)的timeout</p>
<h2 id="redis的备份"><a href="#redis的备份" class="headerlink" title="redis的备份"></a>redis的备份</h2><p>快照用于全量备份，AOF是命令重放用于增量备份</p>
<h3 id="快照的备份原理CoW"><a href="#快照的备份原理CoW" class="headerlink" title="快照的备份原理CoW"></a>快照的备份原理CoW</h3><p>由于redis的快照备份需要用到磁盘IO是没有NIO的，为了不影响业务的正常请求，redis的磁盘备份采用了系统的COW。方法如下</p>
<ol>
<li>父进程调用glibc，fork出一个子进程，这时候子进程和父进程会同时返回。父进程pid大于0,子进程pid等于0，如果小于0说明没有资源，由于是fork出的子进程，俩者共享代码段和数据段</li>
<li>父进程依然处理正常请求，子进程处理快照的持久化</li>
<li>对于写的请求，会用到系统的cow。父进程在写的时候会将数据页复制一份，在复制的这份里进行修改，子进程对应的数据页不做变更，在fork出来的那一刻就固定下来了</li>
</ol>
<p>注意，随着父进程写请求的增多，内存会持续增长，不过也不会超过原数据段的2倍。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>  随着日积月累，AOF的体积会逐渐增大，一旦重放会导致redis长期无法对外提供服务</p>
<p>  瘦身：bgrewriteaof，</p>
<ol>
<li>开辟一个新的进程遍历内存的数据，转换成一些列的指令，写到新的aof文件中</li>
<li>新增的aof指令追加的这个文件中</li>
<li><p>替换原文件完成瘦身</p>
<p>fsync，redis写aof文件是些到一个内核的内存中，通过调用fsync刷到磁盘中，如果这段时间服务器宕机会丢失数据。redis采用glibc的fsync(int fd)方法每隔一段时间刷盘一次。（每次命令都刷盘会降低吞吐）</p>
</li>
</ol>
<h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>  由于aof的fsync和快照的大块写文件都影响性能，建议持久化放在从库中做，为了防止磁盘分区还建议有多个从库。</p>
<h2 id="pipeline和事物"><a href="#pipeline和事物" class="headerlink" title="pipeline和事物"></a>pipeline和事物</h2><p>  pipeline简称管道，为了减少网络的开销，piplline可以一次提交多条指令给redis一起执行，本质上是client的行为。</p>
<p>  事物：redis支持事物，但是无法解决事物的原子性，只能保证事物的隔离性。redis事物的隔离性是通过管道来实现的</p>
<p>  为了节省性能，redis的事物往往配合pipeline一起使用。</p>
<p>  事物命令<br>  multi、exec、discard</p>
<h2 id="pubsub"><a href="#pubsub" class="headerlink" title="pubsub"></a>pubsub</h2><p>  redis自身的消息队列，缺点很明显:消息不能持久化，发送的消息只能被当时在线的消费者消费，如果消费者宕机是无法消费消息的。这个特性可以做服务发现。后续5.0提供了stream来取代它</p>
<p>  支持模式订阅，message订阅</p>
<h2 id="对象的压缩"><a href="#对象的压缩" class="headerlink" title="对象的压缩"></a>对象的压缩</h2><p>如果小于4G可以采用32位进行编译，内存会少一半</p>
<h3 id="zipList"><a href="#zipList" class="headerlink" title="zipList"></a>zipList</h3><p>压缩列表，redis在zset、hash、intset这些数据结构存储数据时候在一定阈值下回采用ziplist来存储。</p>
<p>ziplist实际上是数组的一个变种，有点是：元素长度不固定节省空间，内存地址连续对缓存友好。</p>
<p>zset：元素个数不超过128，k/v长度不超过64</p>
<p>hash、list：元素个数不超过512，k/v长度不超过64</p>
<p>set：不超过512，数据是intset时候，会进行升级，随着元素的增大会从uint16–&gt;uint32–&gt;unint64</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>  redis是以页为单位回收内存的，如果该数据页有一个key,也不会被回收。但是可以被重复使用，这点和mysql很类似</p>
<p>  redis的内存管理采用第三方库默认是jemallloc</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Liu hao</p>
              <p class="site-description motion-element" itemprop="description">励志当好厨子的程序员</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">223</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">54</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">81</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/liuhao163" title="GitHub &rarr; https://github.com/liuhao163" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:liu67224657@qq.com" title="E-Mail &rarr; mailto:liu67224657@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liu hao</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.0"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
