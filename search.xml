<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RUST学习-生命周期</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>  RUST的生命周期是指RUST的编译器用来处理悬垂引用的规则</p><p>  什么是悬垂引用：指生命周期外的变量，引用了本生命周期外的数据，因为这时候被引用的数据在离开被引用的作用域会被回收掉，导致最终引用了一个空值，而RUST的编译器是不允许这种行为产生的</p><p>  RUST对函数生命周期的检查是通过一个组件引用检查器实现的</p><h2 id="几种引用的说明"><a href="#几种引用的说明" class="headerlink" title="几种引用的说明"></a>几种引用的说明</h2><p>  见下面函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于res离开函数largest就被回收掉了所以也无法编译通过会报错：cannot return reference to local variable <code>res</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(x: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="built_in">String</span>::from(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  largest是无法编译通过的会报错:missing lifetime specifier，因为返回值的生命周期无法判断返回的是a还是b，导致编译错误，解决方案需要手动声明函数引用的生命周期，注意泛型里的’a</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的泛型-声明周期"><a href="#函数的泛型-声明周期" class="headerlink" title="函数的泛型+声明周期"></a>函数的泛型+声明周期</h2><p>  生命周期是特殊的泛型需要这么声明</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;<span class="symbol">'a</span>, T: <span class="built_in">PartialOrd</span>&gt;(x: &amp;<span class="symbol">'a</span> T, y: &amp;<span class="symbol">'a</span> T) -&gt; &amp;<span class="symbol">'a</span> T &#123;</span><br><span class="line">    <span class="keyword">if</span> x &gt; y &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RUST省略生命周期的方案"><a href="#RUST省略生命周期的方案" class="headerlink" title="RUST省略生命周期的方案"></a>RUST省略生命周期的方案</h2><p>  我们在编写函数一般不会手动指定生命周期那么，RUST是如何来推断出函数的生命周期呢，主要是遵循以下规则:</p><p>  首先RUST的函数分为输入生命周期（引用参数），和输出生命周期（返回值）,如果通过输入生命周期无法推断出输出生命周期就会报错，那么如何推导出输出生命周期呢需要遵循以下三个原则：</p><ol><li>如果没有手动指定生命周期，且有多个引用参数，则每个引用参数有不同的生命周期</li><li>如果只有一个输入生命周期，则可以把当前生命周期赋予输出生命周期</li><li>如果是一个函数即第一个参数是&amp;self或者&amp;mut self，则可以把&amp;self或者&amp;mut self的输入生命周期赋予给输出生命周期</li></ol>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-trait</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-trait/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-trait/</url>
      
        <content type="html"><![CDATA[<p>  rust的trait很想是java的interface</p><h3 id="如何定义、实现一个trait"><a href="#如何定义、实现一个trait" class="headerlink" title="如何定义、实现一个trait"></a>如何定义、实现一个trait</h3><p>通过关键字pub trait XXX{}，trait里定义的方法如果没有默认实现，可以没有方法体，那么所有实现该trait的strut的必须实现该方法，如果提供默认方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义trait 并且定义了trait的函数，给出了默认实现</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="comment">//默认实现类似于Java的Abstact模板类</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize_auther</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"unknown"</span>.to_string();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"(Read mor form &#123;&#125;...)"</span>, &amp;<span class="keyword">self</span>.sumarize_auther());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现该trait其中NewsArticle和Tweet都实现了Summary这个trait</p><ul><li>需要注意的是如果要实现trait，必须满足trait或者类型是在当前pakcage下定义的【为了安全防止你的代码别别人破坏或者别人破坏你的代码】</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> auther: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现trait</span></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"&#123;&#125;,by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.auther, <span class="keyword">self</span>.location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">sumarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"&#123;&#125;:&#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> news_article = &amp;NewsArticle &#123;</span><br><span class="line">        headline: <span class="built_in">String</span>::from(<span class="string">"头条"</span>),</span><br><span class="line">        location: <span class="built_in">String</span>::from(<span class="string">"北京"</span>),</span><br><span class="line">        auther: <span class="built_in">String</span>::from(<span class="string">"ericliu"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"学习RUST的trait"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"新闻摘要：&#123;&#125;"</span>, news_article.sumarize());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"新闻 break_info：&#123;&#125;"</span>, news_article.break_info());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tweet = &amp;Tweet &#123;</span><br><span class="line">        username: <span class="string">"ericliu"</span>.to_string(),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"学习RUST的trait"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"推文摘要：&#123;&#125;"</span>, tweet.sumarize());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"推文 break_info：&#123;&#125;"</span>, tweet.break_info());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="trait-bound"><a href="#trait-bound" class="headerlink" title="trait bound"></a>trait bound</h3><p>  我们在定义方法如果用到泛型的时候可以通过trait bound的概念对泛型进行一些定义，类似java中的<t extends xxx>这种用法,看例子</t></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get_largest &#123;&#125;"</span>,get_largest(<span class="built_in">vec!</span>[<span class="number">1</span>,-<span class="number">1</span>,<span class="number">100</span>,-<span class="number">100</span>,<span class="number">200</span>]));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"get_largest2 &#123;&#125;"</span>,get_largest2(<span class="built_in">vec!</span>[<span class="string">"hello"</span>.to_string(),<span class="string">"world"</span>.to_string(),<span class="string">"a"</span>.to_string()]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有实现了PartialOrd的泛型所指的类型T</span></span><br><span class="line"><span class="comment">//T实现了Copy的Trait，一般指对象声明在Stack上否则let mut res = v[0];会报错Cannet move</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_largest</span></span>&lt;T:<span class="built_in">PartialOrd</span>+<span class="built_in">Copy</span>&gt;(v: <span class="built_in">Vec</span>&lt;T&gt;) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> res = v[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> v.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> res &lt; item &#123;</span><br><span class="line">            res = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只有实现了PartialOrd的泛型所指的类型T</span></span><br><span class="line"><span class="comment">//T实现了Copy的Trait，一般指对象声明在Stack上否则let mut res = v[0];会报错Cannet move</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_largest2</span></span>&lt;T:<span class="built_in">PartialOrd</span>+<span class="built_in">Clone</span>&gt;(v: <span class="built_in">Vec</span>&lt;T&gt;) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> res = v[<span class="number">0</span>].clone();</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> v.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> res &lt; item.clone() &#123;</span><br><span class="line">            res = item.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait可以对泛型的实现进行限制"><a href="#trait可以对泛型的实现进行限制" class="headerlink" title="trait可以对泛型的实现进行限制"></a>trait可以对泛型的实现进行限制</h3><p>  该场景主要用于加强某些trait的行为，比如说让所有实现了traitA的类型具有B的功能，具体实现方法见下面，典型的例子是rust标准库中实现了Display的函数都实现了ToString这个trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">BreakNews</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">break_info</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过trait限制泛型的类型：给所有实现Summary的泛型实现break_info</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Summary&gt; BreakNews <span class="keyword">for</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">break_info</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">format!</span>(<span class="string">"break_info :&#123;&#125;"</span>, <span class="keyword">self</span>.sumarize());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-集合</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="vec"><a href="#vec" class="headerlink" title="vec"></a>vec</h2><p>  类似于java类型的List和golang的切片</p><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><p>俩种方法一种是Vec::new，一种是vec!宏</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>vec.push(v);</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>  索引访问和match访问，索引访问会出现数组越界的painc，而match返回值是Option,因为有None的存在所以不会出现数组月觉的patinc</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">"out of index 100 &#123;&#125;"</span>,v[<span class="number">100</span>]);<span class="comment">//panicked at 'index out of bounds: the len is 4 but the index is 100'</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(v)=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get this element is &#123;&#125;"</span>,v)&#125;,</span><br><span class="line">    <span class="literal">None</span>=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get out of index"</span>)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">match</span> v.get(<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="literal">Some</span>(v)=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get this element is &#123;&#125;"</span>,v)&#125;,</span><br><span class="line">    <span class="literal">None</span>=&gt;&#123;<span class="built_in">println!</span>(<span class="string">"v.get  out of index"</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历vector，第一次遍历用可变应用可以修改里面的值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v1=<span class="built_in">vec!</span>[<span class="number">100</span>,<span class="number">50</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v1&#123;</span><br><span class="line">    *i=*i+<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &amp;v1&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (index,i) <span class="keyword">in</span> v1.iter().enumerate()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"index &#123;&#125; v &#123;&#125;"</span>, index,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>rust在处理字符串时候常用&amp;str和String俩种类型，其中&amp;str是字符串字面值，String是标准库提供的</p><p>常用函数/宏</p><ul><li>String::from将str构造成String</li><li>format!通过占位符”{}”,格式化</li><li>String实际上是char类型的数组，所以可以采用切片方式访问即:&amp;s4[0..4]，</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s=<span class="string">"hello"</span>;<span class="comment">//这是&amp;str类型</span></span><br><span class="line"><span class="keyword">let</span> s1=<span class="built_in">String</span>::from(<span class="string">"Hello"</span>);<span class="comment">//这是string</span></span><br><span class="line"><span class="keyword">let</span> s2=<span class="built_in">String</span>::from(<span class="string">" World!"</span>);</span><br><span class="line"><span class="keyword">let</span> s4=<span class="built_in">format!</span>(<span class="string">"&#123;&#125;&#123;&#125;"</span>,s1,s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,s4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,&amp;s4[<span class="number">0</span>..<span class="number">4</span>]);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s4.chars()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="创建方法-1"><a href="#创建方法-1" class="headerlink" title="创建方法"></a>创建方法</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> hash_map = HashMap::new();</span><br><span class="line"></span><br><span class="line"><span class="comment">//拉链方法，需要显示制定类型</span></span><br><span class="line"><span class="keyword">let</span> hash_map: HashMap&lt;_, _&gt; = keys.iter().zip(values).collect();</span><br></pre></td></tr></table></figure><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p>insert</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash_map.insert(<span class="string">"blue"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//entry可以做到没有在插入</span></span><br><span class="line">hash_map.entry(<span class="built_in">String</span>::from(<span class="string">"yellow"</span>)).or_insert(<span class="number">50</span>);</span><br></pre></td></tr></table></figure><h3 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h3><p>get</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> hash_map.get(<span class="string">"yellow"</span>) &#123;</span><br><span class="line">       <span class="literal">Some</span>(v) =&gt; <span class="built_in">println!</span>(<span class="string">"match Some &#123;&#125;"</span>, v),</span><br><span class="line">       <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"key empty"</span>),</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span> hash_map&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;,&#123;&#125;"</span>,k,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-代码组成基本结构</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E6%88%90%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E6%88%90%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>  rust的代码组成结构分为package-&gt;cratio-&gt;module</p><p>  每个rust的程序都包含入口文件main.rs,模块导入文件lib.rs</p><h2 id="rust的包导入use关键字"><a href="#rust的包导入use关键字" class="headerlink" title="rust的包导入use关键字"></a>rust的包导入use关键字</h2><p>  在rs文件顶端用use关键字可以导入依赖，另外rust的函数、strut、method默认都是私有的，如果在别的模块和文件需要使用要显示的在定义处加pub</p><p>  pub use的用法:re-export重导出</p><ul><li>因为 lib.rs里有pub use front_of_hosting::hosting</li><li>所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</li><li>也可以写相对路径my_project::front_of_hosting::hosting</li><li>也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</li></ul><p>lib.rs</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::serving::take_order;</span><br></pre></td></tr></table></figure><p>main.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> my_project::eat_at_restaurant;</span><br><span class="line"><span class="keyword">use</span> my_project::front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::hosting <span class="keyword">as</span> pub_hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::take_order;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">/**\</span></span><br><span class="line"><span class="comment">    pub use的用法:re-export重导出</span></span><br><span class="line"><span class="comment">    - 因为 lib.rs里有pub use front_of_hosting::hosting</span></span><br><span class="line"><span class="comment">    - 所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</span></span><br><span class="line"><span class="comment">    - 也可以写相对路径my_project::front_of_hosting::hosting</span></span><br><span class="line"><span class="comment">    - 也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    pub_hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">    take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义mod"><a href="#定义mod" class="headerlink" title="定义mod"></a>定义mod</h2><p>  我们在开发过程中需要自己定义mod,rust对于mod的定义有特殊的犯法，如下：</p><ol><li>在lib.rs里声明mod front_of_hosting;注意这里是;</li><li>按照crate树状结构创建同名的.rs文件这里是front_of_hosting.rs</li><li>如果mod存在嵌套子mod的情况，比如这里front_of_hosting嵌套了serving和hosting，则在父mod的rs文件同样声明子mod，这里是mod hosting;和mod serving;注意这里是;</li><li>创建父mod文件夹，这里是front_of_hosting文件夹，在父mod文件夹里创建子mod的同名.rs文件\</li><li>在同名的mod的rs文件中编写代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-代码组织形式package、crate、mod</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8Fpackage%E3%80%81crate%E3%80%81mod/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8Fpackage%E3%80%81crate%E3%80%81mod/</url>
      
        <content type="html"><![CDATA[<p>  rust代码组织分为package、crate、mod</p><p>  rust代码出于安全性考虑声明的函数、mod、默认都是私有的，如果想导出需要在他们前面加上关键字“pub”</p><p>  在别的文件如果想引用mod或者函数需要使用use关键字</p><h2 id="mod声明和内容独立成文件"><a href="#mod声明和内容独立成文件" class="headerlink" title="mod声明和内容独立成文件"></a>mod声明和内容独立成文件</h2><pre><code>mod独立成文件，需要按照crate树结构创建同名的mo文件</code></pre><p>  1.在lib.rs里声明mod front_of_hosting;注意这里是;<br>  2.按照crate树状结构创建同名的.rs文件这里是front_of_hosting.rs<br>  3.如果mod存在嵌套子mod的情况，比如这里front_of_hosting嵌套了serving和hosting，则在父mod的rs文件同样声明子mod，这里是mod hosting;和mod serving;注意这里是;<br>  4.创建父mod文件夹，这里是front_of_hosting文件夹，在父mod文件夹里创建子mod的同名.rs文件\<br>  5.在同名的mod的rs文件中编写代码</p><p>lib.rs 声明父类mod</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> front_of_hosting;</span><br></pre></td></tr></table></figure><p>front_of_hosting.rs,这里声明了俩个子mod</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure><p>front_of_hosting\hosting.rs 实现mod hosting</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add_to_waitlist</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"add_to_waitlist"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"seat_at_table"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>front_of_hosting\serving.rs 实现mod rust</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">server_order</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h2><p>  默认的use是私有的，在别的文件是无法使用这个use的，如果想使用需要在use前面也加上关键字，</p><p>  一般pub use多用于重导出的场景，即:re-export</p><p>   比如我们又一个mod的路径是 crate::my_project::front_of_hosting::hosting，我们在使用他的地方都需要“use my_project::front_of_hosting::hosting”，有没有简单的导出方法呢，是有的见下面</p><ul><li>因为 lib.rs里有pub use front_of_hosting::hosting</li><li>所以main.rs里能直接 my_project::hosting，省略掉路径front_of_hosting而直接导出了hosting</li><li>也可以写相对路径my_project::front_of_hosting::hosting</li><li>也可以re-export函数，即在lib.rs pub use front_of_hosting::serveing::take_order,这里可以直接调用my_project::take_order</li></ul><p>lib.rs</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> front_of_hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> front_of_hosting::hosting;</span><br></pre></td></tr></table></figure><p>  main.rs<br>  见这里use my_project::front_of_hosting::hosting 和 use my_project::hosting as pub_hosting;【为了避免重名起了个别名】</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> my_project::front_of_hosting::hosting;</span><br><span class="line"><span class="keyword">use</span> my_project::hosting <span class="keyword">as</span> pub_hosting;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    pub_hosting::add_to_waitlist();</span><br><span class="line">    hosting::add_to_waitlist();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-枚举</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E6%9E%9A%E4%B8%BE/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<p>  枚举在rust语言里是一个很强大的数据结构</p><h2 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h2><p>  和strut很类似，关键字是enum，同时我们也能为枚举里每个值增加不同的成员，和方法，见下面的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),<span class="comment">//ipv4是4个0-255的数字</span></span><br><span class="line">    V6(<span class="built_in">String</span>),<span class="comment">//ipv6是一个字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> IpAddrKind &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;&#125; <span class="comment">//枚举的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法见下面</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ip_v4 = IpAddrKind::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> ip_v6 = IpAddrKind::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br><span class="line">    ip_v4.call();</span><br><span class="line">    ip_v6.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="match和if-let"><a href="#match和if-let" class="headerlink" title="match和if let"></a>match和if let</h2><p>  rust类似于其他编程语言开关语句（switch–case）的语法结构是match，/match必须穷举所有可能性，如果值关注几个分支，则需要_通配符，即 _ =&gt; (),</p><p>  如果只助理一个分支则可以用if let，见下面，这种方式写的代码更少，缩进更少，也使用更少末班，使用if let放弃了穷举的可能，和match相比是简洁和穷尽的取舍</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="number">0u8</span>;</span><br><span class="line">    <span class="keyword">match</span> v &#123;</span><br><span class="line">        <span class="number">0</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" zero"</span>); &#125;</span><br><span class="line">        <span class="number">1</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" one"</span>); &#125;</span><br><span class="line">        <span class="number">2</span> =&gt; &#123; <span class="built_in">println!</span>(<span class="string">" two"</span>); &#125;</span><br><span class="line">        _ =&gt; (),<span class="comment">//忽略其他 类似switch</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这个例子plus_one对Option枚举里的值+1并且返回，有俩个分支一个None一个是Some，这里我们输出非None，这里可以搭配else使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我们想输出None这种分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">None</span> = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one NONE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何访问枚举的成员"><a href="#如何访问枚举的成员" class="headerlink" title="如何访问枚举的成员"></a>如何访问枚举的成员</h2><p>  可以用上面的if let和match</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Match访问成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">vlue_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Dime =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Quarter(State) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Quarter from State:&#123;:?&#125;"</span>, State);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//if let访问成员变量</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vlue_in_cents函数如何访问State成员</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Coin result &#123;&#125;"</span>, vlue_in_cents(Coin::Quarter(State::Alabama)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Option枚举"><a href="#Option枚举" class="headerlink" title="Option枚举"></a>Option枚举</h2><p>  Option<t>枚举是很特殊的一个枚举类型，他包含Some<t>和None俩个值，其中None是用来处理null这种情况的，因为RUST里没有NULL。</t></t></p><p>  见下面的plus_one函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(input: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> input &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        <span class="literal">Some</span>(v) =&gt; <span class="literal">Some</span>(v + <span class="number">1</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">//如果只助理一个分支则可以用if let，见下面，这种方式写的代码更少，缩进更少，也使用更少末班，使用if let放弃了穷举的可能，和match相比是简洁和穷尽的取舍</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在这个例子plus_one对Option枚举里的值+1并且返回，有俩个分支一个None一个是Some，这里我们输出非None，这里可以搭配else使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">Some</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(v) = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one :&#123;&#125;"</span>, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里我们想输出None这种分支</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> result = plus_one(<span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">None</span> = result &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"plus_one NONE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-strut</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-strut/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-strut/</url>
      
        <content type="html"><![CDATA[<p> rust的类型（结构体）定义是通过strut定义</p><h2 id="strut定义"><a href="#strut定义" class="headerlink" title="strut定义"></a>strut定义</h2><p>   见下面，在使用的时候，需要给所有的成员赋值，有一个简写的更新语法。</p><p>   在声明struts时候，如果strut可变需要声明为mut，如果strut声明为mut，它所有的成员都是mut的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//声明一个strut,</span></span><br><span class="line">    <span class="keyword">let</span> imt_user1=User&#123;</span><br><span class="line">        user_name:<span class="built_in">String</span>::from(<span class="string">"lh"</span>),</span><br><span class="line">        email:<span class="built_in">String</span>::from(<span class="string">"lh@heyi.com"</span>),</span><br><span class="line">        sign_in_account:<span class="literal">false</span>,</span><br><span class="line">        active:<span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//struts的更新语法 注意..imt_user1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> user2=User&#123;</span><br><span class="line">       user_name:<span class="built_in">String</span>::from(<span class="string">"lh2"</span>),</span><br><span class="line">        email:<span class="built_in">String</span>::from(<span class="string">"lh2@heyi.com"</span>),</span><br><span class="line">        ..imt_user1</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    user_name:<span class="built_in">String</span>,</span><br><span class="line">    email:<span class="built_in">String</span>,</span><br><span class="line">    sign_in_account:<span class="built_in">bool</span>,</span><br><span class="line">    active:<span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tuple-strut"><a href="#tuple-strut" class="headerlink" title="tuple strut"></a>tuple strut</h2><p>  元祖结构体，可以对元祖声明称一个结构体，见下面,使用方法如下，可以通过元祖方式访问下标</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> black=Color(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> origin=Point(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"black.0 &#123;&#125;"</span>,black.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"origin.2 &#123;&#125;"</span>,origin.<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>,<span class="built_in">i32</span>,<span class="built_in">i32</span>);</span><br></pre></td></tr></table></figure><h2 id="strut的输出"><a href="#strut的输出" class="headerlink" title="strut的输出"></a>strut的输出</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">//这里表示该数组可以通过&#123;:?&#125; &#123;:#?&#125;打印</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,rect);<span class="comment">//要加#[derive(Debug)]</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:#?&#125;"</span>,rect);<span class="comment">//&#123;:#?&#125;比&#123;:?&#125;更易读</span></span><br></pre></td></tr></table></figure><h2 id="strut的方法和函数"><a href="#strut的方法和函数" class="headerlink" title="strut的方法和函数"></a>strut的方法和函数</h2><p>  函数的定义，和实现在impl块内，一个strut可以有多个impl块</p><p>  strut的method:第一个参数为&amp;self，调用方式&lt;strut实例名&gt;.&lt;method的Name&gt;</p><p>  strut的函数：第一个参数非&amp;self,调用方式&lt;strut的名称&gt;::&lt;func的name&gt;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    length: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="comment">//关联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(width:<span class="built_in">u32</span>,length:<span class="built_in">u32</span>)-&gt;Rectangle&#123;</span><br><span class="line">        <span class="keyword">return</span> Rectangle&#123;</span><br><span class="line">            width,length</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size:<span class="built_in">u32</span>)-&gt;Rectangle&#123;</span><br><span class="line">        <span class="keyword">return</span> Rectangle&#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mut_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area1</span></span>(<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>,other:&amp;Rectangle)-&gt;<span class="built_in">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width&gt;other.width &amp;&amp; <span class="keyword">self</span>.length&gt;other.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意：strut的方法调用，第一个参数可以是self，&amp;self,&amp;mut self，name在调用的时候自动帮你加上&amp;，&amp;mut 注意如果是rect这时候会触发实例的所有权move</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rect = Rectangle &#123;</span><br><span class="line">    width: <span class="number">50</span>,</span><br><span class="line">    length: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"method : &#123;&#125;"</span>, rect.area());<span class="comment">//rect自动加上了 &amp;</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"method : &#123;&#125;"</span>, rect.mut_area());<span class="comment">//因为是&amp;mut self,所以rect声明为mut，调用时候自动加上了&amp;mut</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mut_area</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area1</span></span>(<span class="keyword">self</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width*<span class="keyword">self</span>.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>,other:&amp;Rectangle)-&gt;<span class="built_in">bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.width&gt;other.width &amp;&amp; <span class="keyword">self</span>.length&gt;other.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RUST学习-所有权</title>
      <link href="RUST%E5%AD%A6%E4%B9%A0-%E6%89%80%E6%9C%89%E6%9D%83/"/>
      <url>RUST%E5%AD%A6%E4%B9%A0-%E6%89%80%E6%9C%89%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>  本章会讲解rust的核心特性，所有权</p><p>  程序运行时候都必须管理他们使用内存的方式<br>    – java,go通过gc来管理内存<br>    – c++ c通过显示的分配和释放内存来管理<br>    –rust用一套所有权机制来管理，编译器咋编译时候检查的规则。因为在编译时检查所以在运行时候没有任何回收内存的开销</p><h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ol><li>每个值都有一个变量，这个变量是这个值的所有者</li><li>每个值同时只能有一个所有者</li><li><p>当所有者超出作用域时候该值会被删除</p><p>代码实例</p></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s在离开main作用域时候会通过drop（）函数使其失效变量会立即交回给系统</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s=<span class="built_in">String</span>::from(<span class="string">"hello"</span>)  ;</span><br><span class="line">s.push_str(<span class="string">",world"</span>);</span><br></pre></td></tr></table></figure><h2 id="通过string说明所有权"><a href="#通过string说明所有权" class="headerlink" title="通过string说明所有权"></a>通过string说明所有权</h2><p>  s1在Stack上保存了份数据ptr,len,capaciry，其中ptr是heap上保存的数据的地址<br>  s2在Stack上复制了份s1的数据ptr,len,capaciry，其中ptr是heap上保存的数据的地址<br>  当s1,s2都离开作用域时候会通过drop释放堆内存数据，这时候会引起bug double free，rust为了解决这个问题引入了move的概念</p><p>  move的原理：<br>  rust的所有权机制的解法：第一不会复制heap上的数据，第二由于s1赋值给了s1，那么s1堆内存的引用会失效，s1离开作用域不会释放任何数据，当然在作用域中s1不能再被使用。</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">let</span> s1=<span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// let s2=s1;</span></span><br><span class="line"><span class="comment">// println!("&#123;&#125;",s1); //这里会报错value borrowed here after move</span></span><br></pre></td></tr></table></figure><p>  clone的概念：相比于move连heap的值都copy过来这时候 s1是可以用的</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s3=s1.clone();</span><br></pre></td></tr></table></figure><h2 id="Stack上的所有权问题"><a href="#Stack上的所有权问题" class="headerlink" title="Stack上的所有权问题"></a>Stack上的所有权问题</h2><p>  Stack上的赋值：copy.比如整数，<br>  Rust提供了Copy trait，当一个类型实现了Copy trait，那么旧的变量在赋值后依然可用；Drop trait 如果类型实现了该trait，就不能在实现Copy trait了</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y=x;</span><br><span class="line"><span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>,x); <span class="comment">//这时候x是可用的</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> rust </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;安全基本知识-加密&#39;</title>
      <link href="%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-%E5%8A%A0%E5%AF%86/"/>
      <url>%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86-%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h2><ol><li>对称加密：首选AES-GCM-256</li><li>非对称加密：首选RSA 2048如果选择ECC首选ECC 多用于对称加密秘钥的传输</li><li>单向散列：首选HMAC-SHA256，无论使用那种算法都需要加盐</li><li>消息认证：首选HMAC-SHA256，因为它能实现消息认证，和完整性保证</li></ol><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><ol><li>首选TLS1.2，新业务推荐直接使用TLS1.3及以上版本</li></ol><h2 id="口令标准"><a href="#口令标准" class="headerlink" title="口令标准"></a>口令标准</h2><ol><li>能够与SSO集成的建议继承SSO，并且配合SSO实现双因子认证或者动态口令</li><li>使用静态口令场景应该符合<ol><li>不使用默认口令</li><li>不使用通用口令</li><li>口令长度不小于14位</li><li>应包含大写、消息、符号、字母、数字</li><li>用户口令<ol><li>不小于8位</li><li>应包含大写、消息、符号、字母、数字</li><li>建议不上传用户口令，用户侧用慢速散列发给服务端，服务端通过加盐配合HMAS-SHA256存储</li></ol></li></ol></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>使用运维提供的组件清单中的服务</li><li>禁止使用FTP、Telnet等不安全的服务q</li></ol>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA的并发包:Lock和Conidtion</title>
      <link href="JAVA%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8C%85-Lock%E5%92%8CConidtion/"/>
      <url>JAVA%E7%9A%84%E5%B9%B6%E5%8F%91%E5%8C%85-Lock%E5%92%8CConidtion/</url>
      
        <content type="html"><![CDATA[<h2 id="再造管程的意义"><a href="#再造管程的意义" class="headerlink" title="再造管程的意义"></a>再造管程的意义</h2><p>  java的管程的关键字是synchronized，在1.6后对管程做了升级，引入了偏向锁，轻量级锁的概念，性能几乎和Lock相近。然而在某些场景还是没法取到Lock。<br>  主要集中synchronized如下的几个痛点</p><ol><li>无法主动响应中断：在synchronzed代码块中，如果已经获取了资源a,在获取b失败后，就直接进入了阻塞，无法主动响应中断，这时候遇到死锁我们是无法处理的；</li><li>无法设置过期时间：synchronzed无法设置过期时间;</li><li>无法在非阻塞情况下竞争锁资源：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="lock的原理"><a href="#lock的原理" class="headerlink" title="lock的原理"></a>lock的原理</h2><p>我们以ReentrantLock为例子，类似管程，每个资源都一个等待队列。它是用一个双向链表实现的等待队列，同时每个链表的节点包含一个volatile的变量state作为锁标记位：0-release,1-lock。在调用lock/unlock方法中会通过cas修改volatile来实现state的变化。他是如何来保证在上锁解锁时候的可见性的呢？我们用下面的代码说明<br>rtl.lock上锁–&gt;之后value+=1–&gt;解锁,他们在并发场景下根据HB原则.</p><ol><li>顺序原则：线程1中：rtl.lock （HB于） value+=1 ；value+=1（HB于）rtl.unlock()</li><li>volatile的原则：此情况是针对线程1的rtl.unlock已经修改state成功但是由于可见性线程2的rtl.lock也申请锁的时候是否会失败？答案是不会，因为但当线程1的rtl.unlock修改state()和线程2的lock修改sate()发生冲突时候，由于rlt.lock需要先读取state，根据volatile的原则，写HB于读，所以unlock一定HB于lock，这时候lock一定读到的是最新的值</li><li>传递性原则：由于线程1的value+=1（HB于）rtl.unlock()，所以线程1的value+=1一定（HB于）于线程2的rtl.lock()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock rtl = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    rtl.lock();  </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value+=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 保证锁能释放</span></span><br><span class="line">      rtl.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock的特点"><a href="#lock的特点" class="headerlink" title="lock的特点"></a>lock的特点</h2><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>lock和synchronized一样都是可重入锁：即同一个线程在获取锁之后，可以重复获取锁资源。（不可重入锁：即在此尝试获取锁资源会进入阻塞）</p><h2 id="公平锁和非公平数锁"><a href="#公平锁和非公平数锁" class="headerlink" title="公平锁和非公平数锁"></a>公平锁和非公平数锁</h2><p>lock可以实现贡公平锁，如：ReentrantLock的构造方法,见下面代码，具体可以看Sync的代码，如果是非公平锁，有可能最后获取资源的反而最先释放。详细可以去看<br>ReentrantLock内部类Sync的tryAcquire俩种实现。其中FairSync里有一个判断hasQueuedPredecessors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lock中的等待通知机制-Condition"><a href="#Lock中的等待通知机制-Condition" class="headerlink" title="Lock中的等待通知机制-Condition"></a>Lock中的等待通知机制-Condition</h2><p>管程中最主要的一个功能就是wait的等待通知机制。那么lock的等待通知机制则是Condition</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition condition=lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等同于 object.wait()</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等同于 object.notify() object.notifyAll();</span></span><br><span class="line">    condition.signal();</span><br><span class="line">    condition.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作异步转同步"><a href="#操作异步转同步" class="headerlink" title="操作异步转同步"></a>操作异步转同步</h2><p>有些操作本身是异步的，但是我们在使用中需要同步的场景，比如dubbo中我们的客户端通过tcp发送数据给服务端后，我们需要接收到返回值才能继续处理请求。而tcp本身就是异步的。这时候就需要同步转异步操作是如何实现的呢,见DefaultFeature，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object ret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待结果转同步</span></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                condition.await(<span class="number">1000L</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isDone()) &#123;</span><br><span class="line">                <span class="keyword">throw</span>  <span class="keyword">new</span> RuntimeException(<span class="string">"timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Object response)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.ret = response;</span><br><span class="line">            <span class="comment">//在别的线程获取结果后异步通知</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lock的最佳实践"><a href="#lock的最佳实践" class="headerlink" title="lock的最佳实践"></a>lock的最佳实践</h2><p>永远只用于锁要修改的成员表变量<br>永远只在访问可变的成员标量加锁<br>永远不要在调用其他对象的方法加锁—因为你不确定他内部是如何实现的</p><p>推荐阅读：</p><p>Doug Lea《Java 并发编程：设计原则与模式》</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> aqs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="dubbo/index/"/>
      <url>dubbo/index/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisy源码-概述</title>
      <link href="MyBatisy%E6%BA%90%E7%A0%81-%E6%A6%82%E8%BF%B0/"/>
      <url>MyBatisy%E6%BA%90%E7%A0%81-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  mybatis在国内是是java-web开发里非常重要的框架，通过xml配置的mappr对数据库进行了orm映射，降低程序对数据库访问的开发难度。</p><p>  希望通过阅读mybatis源码可以了解orm框架都有哪些角色，每个角色的边界是什么</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>  作用：加载配置文件活着注解。</p><p>  关键类：Configuration：该对象加载了配置里的数据源、mappr的映射即“MappedStatement”，并且缓存到内存中</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><pre><code>作用：关键类：MappedStatement</code></pre><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><pre><code>作用：关键类：Executor</code></pre><h3 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h3><pre><code>作用：关键类：</code></pre><ol><li>StatementHandler</li><li>ParamenterHandler</li><li>ResultSetHandler</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> orm </tag>
            
            <tag> mybatis </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机</title>
      <link href="%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>最近刷题lc8写一个string–&gt;int的函数，结题思路是用限自动机的方案</p><ol><li>穷举有几种数字状态“ ”,”+/-“,”0-9”,”其他字符”，对应的 start、signin_number、end</li><li>穷举每种状态之间转化关系</li><li>遇到每种字符后，处理每种状态的逻辑</li></ol><h2 id="源码如下："><a href="#源码如下：" class="headerlink" title="源码如下："></a>源码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.MAX_VALUE);</span><br><span class="line">        System.out.println(Integer.MIN_VALUE);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().myAtoi(<span class="string">"123213213213213211234"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Automation automation=<span class="keyword">new</span> Automation();</span><br><span class="line">        <span class="keyword">return</span> automation.cal(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Automation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> String curState = <span class="string">"start"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Automation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            initStatus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">                parseChar(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sign * (<span class="keyword">int</span>) res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//穷举当前状态和下一个状态的对应关系</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//' '、+/-、0-9、other"</span></span><br><span class="line">            map.put(<span class="string">"start"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"start"</span>, <span class="string">"sign"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"sign"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"innumber"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"innumber"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">            map.put(<span class="string">"end"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理每种对应关系</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseChar</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            String state = map.get(curState)[getNextState(c)];</span><br><span class="line">            <span class="keyword">if</span> (state.equals(<span class="string">"innumber"</span>)) &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">                res = sign == <span class="number">1</span> ? Math.min(res, (<span class="keyword">long</span>) Integer.MAX_VALUE) : Math.min(res, -(<span class="keyword">long</span>) Integer.MIN_VALUE);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(<span class="string">"sign"</span>)) &#123;</span><br><span class="line">                sign = c == <span class="string">'-'</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curState = state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNextState</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">' '</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>当我们的系统复杂度到一定程度的时候，对象的状态分支会很多，我们可以选择用if，else来解决，但是最后往往会写出一堆几乎无法维护的屎山。那么我们可以将对象抽象成一个个状态，特殊情况实际上就是状态之间的转换。</p><p>比如上题，就是有限的状态之间的转换。<br><img src="/自动机/img0.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ebpf学习-初探ebpf</title>
      <link href="ebpf%E5%AD%A6%E4%B9%A0-%E5%88%9D%E6%8E%A2ebpf/"/>
      <url>ebpf%E5%AD%A6%E4%B9%A0-%E5%88%9D%E6%8E%A2ebpf/</url>
      
        <content type="html"><![CDATA[<h2 id="ebpf是什么"><a href="#ebpf是什么" class="headerlink" title="ebpf是什么"></a>ebpf是什么</h2><p>  Linux内核一直是实现监视/可观察性，网络和安全性的理想场所。不幸的是，这通常是不切实际的，因为它需要更改内核源代码或加载内核模块，并导致彼此堆叠的抽象层。 eBPF是一项革命性的技术，可以在Linux内核中运行沙盒程序，而无需更改内核源代码或加载内核模块。通过使Linux内核可编程，基础架构软件可以利用现有的层，从而使它们更加智能和功能丰富，而无需继续为系统增加额外的复杂性层。</p><p>  eBPF导致了网络，安全性，应用程序配置/跟踪和性能故障排除等领域的新一代工具的开发，这些工具不再依赖现有的内核功能，而是在不影响执行效率或安全性的情况下主动重新编程运行时行为。</p><p>  如果直接解释eBPF，有点不明所以。那我们就看看有哪些基于eBPF的工程，这些工程或许你已经知道，或是已经经常使用，也许你会明白eBPF距离我们并不遥远。</p><h2 id="基于eBPF的项目"><a href="#基于eBPF的项目" class="headerlink" title="基于eBPF的项目"></a>基于eBPF的项目</h2><ol><li><p>bcc<br>BCC是用于创建基于eBPF的高效内核跟踪和操作程序的工具包，其中包括一些有用的命令行工具和示例。 BCC简化了用C进行内核检测的eBPF程序的编写，包括LLVM的包装器以及Python和Lua的前端。它还提供了用于直接集成到应用程序中的高级库。</p></li><li><p>bpftrace<br>bpftrace是Linux eBPF的高级跟踪语言。它的语言受awk和C以及DTrace和SystemTap等以前的跟踪程序的启发。 bpftrace使用LLVM作为后端将脚本编译为eBPF字节码，并利用BCC作为与Linux eBPF子系统以及现有Linux跟踪功能和连接点进行交互的库。</p></li><li><p>Cilium<br>Cilium是一个开源项目，提供基于eBPF的联网，安全性和可观察性。它是从头开始专门设计的，旨在将eBPF的优势带入Kubernetes的世界，并满足容器工作负载的新可伸缩性，安全性和可见性要求。</p></li><li><p>Falco<br>Falco是一种行为活动监视器，旨在检测应用程序中的异常活动。 Falco在eBPF的帮助下审核Linux内核层的系统。它使用其他输入流（例如容器运行时度量标准和Kubernetes度量标准）丰富了收集的数据，并允许连续监视和检测容器，应用程序，主机和网络活动。</p></li><li><p>Katran<br>Katran是一个C ++库和eBPF程序，用于构建高性能的第4层负载平衡转发平面。 Katran利用Linux内核中的XDP基础结构来提供用于快速数据包处理的内核功能。它的性能与NIC接收队列的数量成线性比例，并且使用RSS友好的封装转发到L7负载平衡器。</p></li><li><p>Sysdig</p><p>Sysdig是提供深层系统可见性的简单工具，并具有对容器的原生支持。<br>其他基于eBPF技术的项目还有很多，比如kubectl-trace ，ply 等，这里不再赘述。</p></li></ol><h2 id="一个简单的DEMO"><a href="#一个简单的DEMO" class="headerlink" title="一个简单的DEMO"></a>一个简单的DEMO</h2><p> 下面我们写一个简单的demo来展示下开发一个ebpf程序需要哪些步骤，这里我们采用Cilium/ebpf库进行开发，因为ebpf的用户态代码可以用golang开发。:P</p><p> 程序是通过ebpf的tracepoint监听syscalls/sys_enter_execve，在执行该方法时候获取pid和commd。通过ebpf的map将pid和commd传到用户态。</p><h3 id="step-1-环境搭建"><a href="#step-1-环境搭建" class="headerlink" title="step.1 环境搭建"></a>step.1 环境搭建</h3><p>系统配置： Ubuntu 20.04.4<br>系统依赖： llvm，clang-10.0.0-4ubuntu1，还有linux的kernel这里源码在路径（/kernel-src），golang环境</p><h3 id="step-2-编写ebpf的kernel侧的程序-c代码"><a href="#step-2-编写ebpf的kernel侧的程序-c代码" class="headerlink" title="step.2 编写ebpf的kernel侧的程序-c代码"></a>step.2 编写ebpf的kernel侧的程序-c代码</h3><ol><li>编写代码并且用下面命令将代码变成bpf_program.o<br>clang -O2 -target bpf -c bpf_program.c -I/kernel-src/tools/testing/selftests/bpf  -o bpf_program.o</li><li>将bpf_program.o文件copy到golang程序下</li></ol><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/bpf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bpf_helpers.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC(NAME) __attribute__((section(NAME), used))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义c的结构，将pid和comm封装到该结构体，将该结构体通过tracker_map传递给用户态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_data_t</span> &#123;</span></span><br><span class="line">    __u32 pid;</span><br><span class="line">    <span class="keyword">char</span> comm[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ebpf的map</span></span><br><span class="line"><span class="function">struct bpf_map_def <span class="title">SEC</span><span class="params">(<span class="string">"maps"</span>)</span> tracker_map </span>= &#123;</span><br><span class="line">        .type = BPF_MAP_TYPE_HASH,</span><br><span class="line">        .key_size = <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">        .value_size = <span class="keyword">sizeof</span>(struct <span class="keyword">event_data_t</span>),</span><br><span class="line">        .max_entries = <span class="number">2048</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ebpf程序挂载点，</span></span><br><span class="line">SEC(<span class="string">"tracepoint/syscalls/sys_enter_execve"</span>)</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bpf_prog</span><span class="params">(<span class="keyword">void</span> *ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_data_t</span> <span class="title">evt</span> = &#123;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    __u64 id = bpf_get_current_pid_tgid();</span><br><span class="line">    evt.pid = id &gt;&gt; <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    bpf_get_current_comm(&amp;evt.comm, <span class="keyword">sizeof</span>(evt.comm));</span><br><span class="line">    bpf_map_update_elem(&amp;tracker_map, &amp;index, &amp;evt, BPF_ANY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//协议</span></span><br><span class="line"><span class="keyword">char</span> _license[] SEC(<span class="string">"license"</span>) = <span class="string">"GPL"</span>;</span><br></pre></td></tr></table></figure><h3 id="step3用户态侧代码-golang的代码"><a href="#step3用户态侧代码-golang的代码" class="headerlink" title="step3用户态侧代码-golang的代码"></a>step3用户态侧代码-golang的代码</h3><ul><li>编写go代码</li><li>执行go build ./</li><li>执行go程序，这里是go-tools</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mapKey <span class="keyword">uint32</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ebpf标签的说明</span></span><br><span class="line"><span class="comment">// BpfProg对应的是c程序中的bSEC(tracepoinst/...)的方法名</span></span><br><span class="line"><span class="comment">// TrackerMap对应的c程序中的SEC(map)</span></span><br><span class="line"><span class="keyword">type</span> bpfPrograms <span class="keyword">struct</span> &#123;</span><br><span class="line">BpfProg    *ebpf.Program <span class="string">`ebpf:"bpf_prog"`</span></span><br><span class="line">TrackerMap *ebpf.Map     <span class="string">`ebpf:"tracker_map"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *bpfPrograms)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := p.BpfProg.Close()</span><br><span class="line">err = p.TrackerMap.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字段类型，对应c程序中的event_data_t类型，注意Comm是uint8</span></span><br><span class="line"><span class="keyword">type</span> EventData <span class="keyword">struct</span> &#123;</span><br><span class="line">Pid  <span class="keyword">uint32</span></span><br><span class="line">Comm [<span class="number">20</span>]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e EventData)</span> <span class="title">CommHex</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ba := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, b := <span class="keyword">range</span> e.Comm &#123;</span><br><span class="line">ba = <span class="built_in">append</span>(ba, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">string</span>(ba)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//程序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadTestEbpf</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> err := rlimit.RemoveMemlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载c编译出来的.o文件的相对路径,这个地址一定不能出错</span></span><br><span class="line">spec, err := ebpf.LoadCollectionSpec(<span class="string">"ebpf/bpf_program.o"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值obj</span></span><br><span class="line">obj := bpfPrograms&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := spec.LoadAndAssign(&amp;obj, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> obj.Close()</span><br><span class="line"></span><br><span class="line">tp, err := link.Tracepoint(<span class="string">"syscalls"</span>, <span class="string">"sys_enter_execve"</span>, obj.BpfProg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tp.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read loop reporting the total amount of times the kernel</span></span><br><span class="line"><span class="comment">// function was entered, once per second.</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">log.Println(<span class="string">"Waiting for events.."</span>)</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value []<span class="keyword">byte</span></span><br><span class="line"><span class="comment">//c的结构体序列化成bytes（value）</span></span><br><span class="line"><span class="keyword">if</span> err := obj.TrackerMap.Lookup(&amp;mapKey, &amp;value); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"reading map: %v"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">var</span> event EventData</span><br><span class="line"><span class="comment">//c的结构体序列化成golang的喜爱那个并且打印出来</span></span><br><span class="line"><span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(value), binary.LittleEndian, &amp;event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"parsing perf event: %s"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"pid:%v,comm:%v"</span>, event.Pid, event.CommHex())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序入口</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ebpf.LoadTestEbpf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step3，运行查看效果"><a href="#step3，运行查看效果" class="headerlink" title="step3，运行查看效果"></a>step3，运行查看效果</h3><ul><li>在终端1上运行：./go-tools</li><li>在中断2上输入任何指令</li><li>查看终端1的输出</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2022</span>/<span class="number">03</span>/<span class="number">11</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">26</span> reading <span class="keyword">map</span>: lookup: key does not exist</span><br><span class="line"><span class="number">2022</span>/<span class="number">03</span>/<span class="number">11</span> <span class="number">17</span>:<span class="number">01</span>:<span class="number">30</span> pid:<span class="number">60184</span>,comm:sshd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebpf </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用antlr开发一个简单的规则引擎</title>
      <link href="%E7%94%A8antlr%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/"/>
      <url>%E7%94%A8antlr%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>golang源码学习-sync.Map</title>
      <link href="Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sync-Map/"/>
      <url>Go%E8%AF%AD%E8%A8%80%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-sync-Map/</url>
      
        <content type="html"><![CDATA[<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>  位于sync包中，主要解决map的线程安全的问题，适用于读多写少的场景。</p><h2 id="sync-Map的原理"><a href="#sync-Map的原理" class="headerlink" title="sync.Map的原理"></a>sync.Map的原理</h2><p>  内部持有俩个map，一个是read，类型是atomic.Value实际类型是【map[interface{}]<em>entry】，一个是dirty类型是map【[interface{}]</em>entry】。</p><p>  其中read主要解决无数据竞争的情况下数据的快速访问，它通过cas进行快速的读写操作；一旦出现数据的竞争，就会用到dirty，dirty里面保存read里所有非nil的值【通过状态来表示unexpunged】，当出现竞争后数据会写到dirty而不是read中。</p><p>  数据的访问路径大致是：</p><ul><li>读，先从read里找，read里没有，去dirty里找，如果miss过一定的阈值【dirty的长度】时候，将dirty和read交换，交换后dirty置为nil；</li><li><p>写，先判断key是否存在，如果存在且不为expunaged，先通过cas写快速返回，否则有如下分支：</p><ul><li>如果key是expunaged，说明key之前被删除了，但是dirty没有，unexpunaged之后同步修改read和dirty</li><li>如果key不存在于read，但是存在于dirty修改dirty</li><li>如果key不存在与read和dirty，初始化dirty【如果需要】，数据写入dirty</li></ul><p>因为数据在并发写的时候一旦发生竞争还是会用到锁，并发写的时候的锁是不可避免的。所以sync.Map适用于读多写少数据冲突不那么复杂的场景</p></li></ul><h2 id="sync-Map的源码分析"><a href="#sync-Map的源码分析" class="headerlink" title="sync.Map的源码分析"></a>sync.Map的源码分析</h2><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">mu Mutex <span class="comment">//锁 用来保护read、dirty的并发控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// read包含部分map的内容，他是atomic.Value类型的用来解决并发访问的安全的问题，在读的场景不需要加锁，而在写的场景需要mu的控制</span></span><br><span class="line">read atomic.Value <span class="comment">// readOnly </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dirty访问要在mu的保护下进行，他包含所有的readOnly里non-expunged的数据</span></span><br><span class="line"><span class="comment">// 在read中标记为Expunged的entries不会被存储在dirt中，如果一个在read中存在的key被标记为expunged,他需要先unexpunged在保存在dirty中</span></span><br><span class="line"><span class="comment">// 如果dirty是nil，当下一次修改map的时候需要初始化dirty，初始化的方式是将read的不为exunped的value都copy到dirty中</span></span><br><span class="line">dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器，当从read读取数据时候miss回增加该值，打到一定的阈值，即miss&gt;=len(dirty)的时候回触发dirty和read的互换</span></span><br><span class="line">misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// read中的值</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">amended <span class="keyword">bool</span> <span class="comment">// 一个标记为，默认是false，true说明readOnly的m和dirty已经同步过了，即dirty不为nil了，在Store操作中，dirtyLocked函数调用后会置为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 封装了指向value值的指针</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If p == nil, the entry has been deleted and m.dirty == nil.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If p == expunged, the entry has been deleted, m.dirty != nil, and the entry</span></span><br><span class="line"><span class="comment">// is missing from m.dirty.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty</span></span><br><span class="line"><span class="comment">// != nil, in m.dirty[key].</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An entry can be deleted by atomic replacement with nil: when m.dirty is</span></span><br><span class="line"><span class="comment">// next created, it will atomically replace nil with expunged and leave</span></span><br><span class="line"><span class="comment">// m.dirty[key] unset.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// An entry's associated value can be updated by atomic replacement, provided</span></span><br><span class="line"><span class="comment">// p != expunged. If p == expunged, an entry's associated value can be updated</span></span><br><span class="line"><span class="comment">// only after first setting m.dirty[key] = e so that lookups using the dirty</span></span><br><span class="line"><span class="comment">// map find the entry.</span></span><br><span class="line">p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标记位当entry.p=expunged说明，该对象在read中被删除，标记了expunged的key不会出现在dirty中。</span></span><br><span class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;))</span><br></pre></td></tr></table></figure><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Store</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">//从read中获取readOnly，如果key存在，通过cas修改不为expunged的值，成功后快速返回</span></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改失败通过锁进行鬓发保护</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)<span class="comment">//双重检查</span></span><br><span class="line"><span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line"><span class="comment">//key存在于read但是状态是expunged，cas修改成nil，同步dirty和readOnly的值，</span></span><br><span class="line"><span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line"><span class="comment">//走到这里说明dirty已经被初始化了，见m.dirtyLocked()里e.tryExpungeLocked()这一步</span></span><br><span class="line">m.dirty[key] = e</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cas保存value</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line"><span class="comment">//key存在于dirty</span></span><br><span class="line">e.storeLocked(&amp;value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//!read.amended说明dirty为空初始化dirty，将read中不为expunged值写入dirty，见下面</span></span><br><span class="line"><span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">m.dirtyLocked()</span><br><span class="line">m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改dirty的值</span></span><br><span class="line">m.dirty[key] = newEntry(value)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">dirtyLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">m.dirty[k] = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">tryExpungeLocked</span><span class="params">()</span> <span class="params">(isExpunged <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Load</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line"><span class="comment">//优先读取read</span></span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="comment">//key不存在但是dirty已经初始化，这里需要锁来保护并发冲突</span></span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)<span class="comment">//双重检查</span></span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="comment">//从dirty里取</span></span><br><span class="line">e, ok = m.dirty[key]</span><br><span class="line"><span class="comment">//超过阈值交换dirty和read,并且dirty置为nil，见下面</span></span><br><span class="line">m.missLocked()</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载value</span></span><br><span class="line"><span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">load</span><span class="params">()</span> <span class="params">(value <span class="keyword">interface</span>&#123;&#125;, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">missLocked</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.misses++</span><br><span class="line"><span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">m.dirty = <span class="literal">nil</span></span><br><span class="line">m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">e, ok := read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">m.mu.Lock()</span><br><span class="line">read, _ = m.read.Load().(readOnly)</span><br><span class="line">e, ok = read.m[key]</span><br><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line"><span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">&#125;</span><br><span class="line">m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">e.<span class="built_in">delete</span>()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span> <span class="title">delete</span><span class="params">()</span> <span class="params">(hadValue <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line"><span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal如何在子线程传递</title>
      <link href="ThreadLocal%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92/"/>
      <url>ThreadLocal%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>主线程如何向自己创建的子线程传递ThreadLocal值，只需要创建InheritableThreadLocal值,实现原理如下：</p><p>InheritableThreadLocal覆写了它三个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建线程时候，会调用该方法,见下面init</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Map时候，返回的是t.inheritableThreadLocals，见ThreadLocal操作值</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//createMap时候，返回的是t.inheritableThreadLocals，见ThreadLocal操作值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>见子线程初始化过程,初始化时候如果当前线程inheritableThreadLocals不为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//这里初始的是this.inheritableThreadLocals</span></span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocal.createInheritedMap会调用ThreadLocalMap(ThreadLocalMap parentMap)方法，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//这里调用InheritableThreadLocal覆写的childValue，返回的是parent的value，将parent的值copy到子线程中</span></span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么inheritableThreadLocals它什么时候不为空呢，见下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在set值时候判断ThreadLocalMap为空，调用InheritableThreadLocal.getMap方法返回当前线程的t.inheritableThreadLocals，否则初始化t.inheritableThreadLocals</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取的是t.inheritableThreadLocals的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除值实际上删除的t.inheritableThreadLocals</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 案例分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坑-下载文件，丢失文件格式和后缀</title>
      <link href="%E5%9D%91-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%A2%E5%A4%B1%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%90%8E%E7%BC%80/"/>
      <url>%E5%9D%91-%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%EF%BC%8C%E4%B8%A2%E5%A4%B1%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%90%8E%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>将记录导出成excel供下载，生成xlsl以后下载文件会丢失文件格式，curl链接情况如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bogon:~ liuhaoeric$ curl -vvv https:<span class="comment">//xxxxxx.xlsx -output xxxxx.xlsx </span></span><br><span class="line">.....</span><br><span class="line">&lt; Content-Disposition: inline; filename=<span class="string">"xxxxx"</span> <span class="comment">//上传时候需制定filename这就是下载的文件名，如果filename未制定文件后缀名下载就会丢失文件格式</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>上传时候指定filename时候xxxxx.xlsx</p><p>在curl发现代码已经变为如下所示，问题解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; Content-Disposition: inline; filename=<span class="string">"xxxxx.xlsx"</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSL的请求过程</title>
      <link href="SSL%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <url>SSL%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>  公钥即证书：由服务端传递给客户端，用于客户端的CA证书校验合法性；非对称加密clientKey；<br>  CA证书：内置于系统中用于校验公钥的合法性<br>  私钥：服务端保存，用于非对称解密clientKey<br>  clientKey：公钥验证通过后由浏览器生成clientKey通过对称加密和服务端进行交互</p><h2 id="发送请求的过程"><a href="#发送请求的过程" class="headerlink" title="发送请求的过程"></a>发送请求的过程</h2><ol><li>浏览器发送请求给服务端，这时候端口是443；</li><li>服务端返回公钥【证书】给客户端；</li><li>浏览器通过系统内置的CA证书验证证书的合法性，如果不合法请求终止；</li><li>浏览器生成clientKey明文，并且用公钥加密clientKey，发送密文的clientKey给服务端；</li><li>服务端得到加密过的公钥，用私钥解密，获取明文clientKey；</li><li>浏览器用clientKey通过对称加密方式通信：<ol><li>浏览器通过clientKey加密请求，发送给服务端；</li><li>服务端通过clientKey解密请求，并且将响应用clientKey加密发给浏览器；</li><li>浏览器接到密文响应，用clientKey解密；</li></ol></li></ol><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/SSL的请求过程/img.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协议、知识积累 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证缓存和数据库的数据一致</title>
      <link href="%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/"/>
      <url>%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4/</url>
      
        <content type="html"><![CDATA[<p>  本篇文章主要讨论常见的集中缓存的使用方案，以及如何解决数据和缓存的一致性</p><h2 id="常见的缓存模式"><a href="#常见的缓存模式" class="headerlink" title="常见的缓存模式"></a>常见的缓存模式</h2><h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache-Aside Pattern"></a>Cache-Aside Pattern</h3><p>我们常见的缓存方案，可以说我们大部分都采用这种方案，见下面:</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Aside Pattern.jpg" alt="avator"></p><h3 id="Read-Through-Write-through（读写穿透）"><a href="#Read-Through-Write-through（读写穿透）" class="headerlink" title="Read-Through/Write through（读写穿透）"></a>Read-Through/Write through（读写穿透）</h3><p>本质上和Cache-Aside Pattern类似，只是在程序和缓存中增加了一层Cache Provider，读写如果未命中由Cache Proxy来负责和缓存交互。减少程序开发的复杂性，需要中间件支持</p><h4 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read-Through"></a>Read-Through</h4><p><img src="/如何保证缓存和数据库的数据一致/Read-Through.jpg" alt="avator"></p><h4 id="Write-through"><a href="#Write-through" class="headerlink" title="Write through"></a>Write through</h4><p><img src="/如何保证缓存和数据库的数据一致/Write-Through.jpg" alt="avator"></p><h3 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h3><p>和Read-Through/Write through类似，区别是Write behind模式下，数据都是写到Cache Provider，由Cache Provider异步的刷到数据库中，听着是不是很熟悉，对Mysql的WAL异步刷盘就是这种模式</p><p><img src="/如何保证缓存和数据库的数据一致/Write-Behind.jpg" alt="avator"></p><h2 id="如何保证缓存和数据库的数据一致"><a href="#如何保证缓存和数据库的数据一致" class="headerlink" title="如何保证缓存和数据库的数据一致"></a>如何保证缓存和数据库的数据一致</h2><p>这里是以常见的Cache-Aside Pattern来讨论，正确操作缓存的姿势是</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Update.jpg" alt="avator"></p><p>这里要注意俩点</p><h3 id="不是更新缓存而是要删除缓存"><a href="#不是更新缓存而是要删除缓存" class="headerlink" title="不是更新缓存而是要删除缓存"></a>不是更新缓存而是要删除缓存</h3><p>如果更新缓存不是删除缓存在并发场景下会出现脏数据里有如下：</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Update-Dirty.jpg" alt="avator"></p><ol><li>线程A先发起一个写操作，第一步先更新数据库</li><li>线程B再发起一个写操作，第二步更新了数据库</li><li>由于网络等原因，线程B先更新了缓存</li><li>线程A更新缓存。</li></ol><p>这时DB是B操作后的数据，缓存是A操作的数据</p><h3 id="要先操作数据库而不是先操作缓存"><a href="#要先操作数据库而不是先操作缓存" class="headerlink" title="要先操作数据库而不是先操作缓存"></a>要先操作数据库而不是先操作缓存</h3><p>如果先操作缓存不是先操作数据库会在并发场景下会出现脏数据里有如下：</p><p><img src="/如何保证缓存和数据库的数据一致/Cache-Write-Dirty.jpg" alt="avator"></p><ol><li>线程A发起一个写操作，第一步del cache</li><li>此时线程B发起一个读操作，cache miss</li><li>线程B继续读DB，读出来一个老数据</li><li>然后线程B把老数据设置入cache</li><li>线程A写入DB最新的数据</li></ol><p>这时DB是A操作后的数据，缓存是B操作后的数据。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> 数据一致性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务-事务传播级别</title>
      <link href="Spring%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/"/>
      <url>Spring%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>  事务是逻辑处理原子性的保证手段，通过使用事务控制，可以极大的避免出现逻辑处理失败导致的脏数据等问题。<br>  事务最重要的两个特性，是事务的传播级别和数据隔离级别。传播级别定义的是事务的控制范围，事务隔离级别定义的是事务在数据库读写方面的控制范围。</p><p>  在spring中我们对事务的定义主要是通过注解@Transactional,控制传播级别的就是参数propagation是一个Propagation的枚举有如下的值</p><h2 id="REQUIRED（PROPAGATION-REQUIRED）"><a href="#REQUIRED（PROPAGATION-REQUIRED）" class="headerlink" title="REQUIRED（PROPAGATION_REQUIRED）"></a>REQUIRED（PROPAGATION_REQUIRED）</h2><p>默认的spring事务传播级别，使用该级别的特点是，如果上下文中已经存在事务，那么就加入到事务中执行，如果当前上下文中不存在事务，则新建事务执行。所以这个级别通常能满足处理大多数的业务场景。</p><p>即，当前的事务如果没有运行在@Transactional注解的方法中，新建一个事务，如果运行在一个@Transactional注解的方法中则加入当前事务，一旦出现异常，会连调用者的事务一起回滚。</p><h2 id="SUPPORTS（PROPAGATION-SUPPORTS）"><a href="#SUPPORTS（PROPAGATION-SUPPORTS）" class="headerlink" title="SUPPORTS（PROPAGATION_SUPPORTS）"></a>SUPPORTS（PROPAGATION_SUPPORTS）</h2><p>从字面意思就知道，supports，支持，该传播级别的特点是，如果上下文存在事务，则支持事务加入事务，如果没有事务，则使用非事务的方式执行。所以说，并非所有的包在transactionTemplate.execute中的代码都会有事务支持。这个通常是用来处理那些并非原子性的非核心业务逻辑操作。应用场景较少。</p><p>即，当前的事务如果没有运行在@Transactional注解的方法中，则没有事务，如果运行在一个@Transactional注解的方法中则加入当前事务，一旦出现异常，会连调用者的事务一起回滚。</p><h2 id="MANDATORY（PROPAGATION-MANDATORY）"><a href="#MANDATORY（PROPAGATION-MANDATORY）" class="headerlink" title="MANDATORY（PROPAGATION_MANDATORY）"></a>MANDATORY（PROPAGATION_MANDATORY）</h2><p>该级别的事务要求上下文中必须要存在事务，否则就会抛出异常！配置该方式的传播级别是有效的控制上下文调用代码遗漏添加事务控制的保证手段。比如一段代码不能单独被调用执行，但是一旦被调用，就必须有事务包含的情况，就可以使用这个传播级别。</p><p>即，当前的方法必须运行在有@Transactional注解的方法种，否则会抛出异常，和NEVER相反。</p><h2 id="REQUIRES-NEW（PROPAGATION-REQUIRES-NEW）"><a href="#REQUIRES-NEW（PROPAGATION-REQUIRES-NEW）" class="headerlink" title="REQUIRES_NEW（PROPAGATION_REQUIRES_NEW）"></a>REQUIRES_NEW（PROPAGATION_REQUIRES_NEW）</h2><p>从字面即可知道，new，每次都要一个新事务，该传播级别的特点是，每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</p><p>即，当前的方法单独运行会以事务方式运行，在@Transactional注解的方法中运行，运行到该方法时候回将当前事务挂起，新建一个事务运行，一旦出现异常，只会回滚该方法的事务，不会回滚调用者的事务。</p><p>这是一个很有用的传播级别，举一个应用场景：现在有一个发送100个红包的操作，在发送之前，要做一些系统的初始化、验证、数据记录操作，然后发送100封红包，然后再记录发送日志，发送日志要求100%的准确，如果日志不准确，那么整个父事务逻辑需要回滚。<br>怎么处理整个业务需求呢？就是通过这个PROPAGATION_REQUIRES_NEW 级别的事务传播控制就可以完成。发送红包的子事务不会直接影响到父事务的提交和回滚。</p><h2 id="NOT-SUPPORTED（PROPAGATION-NOT-SUPPORTED）"><a href="#NOT-SUPPORTED（PROPAGATION-NOT-SUPPORTED）" class="headerlink" title="NOT_SUPPORTED（PROPAGATION_NOT_SUPPORTED）"></a>NOT_SUPPORTED（PROPAGATION_NOT_SUPPORTED）</h2><p>这个也可以从字面得知，not supported ，不支持，当前级别的特点就是上下文中存在事务，则挂起事务，执行当前逻辑，结束后恢复上下文的事务。</p><p>即，当前方法单独运行不会以事务方法运行，如果运行在在@Transactional注解的方法中，运行到该方法时候会将当前事务挂起，以非事务的方式执行该方法在恢复事务</p><p>这个级别有什么好处？可以帮助你将事务极可能的缩小。我们知道一个事务越大，它存在的风险也就越多。所以在处理事务的过程中，要保证尽可能的缩小范围。比如一段代码，是每次逻辑操作都必须调用的，比如循环1000次的某个非核心业务逻辑操作。这样的代码如果包在事务中，势必造成事务太大，导致出现一些难以考虑周全的异常情况。所以这个事务这个级别的传播级别就派上用场了。用当前级别的事务模板抱起来就可以了。</p><h2 id="NEVER（PROPAGATION-NEVER）"><a href="#NEVER（PROPAGATION-NEVER）" class="headerlink" title="NEVER（PROPAGATION_NEVER）"></a>NEVER（PROPAGATION_NEVER）</h2><p>该事务更严格，上面一个事务传播级别只是不支持而已，有事务就挂起，而PROPAGATION_NEVER传播级别要求上下文中不能存在事务，一旦有事务，就抛出runtime异常，强制停止执行！这个级别上辈子跟事务有仇。</p><p>即，该方法不能运行在注解@Transactional的方法中，和MANDATORY相反</p><h2 id="NESTED（PROPAGATION-NESTED）"><a href="#NESTED（PROPAGATION-NESTED）" class="headerlink" title="NESTED（PROPAGATION_NESTED）"></a>NESTED（PROPAGATION_NESTED）</h2><p>字面也可知道，nested，嵌套级别事务。该传播级别特征是，如果上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</p><p>即：和REQUIRED（PROPAGATION_REQUIRED）类似，很少见</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>测试代码见：<a href="https://gitee.com/liuhao163/test-transational" target="_blank" rel="noopener">https://gitee.com/liuhao163/test-transational</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构-为什么要重构以及代码中的坏味道</title>
      <link href="%E9%87%8D%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93/"/>
      <url>%E9%87%8D%E6%9E%84-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h2 id="重构指什么"><a href="#重构指什么" class="headerlink" title="重构指什么"></a>重构指什么</h2><p>  这里的 <strong>重构行为</strong> 是指在不改变软件功能的前提下，通过一些 <strong>重构手段</strong> 调整代码结构使其更易维护、代码更加健壮，并且能有效降低项目的学习成本。</p><p>  为何重构</p><ul><li>改进软件设计</li><li>使软件更易读</li><li>帮助解决一些诡异的BUG</li><li>提高变成速度</li></ul><h2 id="重构的时机很重要"><a href="#重构的时机很重要" class="headerlink" title="重构的时机很重要"></a>重构的时机很重要</h2><p>  我们何时重构呢？一般来说，我们很难说找到一个比较长的周期什么事都不做，只重构。那么重构应该就穿插在我们日常工作中。</p><ul><li>预备性重构：添加新的功能之前做技术设计，发现这部分代码设计的不够合理我们可以在这时候进行该功能的重构</li><li>帮助理解的重构：当我读不懂这段代码的时候，我就要考虑进行重构，或者说的极限点，当我觉得这部分代码需要些注释才能解释明白的时候我可以考虑进行重构</li><li>捡垃圾式的重构：在读代码时候发现这段代码逻辑相同，或者结构迂回有问题</li><li>有计划的重构和见机行事的重构：在写新功能时候顺手就把不合理的代码改掉</li><li>长期重构：一些比较大的架构需要调整的视乎</li><li><p>review时候重构</p><p>另外重构尽量在程序员之间内部闭环少让产品、项目经理参与他们可能出于成本考虑阻碍重构，另外重新比重构划算时候就重写吧</p></li></ul><h2 id="重构的挑战是什么"><a href="#重构的挑战是什么" class="headerlink" title="重构的挑战是什么"></a>重构的挑战是什么</h2><ul><li>延缓新功能开发：如果一块代码被封装隔离起来了，即便写的很糟只要你不用理解它你就可以不重构它</li><li>代码所有权：一旦接口发布出去了就不好在重构了，否则需要做大量兼容工作</li><li>分支：主干发布，分支开发这种会导致，merge地狱出现</li><li>测试：重构要提前想好测试方案，减少出现BUG的几率</li><li>遗留代码：祖传代码没人敢动，还是提前准备充足测试方案</li><li>数据库的重构：做好版本管理，将改动合并到代码库中便于回滚</li></ul><h2 id="代码有哪些坏味道"><a href="#代码有哪些坏味道" class="headerlink" title="代码有哪些坏味道"></a>代码有哪些坏味道</h2><p>  在我们工程的代码中出现如下的情况，会使我们的代码产生坏的味道入股不管，这些坏味道很快就会让我们的工程腐败，所以我们可以考虑对这些地方进行进行重构。</p><h3 id="神秘命名"><a href="#神秘命名" class="headerlink" title="神秘命名"></a>神秘命名</h3><p>  当我们发现我们对方法或者函数命名不够准确，很难理解这时候我们应该考虑架构是否合理，代码结构是否应该调整。</p><p>  解决方法：</p><ol><li>改变函数声明</li><li>字段改名</li><li>变量改名</li></ol><h3 id="重复代码"><a href="#重复代码" class="headerlink" title="重复代码"></a>重复代码</h3><p>  在一个地方看到相同的代码结构，导致后期维护需要维护多个副本</p><p>  解决方法：</p><ol><li>提炼函数</li><li>如果只是相似而不是相同，我们可以先 <strong>移动语句</strong> 重组代码顺序</li><li>如果重复代码在不同的子类中，我们可以用 <strong>函数上移</strong> 将代码放到父类中</li></ol><h3 id="过长函数"><a href="#过长函数" class="headerlink" title="过长函数"></a>过长函数</h3><p>  过长的函数会导致代码很难理解</p><p>  解决方法：</p><ol><li>提炼函数，拆分成多个小函数</li><li>以查询取代临时变量，减少难以理解的临时变量</li><li>引入参数对象、保持参数完整性，减少过长的参数列表</li><li>如果还有_太多参数和临时变量，我们可以以 <strong>以命令取代函数</strong> 将这个长的函数封装成一个命令类，构造函数是参数</li><li>对于循环 <strong>拆分循环</strong> ,对于条件表达式可以 <strong>分解条件表达式</strong>，或者以 <strong>多态处理</strong></li></ol><h3 id="过长参数列表"><a href="#过长参数列表" class="headerlink" title="过长参数列表"></a>过长参数列表</h3><p>  危害同上</p><p>  解决方法：</p><ol><li>假设参数列表中的一个参数，是通过另一个参数求解出来的，我们可以用 <strong>已查询取代参数</strong> 来去掉这个参数</li><li>保持参数完整性</li><li>已入参数对象</li><li>移除标记参数</li><li>如果多个函数引用相同的参数列表，可以 <strong>函数组合成类</strong></li></ol><h3 id="全局数据"><a href="#全局数据" class="headerlink" title="全局数据"></a>全局数据</h3><p>  如果没有对数据的修改封装，很可能会造成系统BUG</p><p>  解决方案</p><ol><li>少用，如果必须要用缩短其作用域（包级别调用）</li><li>封装变量</li></ol><h3 id="可变数据"><a href="#可变数据" class="headerlink" title="可变数据"></a>可变数据</h3><p>  对数据的修改很可能会导致BUG，同上</p><p>  解决方案</p><ol><li>封装变量</li><li>拆分变量</li><li>移动语句，提炼函数</li><li>将查询函数和修改函数分离</li><li>移除设值函数</li><li>如果可变数据能在其他地方计算出来，我们可以 <strong>查询取代派生变量</strong> 即：字段只没有变，每次返回的都是计算过程</li><li>函数组合成类、函数组合成变换、引用对象改为值对象</li></ol><h3 id="发散式变化"><a href="#发散式变化" class="headerlink" title="发散式变化"></a>发散式变化</h3><p>  某个模块因为不同的原因在不同的地方发生变化，最终导致这个模块无法维护，这个其实违反了地耦合的原则，一个类应该指关心自己的上下文。</p><p>  解决方案</p><ol><li>先用拆分阶段将两者拆分、然后用搬移函数将处理逻辑分开。</li><li>如果函数内部混合了俩类处理逻辑、先提炼函数讲起拆分，如果是以类的方式定义的可以用提炼类来做拆分</li></ol><h3 id="霰弹式修改"><a href="#霰弹式修改" class="headerlink" title="霰弹式修改"></a>霰弹式修改</h3><p>  如果每次修改一个地方，都需要在很多其他类中做修改，这个其实违反了高内聚的原则。</p><p>  解决方案</p><ol><li>搬移函数或者搬移字段把要修改的代码放在同一个模块</li><li>如果有很多函数都在操作想死的数据，可以使用 <strong>函数组合</strong></li><li>如果优先函数是功能转换或者数据填充，可以使用 <strong>函数组合成变换</strong></li><li>如果一些函数输出可以组合后提供给一段专门使用这些计算结果的逻辑，可以使用 <strong>拆分阶段</strong></li><li>一个常用策略是 <strong>内联函数</strong> 或者是 <strong>内连类</strong> 将不该分散的逻辑拽到一起。</li></ol><h3 id="依恋情节"><a href="#依恋情节" class="headerlink" title="依恋情节"></a>依恋情节</h3><p>todo</p>]]></content>
      
      
      <categories>
          
          <category> 重构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
            <tag> 重构 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次安装opencv和gocv踩过的坑</title>
      <link href="%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85opencv%E5%92%8Cgocv%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
      <url>%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%89%E8%A3%85opencv%E5%92%8Cgocv%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>  最近负责一个项目将人脸算法工程，和人脸后端工程集成到一个arm架构的小型盒子中。我主要负责后端工程这部分，语言栈是golang,通过gocv调用opencv【ffmpeg】拉取rtsp视频流到本地抽帧进行人脸的比对。</p><p>  这其中涉及到gocv+opencv，由于盒子的的架构比较特殊切公司出于安全原因无法连接外网，大部分依赖只能通过源码编译，我踩了不少的坑特此记录</p><h2 id="如何安装ffmpeg"><a href="#如何安装ffmpeg" class="headerlink" title="如何安装ffmpeg"></a>如何安装ffmpeg</h2><p>  所以我马上手动编译ffmpeg，一般我们都可以用yum安装，但是这里不能联网只能源码安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ffmpeg</span><br><span class="line">./configure --<span class="built_in">enable</span>-shared --<span class="built_in">enable</span>-swscale --<span class="built_in">enable</span>-gpl --<span class="built_in">enable</span>-nonfree --<span class="built_in">enable</span>-pic --prefix=/usr/<span class="built_in">local</span>/ffmpeg --<span class="built_in">enable</span>-version3 --<span class="built_in">enable</span>-postproc --<span class="built_in">enable</span>-pthreads --<span class="built_in">enable</span>-avisynth</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="如何编译opencv"><a href="#如何编译opencv" class="headerlink" title="如何编译opencv"></a>如何编译opencv</h2><p>  下载opencv，注意版本，当前gocv的依赖库制定的是opencv4.5.0</p><p>  注意安装opencv需要cmake3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> opencv-<span class="variable">$&#123;OPENCV_VERSION&#125;</span> <span class="comment">#这里进入opencv目录</span></span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake3 -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span> -DOPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-<span class="variable">$&#123;OPENCV_VERSION&#125;</span>/modules -DOPENCV_GENERATE_PKGCONFIG=ON -DWITH_FFMPEG=on ..</span><br><span class="line">make -j <span class="variable">$proc</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>CMAKE_INSTALL_PREFIX 安装目录</li><li>OPENCV_EXTRA_MODULES_PATH 制定的一些插件目录这里用不到</li><li>OPENCV_GENERATE_PKGCONFIG 编译golang的程序时候gocv检查依赖是通过pkg-config所以要安装，会生成<em>.pc文件，之后我们可以将</em>.pc文件放到pkg-config，后面会讲到如何放</li><li>WITH_FFMPEG 处理视频流的解码要依赖</li></ul><h2 id="安装opencv-执行cmake3时候解决FFMPEG-NO"><a href="#安装opencv-执行cmake3时候解决FFMPEG-NO" class="headerlink" title="安装opencv,执行cmake3时候解决FFMPEG NO"></a>安装opencv,执行cmake3时候解决FFMPEG NO</h2><p>  我在编译opencv4.5.0，执行cmake时候发现ffmpeg总是no，导致程序启动时候无法顺利拉流下来提示Error read file :xxxx这是由于安装opencv时候check依赖ffmpeg失败导致的。原来opencv检查ffpmeg是通过pkg-config的，所以</p><p>  解决方案：我们需要将刚才编译的ffmpeg下的*.pc都拷贝到pkg-config指定的目录中</p><h2 id="指定pkg-config"><a href="#指定pkg-config" class="headerlink" title="指定pkg-config"></a>指定pkg-config</h2><p>  我们在编译golang程序时候有可能会失败，指找不到opencv库，有可能是pkg-config加载失败导致的解决方案</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=&lt;存放*.pc的目录，一般是xxx/pkgconfig&gt;:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line">pkg-config --cflags  -- opencv4  <span class="comment">#测试opencv4</span></span><br></pre></td></tr></table></figure><h2 id="加载动态链接库"><a href="#加载动态链接库" class="headerlink" title="加载动态链接库"></a>加载动态链接库</h2><p>如果想让系统找到opencv库文件需要这么做</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/ld.so.conf.d</span><br><span class="line">touch OpenCV.conf</span><br><span class="line"><span class="built_in">echo</span> &lt;libopenxxx.so所在的补录，这里一般是/usr/<span class="built_in">local</span>/lib &gt; OpenCV.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h2 id="编译golang程序"><a href="#编译golang程序" class="headerlink" title="编译golang程序"></a>编译golang程序</h2><p>  以为没法连外网所以把源码和依赖拷贝到盒子中</p><p>  下载依赖</p><ul><li>go mod tidy</li><li><p>go mod vendor</p><p>编译</p></li><li><p>go build -mod vendor</p></li></ul><p>至此，基本上坑都踩过了，特此记录。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-工具-EmbeddedValueResolverAware</title>
      <link href="Spring%E6%BA%90%E7%A0%81-%E5%B7%A5%E5%85%B7-EmbeddedValueResolverAware/"/>
      <url>Spring%E6%BA%90%E7%A0%81-%E5%B7%A5%E5%85%B7-EmbeddedValueResolverAware/</url>
      
        <content type="html"><![CDATA[<p>todo</p><p>读取配置文件的配置用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc源码-RequestMappingHandlerAdapter</title>
      <link href="SpringMvc%E6%BA%90%E7%A0%81-RequestMappingHandlerAdapter/"/>
      <url>SpringMvc%E6%BA%90%E7%A0%81-RequestMappingHandlerAdapter/</url>
      
        <content type="html"><![CDATA[<h2 id="HandlerAdapter接口的说明"><a href="#HandlerAdapter接口的说明" class="headerlink" title="HandlerAdapter接口的说明"></a>HandlerAdapter接口的说明</h2><p>  在SprintMVC中，HandlerAdapter组件是一个handler适配器类，它通过handle方法调用request对应的controller方法来处理请求【HandlerMethod】</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the given handler to handle this request.</span></span><br><span class="line"><span class="comment"> * The workflow that is required may vary widely.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> handler handler to use. This object must have previously been passed</span></span><br><span class="line"><span class="comment"> * to the &#123;<span class="doctag">@code</span> supports&#125; method of this interface, which must have 实际上是 HandlerMethod</span></span><br><span class="line"><span class="comment"> * returned &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a ModelAndView object with the name of the view and the required</span></span><br><span class="line"><span class="comment"> * model data, or &#123;<span class="doctag">@code</span> null&#125; if the request has been handled directly</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="如何获取HandlerAdapter"><a href="#如何获取HandlerAdapter" class="headerlink" title="如何获取HandlerAdapter"></a>如何获取HandlerAdapter</h2><p>见DispatcherServlet.getHandlerAdapter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerAdapter <span class="title">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">//遍历DipatcherServlet.properties里org.springframework.web.servlet.HandlerAdapter的配置，调用handlerAdpater.supports看那个符合条件</span></span><br><span class="line"><span class="comment">//Springboot中，会执行RequestMappingHandler.supports--&gt;AbstractHandlerMethodAdapter.supports 即handler是HandlerMetod</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.handlerAdapters != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (HandlerAdapter adapter : <span class="keyword">this</span>.handlerAdapters) &#123;</span><br><span class="line"><span class="keyword">if</span> (adapter.supports(handler)) &#123; </span><br><span class="line"><span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"No adapter for handler ["</span> + handler +</span><br><span class="line"><span class="string">"]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="handle方法的执行"><a href="#handle方法的执行" class="headerlink" title="handle方法的执行"></a>handle方法的执行</h2><p>  调用路径是AbstractHandlerMethodAdapter.handle()–&gt;AbstractHandlerMethodAdapter.handleInternal()–&gt;RequestMappingHandlerAdapter.handleInternal。</p><p>  见RequestMappingHandlerAdapter.handleInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleInternal</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">ModelAndView mav;</span><br><span class="line"><span class="comment">//校验requestMethod和requireSession</span></span><br><span class="line">checkRequest(request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute invokeHandlerMethod in synchronized block if required.</span></span><br><span class="line"><span class="comment">// session线程不安全，如果想用户多次请求都访问同一个session需要加一个全局锁。。性能极差很少见</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.synchronizeOnSession) &#123;</span><br><span class="line">HttpSession session = request.getSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (session != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object mutex = WebUtils.getSessionMutex(session);</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No HttpSession available -&gt; no mutex necessary</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No synchronization on session demanded at all...</span></span><br><span class="line"><span class="comment">// 关键方法，代理方法执行handlerMethod,返回modelAndView</span></span><br><span class="line">mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;</span><br><span class="line"><span class="keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;</span><br><span class="line">applyCacheSeconds(response, <span class="keyword">this</span>.cacheSecondsForSessionAttributeHandlers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">prepareResponse(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller方法的执行原理，代理模式和反射的应用：invokeHandlerMethod"><a href="#controller方法的执行原理，代理模式和反射的应用：invokeHandlerMethod" class="headerlink" title="controller方法的执行原理，代理模式和反射的应用：invokeHandlerMethod"></a>controller方法的执行原理，代理模式和反射的应用：invokeHandlerMethod</h3><p>最终的执行实际上是利用了java的反射包，以及代理模式，关键代码见：invokeHandlerMethod</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoke the &#123;<span class="doctag">@link</span> RequestMapping&#125; handler method preparing a &#123;<span class="doctag">@link</span> ModelAndView&#125;</span></span><br><span class="line"><span class="comment"> * if view resolution is required.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createInvocableHandlerMethod(HandlerMethod)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//HttpServletRequest 的封装</span></span><br><span class="line">ServletWebRequest webRequest = <span class="keyword">new</span> ServletWebRequest(request, response);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//用来处理request中的参数映射，WebDataBinderFactory里的值见：afterPropertiesSet</span></span><br><span class="line">WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);</span><br><span class="line"><span class="comment">//用来创建初始化model</span></span><br><span class="line">ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"><span class="comment">//根据handlerMethod实例化一个ServletInvocableHandlerMethod来处理请求</span></span><br><span class="line">ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);</span><br><span class="line"><span class="comment">//设置argumentResolvers处理request的参数 argumentResolvers里的值见afterPropertiesSet</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.argumentResolvers != <span class="keyword">null</span>) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodArgumentResolvers(<span class="keyword">this</span>.argumentResolvers);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置argumentResolvers处理response的参数 returnValueHandlers里的值见afterPropertiesSet</span></span><br><span class="line"><span class="comment">// 可自定义 TODO 比如想给所有的ResponseBody返回值封装成&#123;code:0,msg:1,data:null&#125;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>) &#123;</span><br><span class="line">invocableMethod.setHandlerMethodReturnValueHandlers(<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line">&#125;</span><br><span class="line">invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">invocableMethod.setParameterNameDiscoverer(<span class="keyword">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//modelAndView的上下文对象</span></span><br><span class="line">ModelAndViewContainer mavContainer = <span class="keyword">new</span> ModelAndViewContainer();</span><br><span class="line">mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line"><span class="comment">//初始化Model对象，同时将sessionAtrributes值和ModelAtrributes的值都合并在一起放在Model中</span></span><br><span class="line">modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">mavContainer.setIgnoreDefaultModelOnRedirect(<span class="keyword">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line"><span class="comment">//todo 未读</span></span><br><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line">LogFormatUtils.traceDebug(logger, traceOn -&gt; &#123;</span><br><span class="line">String formatted = LogFormatUtils.formatValue(result, !traceOn);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Resume with async result ["</span> + formatted + <span class="string">"]"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">invocableMethod = invocableMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码，通过handlerMethod的代理方法，执行Controller的方法，将结果存储到mavContainer</span></span><br><span class="line">invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取ModelAndView</span></span><br><span class="line"><span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">webRequest.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invocableMethod.invokeAndHandle(webRequest, mavContainer);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAndHandle</span><span class="params">(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码，通过java的反射机制doInvoke执行handlerMethod对应的controller方法</span></span><br><span class="line">Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);</span><br><span class="line">setResponseStatus(webRequest);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (isRequestNotModified(webRequest) || getResponseStatus() != <span class="keyword">null</span> || mavContainer.isRequestHandled()) &#123;</span><br><span class="line">disableContentCachingIfNecessary(webRequest);</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.hasText(getResponseStatusReason())) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">false</span>);</span><br><span class="line">Assert.state(<span class="keyword">this</span>.returnValueHandlers != <span class="keyword">null</span>, <span class="string">"No return value handlers"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//调用returnValueHandlers 将返回值写到response中（webRequest.getNativeResponse)里</span></span><br><span class="line"><span class="comment">// 由于现在开发采用前后端分离，RestApi往往会用到RequestResponseBodyMethodProcessor，可以看这个类，返回值和controller方法有@ResponseBody</span></span><br><span class="line"><span class="keyword">this</span>.returnValueHandlers.handleReturnValue(</span><br><span class="line">returnValue, getReturnValueType(returnValue), mavContainer, webRequest);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatErrorForReturnValue(returnValue), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invokeForRequest方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invokeForRequest</span><span class="params">(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">Object... providedArgs)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//从request里获取controller执行方法的参数，request里的值变为方法里设置的参数</span></span><br><span class="line">Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Arguments: "</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过java的反射机制，执行controller里的方法，方法参数getMethodArgumentValues获取</span></span><br><span class="line"><span class="keyword">return</span> doInvoke(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doInvoke</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ReflectionUtils.makeAccessible(getBridgedMethod());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//todo 通过反射执行方法 书签</span></span><br><span class="line"><span class="comment">//调用java反射包的invoke 代理执行HandlerMethod里econtroller对应的方法</span></span><br><span class="line"><span class="comment">// getBridgedMethod= 如果没有意外等于controller被执行的方法</span></span><br><span class="line"><span class="comment">// getBean()=Controller对象</span></span><br><span class="line"><span class="comment">// args=request通过argumentResolver得到的方法参数对象</span></span><br><span class="line"><span class="keyword">return</span> getBridgedMethod().invoke(getBean(), args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">assertTargetBean(getBridgedMethod(), getBean(), args);</span><br><span class="line">String text = (ex.getMessage() != <span class="keyword">null</span> ? ex.getMessage() : <span class="string">"Illegal argument"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(text, args), ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="comment">// Unwrap for HandlerExceptionResolvers ...</span></span><br><span class="line">Throwable targetException = ex.getTargetException();</span><br><span class="line"><span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Error) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (targetException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Exception) targetException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(formatInvokeError(<span class="string">"Invocation failure"</span>, args), targetException);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc源码-RequestMappingHandlerMapping</title>
      <link href="SpringMvc%E6%BA%90%E7%A0%81-RequestMappingHandlerMapping/"/>
      <url>SpringMvc%E6%BA%90%E7%A0%81-RequestMappingHandlerMapping/</url>
      
        <content type="html"><![CDATA[<p>RequestMappingHandlerMapping负责将RequestMapping注解的方法与url关联起来，并且返回HandlerExecutionChain</p><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><p>  DispatcherServlet.initStrategies的initHandlerMappings方法中会通过读取DispatchServerlet.proeprties对HandlerMapping进行初始化，这里重点看RequestMappingHandlerMapping类</p><p>  DispatcherServlet.properties的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span><br><span class="line">org.springframework.web.servlet.function.support.RouterFunctionMapping</span><br></pre></td></tr></table></figure><h2 id="初始化HandlerMapping"><a href="#初始化HandlerMapping" class="headerlink" title="初始化HandlerMapping"></a>初始化HandlerMapping</h2><p>  HandlerMapping，封装了是request与他的处理类HandlerMethod的映射关系，他的职责主要是通过request找到对应的handlerMapping</p><p>  AbstractHandlerMethodMapping实现了InitializingBean所以在afterPropertiesSet会进行初始化工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用initHandlerMethods</span></span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//从ApplicationContext扫描所有的bean, 找到并且将handler method注册到容器中【将url和handlerMethod关联】</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取application中所有的bean</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">       <span class="comment">//重点方法</span></span><br><span class="line">processCandidateBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法：processCandidateBean"><a href="#重点方法：processCandidateBean" class="headerlink" title="重点方法：processCandidateBean"></a>重点方法：processCandidateBean</h3><p>  根据bean找到method，封装成handlerMethod注册到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processCandidateBean</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// An unresolvable bean type, probably from a lazy bean - let's ignore it.</span></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Could not resolve type for bean '"</span> + beanName + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里isHandler判断beanType是否是一个Controller【判断是否有@Controller和@RequestMapping注解】</span></span><br><span class="line"><span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">     <span class="comment">//重点方法</span></span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><p>  detectHandlerMethods遍历bean的method方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(Object handler)</span> </span>&#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line"><span class="comment">//遍历handler中的方法，通过getMappingForMethod返回RequestMappingInfo</span></span><br><span class="line"><span class="comment">// 通过方法上的RequestMapping注解,生成RequestMappingInfo，并且和Method关联</span></span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid mapping on handler class ["</span> +</span><br><span class="line">userType.getName() + <span class="string">"]: "</span> + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(formatMappings(userType, methods));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历method--&gt;RequestMappingInfo 并且将method和mapping注册到 mappingRegistry中RequestMappingHandlerMapping对其进行了改写</span></span><br><span class="line">methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法：registerHandlerMethod-handler-invocableMethod-mapping"><a href="#重点方法：registerHandlerMethod-handler-invocableMethod-mapping" class="headerlink" title="重点方法：registerHandlerMethod(handler, invocableMethod, mapping)"></a>重点方法：registerHandlerMethod(handler, invocableMethod, mapping)</h3><p>  向容器注册HandlerMapping：registerHandlerMethod(handler, invocableMethod, mapping);<br>  这里的mappingRegistry 是AbstractHandlerMethodMapping的内部类MappingRegistry;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerHandlerMethod</span><span class="params">(Object handler, Method method, T mapping)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(T mapping, Object handler, Method method)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Assert that the handler method is not a suspending one.</span></span><br><span class="line"><span class="keyword">if</span> (KotlinDetector.isKotlinType(method.getDeclaringClass()) &amp;&amp; KotlinDelegate.isSuspend(method)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported suspending handler method detected: "</span> + method);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.readWriteLock.writeLock().lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//封装成HandlerMethod</span></span><br><span class="line">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line"><span class="comment">//判断mapping是否已经存在，存在抛异常</span></span><br><span class="line">validateMethodMapping(handlerMethod, mapping);</span><br><span class="line"><span class="comment">//关联 mapping--&gt;handlerMethod</span></span><br><span class="line"><span class="keyword">this</span>.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"><span class="comment">//根据mapping获取url并且将Url和mapping关联起来</span></span><br><span class="line">List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line"><span class="keyword">for</span> (String url : directUrls) &#123;</span><br><span class="line"><span class="keyword">this</span>.urlLookup.add(url, mapping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关联name【RequestMappingInfoHandlerMethodMappingNamingStrategy.getName】和handlerMethod</span></span><br><span class="line">String name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (getNamingStrategy() != <span class="keyword">null</span>) &#123;</span><br><span class="line">name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">addMappingName(name, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//corsLookup绑定handlerMethod和corsConfig,注解或者方法上带CrossOrigin</span></span><br><span class="line">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line"><span class="keyword">if</span> (corsConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.registry.put(mapping, <span class="keyword">new</span> MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  至此所有的RequestMapping都注册到容器中</p><h2 id="doDipatch时候"><a href="#doDipatch时候" class="headerlink" title="doDipatch时候"></a>doDipatch时候</h2><p>  通过reqeust获取handler和拦截器封装成HandlerExecutionChain过程</p><p>  找到在初始化时候注册的handlerMappings，调用它们的getHandler方法，具体实现在AbstraceHanlderMapping中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//根据request获取一个指定的handler，如果没找到返回null，类型是HandlerMethod，调用链路RequestMappingHandlerMapping.getHandlerInternal--&gt;AbstractHandlerMethodMapping.getgetHandlerInternal</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点方法1 </span></span><br><span class="line">Object handler = getHandlerInternal(request);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">handler = getDefaultHandler();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bean name or resolved handler?</span></span><br><span class="line"><span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">String handlerName = (String) handler;</span><br><span class="line">handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点方法2 返回HandlerExecutionChain【handler和拦截器】的封装</span></span><br><span class="line">HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Mapped to "</span> + handler);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled() &amp;&amp; !request.getDispatcherType().equals(DispatcherType.ASYNC)) &#123;</span><br><span class="line">logger.debug(<span class="string">"Mapped to "</span> + executionChain.getHandler());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasCorsConfigurationSource(handler)) &#123;</span><br><span class="line">CorsConfiguration config = (<span class="keyword">this</span>.corsConfigurationSource != <span class="keyword">null</span> ? <span class="keyword">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="keyword">null</span>);</span><br><span class="line">CorsConfiguration handlerConfig = getCorsConfiguration(handler, request);</span><br><span class="line">config = (config != <span class="keyword">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> executionChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法1-getHandlerInternal"><a href="#重点方法1-getHandlerInternal" class="headerlink" title="重点方法1 getHandlerInternal"></a>重点方法1 getHandlerInternal</h3><p>  这里的实现见：AbstractHandlerMethodMapping.getgetHandlerInternal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">getHandlerInternal</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//获取urlPath用于查找HandlerMethod</span></span><br><span class="line">String lookupPath = getUrlPathHelper().getLookupPathForRequest(request);</span><br><span class="line">request.setAttribute(LOOKUP_PATH, lookupPath);</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.acquireReadLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//查找HandlerMethod 优先通过Path找，没找到轮询mappingLookup，之后对找到的HandlerMethod排序找到最合适的HandlerMethod</span></span><br><span class="line">HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);</span><br><span class="line"><span class="comment">//re-create bean 享元模式防止请求修改HandlerMethod</span></span><br><span class="line"><span class="keyword">return</span> (handlerMethod != <span class="keyword">null</span> ? handlerMethod.createWithResolvedBean() : <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.mappingRegistry.releaseReadLock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> HandlerMethod <span class="title">lookupHandlerMethod</span><span class="params">(String lookupPath, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">List&lt;Match&gt; matches = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//通过path查找到符合要求的RequestMappingInfo</span></span><br><span class="line">List&lt;T&gt; directPathMatches = <span class="keyword">this</span>.mappingRegistry.getMappingsByUrl(lookupPath);</span><br><span class="line"><span class="keyword">if</span> (directPathMatches != <span class="keyword">null</span>) &#123;</span><br><span class="line">addMatchingMappings(directPathMatches, matches, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果通过path没找到去mappingLookup轮询一遍查找</span></span><br><span class="line"><span class="keyword">if</span> (matches.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// No choice but to go through all mappings...</span></span><br><span class="line">addMatchingMappings(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), matches, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不为空</span></span><br><span class="line"><span class="keyword">if</span> (!matches.isEmpty()) &#123;</span><br><span class="line"><span class="comment">//根据RequestMappingInfoHandlerMapping.getMappingComparator排序Match.mapping的Compare然后取第一个</span></span><br><span class="line"><span class="comment">// todo 优先级未看</span></span><br><span class="line">Comparator&lt;Match&gt; comparator = <span class="keyword">new</span> MatchComparator(getMappingComparator(request));</span><br><span class="line">matches.sort(comparator);</span><br><span class="line"><span class="comment">//排序后取第一个作为返回结果</span></span><br><span class="line">Match bestMatch = matches.get(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//取出来俩个然后优先级一样直接抛出异常意思是Handler重复"多个优先级"</span></span><br><span class="line"><span class="keyword">if</span> (matches.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(matches.size() + <span class="string">" matching mappings: "</span> + matches);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line"><span class="keyword">return</span> PREFLIGHT_AMBIGUOUS_MATCH;</span><br><span class="line">&#125;</span><br><span class="line">Match secondBestMatch = matches.get(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (comparator.compare(bestMatch, secondBestMatch) == <span class="number">0</span>) &#123;</span><br><span class="line">Method m1 = bestMatch.handlerMethod.getMethod();</span><br><span class="line">Method m2 = secondBestMatch.handlerMethod.getMethod();</span><br><span class="line">String uri = request.getRequestURI();</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line"><span class="string">"Ambiguous handler methods mapped for '"</span> + uri + <span class="string">"': &#123;"</span> + m1 + <span class="string">", "</span> + m2 + <span class="string">"&#125;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);</span><br><span class="line"><span class="comment">//为request设置值：PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE，返回对应的handlerMethod</span></span><br><span class="line"><span class="comment">//这里其实就是把mapping,和handler都返回只不过mapping放在了requst里</span></span><br><span class="line">handleMatch(bestMatch.mapping, lookupPath, request);</span><br><span class="line"><span class="keyword">return</span> bestMatch.handlerMethod;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//都没匹配到调用该方法见RequestMappingInfoHandlerMapping，其中不符合RequestMappingInfo的会抛异常</span></span><br><span class="line"><span class="keyword">return</span> handleNoMatch(<span class="keyword">this</span>.mappingRegistry.getMappings().keySet(), lookupPath, request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法2-getHandlerExecutionChain"><a href="#重点方法2-getHandlerExecutionChain" class="headerlink" title="重点方法2 getHandlerExecutionChain"></a>重点方法2 getHandlerExecutionChain</h3><p>  返回handler和拦截器的封装，注：springboot的WebMvcConfigurer.addInterceptors方法中添加的拦截器会转成MappedInterceptor添加到RRequestMappingHandlerMapping中代码可以从WebMvcAutoConfiguration中看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> HandlerExecutionChain <span class="title">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果是一个存在的HandlerExecutionChain,直接返回，否则new一个HandlerExecutionChain</span></span><br><span class="line"><span class="comment">//new HandlerExecutionChain(handler)在HandlerExecutionChain的构造方法里会再判断下Handler的类型，</span></span><br><span class="line"><span class="comment">// 如果是HandlerExecutionChain进行merge</span></span><br><span class="line"><span class="comment">// 如果是HandlerMethod会进行赋值具体见HandlerExecutionChain构造方法</span></span><br><span class="line">HandlerExecutionChain chain = (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">(HandlerExecutionChain) handler : <span class="keyword">new</span> HandlerExecutionChain(handler));</span><br><span class="line"></span><br><span class="line">String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class="line"><span class="comment">//处理拦截器，</span></span><br><span class="line"><span class="comment">// 如果是MappedInterceptor，判断lookupPath是否匹配如果匹配将拦截器加入到HandlerExecutionChain</span></span><br><span class="line"><span class="comment">// 如果是HandlerInterceptor 或者WebRequestInterceptor直接将拦截器加入到HandlerExecutionChain</span></span><br><span class="line"><span class="comment">// todo 注意：springboot 通过WebMvcConfigurer配置的interceptor最终都会转成MappedInterceptor，</span></span><br><span class="line"><span class="comment">// 见InterceptorRegistration.getInterceptor(),入口在WebMvcAutoConfiguration.requestMappingHandlerMapping()方法</span></span><br><span class="line"><span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="keyword">this</span>.adaptedInterceptors) &#123;</span><br><span class="line"><span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;</span><br><span class="line"><span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="keyword">this</span>.pathMatcher)) &#123;</span><br><span class="line">chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">chain.addInterceptor(interceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回了包含handler和interceptor的HandlerExecutionChain为下一步handlerAdapter执行做好准备</p><h2 id="附录：MappingRegistry几个重要的容器"><a href="#附录：MappingRegistry几个重要的容器" class="headerlink" title="附录：MappingRegistry几个重要的容器"></a>附录：MappingRegistry几个重要的容器</h2><p>上面提到的register过程中涉及到了MappingRegistry类，它包含了几个重要容器用来缓存url,RequestMappingInfo HandlerMethod的对应关系</p><ul><li>urlLookup: url–&gt;List&lt;RequestMappingInfo&gt;</li><li>mappingLookup:RequestMappingInfo–&gt;HandlerMethod</li></ul><h2 id="附录：-RequestMapping注解"><a href="#附录：-RequestMapping注解" class="headerlink" title="附录：@RequestMapping注解"></a>附录：@RequestMapping注解</h2><p>  RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p><ul><li>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</li><li>method：指定请求的method类型， GET、POST、PUT、DELETE等；</li><li>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</li><li>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；</li><li>params：指定request中必须包含某些参数值是，才让该方法处理。</li><li>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何精炼领域模型</title>
      <link href="%E5%A6%82%E4%BD%95%E7%B2%BE%E7%82%BC%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/"/>
      <url>%E5%A6%82%E4%BD%95%E7%B2%BE%E7%82%BC%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>  <a href="./如何保持领域模型的完整性">如何保持领域模型的完整性</a>描述如何通过Bounded Context使自己的领域模型保持完整，但是随着业务的不断发展模型也在不断的完善，模型本身会膨胀到我们难以控制。所以我们要时刻精简我们的模型，如何清晰的明确哪些是我们模型要解决的主要矛盾，即：“Core Domain”</p><h2 id="Core-Domain"><a href="#Core-Domain" class="headerlink" title="Core Domain"></a>Core Domain</h2><p>  核心领域，我们建模中亟待解决的主要矛盾</p><ul><li>它内容应该是精炼的</li><li>它在工作中的优先级应该是最高的最先被解决的</li><li>它应该是趋于稳定的，因为Core Domain经常被变更很有可能是我们对模型理解不够</li></ul><h2 id="Generic-Subdomain"><a href="#Generic-Subdomain" class="headerlink" title="Generic Subdomain"></a>Generic Subdomain</h2><p>  一些和我们当前要解决的核心问题【Core Domain】的通用知识我们应该分离出去至少在设计Core Domain时候它们的优先级不高，属于次要矛盾。比如订单系统中的“用户”，它不属于订单系统的Core Domain，订单系统的Core Domain更应该是订单的状态、流转等信息</p><h2 id="突出Core-Domain的俩种方法"><a href="#突出Core-Domain的俩种方法" class="headerlink" title="突出Core Domain的俩种方法"></a>突出Core Domain的俩种方法</h2><ol><li>Domain Vision Statement-领域远景说明：它很类似我们上学时候总结文章的主要内容，应该简要指出我们当前核心要解决的问题主旨，以及我们模型的核心价值，与此无关的信息都不要提，也就是我们常说的痛点。</li><li>Highted Core：突出核心，Core Domain应该能很容易的被分辨出来，应该被团队所有人非常容易的理解</li></ol><h2 id="Cohesive-Mechanism-内聚机制"><a href="#Cohesive-Mechanism-内聚机制" class="headerlink" title="Cohesive Mechanism 内聚机制"></a>Cohesive Mechanism 内聚机制</h2><p>  如果模型包含了很复杂、专业的算法，集成在模型中可能导致Core Domain的混乱那么我们可以把算法抽象出去并且提供api给Core Domain。很类似Generic Subdomain，它俩的区别可能Cohesive Mechanism只是封装了算法而不是模型。</p><h2 id="Segregated-Core-分离核心"><a href="#Segregated-Core-分离核心" class="headerlink" title="Segregated Core 分离核心"></a>Segregated Core 分离核心</h2><p>  模型中如果有一些起到支撑作用的对象、类和Core Domain掺杂在一起我们应该对其进行重构以保持Core Domain的简介、易理解。这时候我们往往先审核Core Domain将和其无关的代码放在其他的Moudle中，然后分别对Core Domain和那个Moudle进行重构。</p><p>  难点在于，团队对于Core Domain的统一认知，因为Core Domain在重构过程中是不断变化的</p><p>##</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保持领域模型的完整性</title>
      <link href="%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>  随着团队的扩张以及各种业务需求，我们单一的模型往往会逐步的扩大到一个不可维护的状态，如：概念的复用导致业务的耦合，这时候我们为了保证领域模型和Ubiquitous Language在概念上一致可能会涉及到模型的拆分，将一个单一的大模型拆分到多个小模型中，同时团队也随着模型打散、重组。让各人员各司其职，这个过程往往成本很高且漫长为了少走弯路我们可以有以下几个方法和原则去遵循</p><h2 id="Bounded-Context"><a href="#Bounded-Context" class="headerlink" title="Bounded Context"></a>Bounded Context</h2><p>  字面意思限定上下文，就是我们要针对我们的业务划分出不同的边界。每一个边界是一个Bounded Context，一个概念在Bounded Context内部是高度统一的，它只作用于这个Context中。不同的Bounded Context之间应该尽量隔离，如果它们需要通信，那么最好约定好一个协议通过接口方式交互。否则，俩个Bounded Context共用一个模型轻则出现一个有N多同质属性的对象，或者一个属性在俩个Context中定义的不一样的情况。</p><h2 id="Continuous-Integration"><a href="#Continuous-Integration" class="headerlink" title="Continuous Integration"></a>Continuous Integration</h2><p>  字面理解像是持续集成的意思，当我们确定好Bounded Context,为了不断的迭代、精华模型，团队成员要持续的集成完善Bounded Context。【注意Continuous Integration是指团队中的是在一个Bounded Context中进行的】</p><p>  注意，为了实现Continuous Integration我们应该</p><ol><li>分布集成，采用可重现的合并/构建技术</li><li>自动化测试套件；【单元测试可满足】</li><li>小范围的集成试错，并且制定一每一次集成的Milestone</li><li>集成中坚持使用Ubiquitous Language</li></ol><h2 id="Context-Map"><a href="#Context-Map" class="headerlink" title="Context Map"></a>Context Map</h2><p>  当一个大项目出现多个Bounded Context时候我们要规划一个全局的Context Map，并且找到他们的关联，以及关联的交互方式。后面会讲集中Bounded Context的交互方式。</p><h2 id="Shared-Kernel"><a href="#Shared-Kernel" class="headerlink" title="Shared Kernel"></a>Shared Kernel</h2><p>  最理想的方式，假如俩个模型高度重合我们可用共用一部分基础设施或者底层逻辑。避免一部分重复的工作。比如共用一种数据库、共用一套数据层</p><h2 id="Customer-Suppiler-Development-Team"><a href="#Customer-Suppiler-Development-Team" class="headerlink" title="Customer/Suppiler Development Team"></a>Customer/Suppiler Development Team</h2><p>  俩个模型是下游依赖上游的单向依赖关系。下游依赖上游输出，但是上游不需要下游的反馈，如：业务的统计系统，需要上游的日志、数据，上游业务系统却不太需要统计系统的反馈。这时候俩个模型可以采用这种客户/供应商关系</p><ol><li>当下游依赖上游的输出和结果，并且是依赖是单向的</li><li>上游愿意配合下游的工作</li><li>一个boss【个人觉得这个最重要。起码在我司】</li></ol><h2 id="Conformist"><a href="#Conformist" class="headerlink" title="Conformist"></a>Conformist</h2><p>  跟随者模式，加入上游不配合或者整个系统没有人维护了，这时候为了上游的数据能响应下游需求，加入上游模型我们可以复用质量不差，便于使用，我们完全没必要推翻他们，可以选择采用跟随者模式。</p><p>  使用时候严格遵守上游的Bounded Context可以避免俩个模型之间数据格式的转换</p><h2 id="Anticorruption-Layer"><a href="#Anticorruption-Layer" class="headerlink" title="Anticorruption Layer"></a>Anticorruption Layer</h2><p>  防腐层【隔离层】，为俩个Bounded Context提供隔离机制。由于上游、下游的Bounded Context无法完全复用，那么数据就需要进行转化，为了防止俩个Context的概念互相渗透，这种转换我们往往放在防腐层进行。</p><p>  在防腐层我们最长用到的是Adapter和Facade俩种模型，下游的service通过Adpater来兼容调用被上游的服务，Facade在被调用者端隐藏对象数据的组装。防腐层可以部署在下游也可以部署在上游</p><h2 id="Separate-Way"><a href="#Separate-Way" class="headerlink" title="Separate Way"></a>Separate Way</h2><p>  如果上游的Bounded Context和下游的Bounded Context区别非常大。em…各行其道吧。完全隔离开。</p><p>  PS:我们审视我们的项目是否有必要把项目集成在一起？他们是否能独立存在？如果能，建议各行其到</p><h2 id="Open-Host-Service"><a href="#Open-Host-Service" class="headerlink" title="Open Host Service"></a>Open Host Service</h2><p>  为了减少模型之间的转换工作我们可以为我们的服务提供Api，我想着就是微服务为什么兴起的原因。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  个人认为根据Context Map的各Bounded Context的紧密程度来划分：Shared Kernel &gt; Customer/Suppiler Development Team &gt; Conformist&gt;Anticorruption Layer &gt; Separate Way</p><p>  我们在思考方案时候可以遵循这个原则</p><p>  另外建议在开发中对于Bounded Context的设计采用减法，程序要保持小规模的持续集成。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive Sql学习记录一</title>
      <link href="Hive%20sql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80/"/>
      <url>Hive%20sql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="内部表和外部表"><a href="#内部表和外部表" class="headerlink" title="内部表和外部表"></a>内部表和外部表</h2><ul><li>内部表【managed table】：默认创建的就是内部表，删除内部表会删除meta信息和数据，适合作为中间表。</li><li>外部表 【external table】：创建时候加上关键字external，删除外部表只会删除meta信息不会删除数据，这样可以利用到历史数据，适合多个表利用同一份数据。【比如一份log，多个部门都想利用这时候建议外部表】。</li><li>临时表：</li><li>分区表：hive的数据本质上是按照一定规范映射成对应的目录存储在hadoop的hdfs上的，一张表对饮一个文件，我们每一次查询实际是全表扫描，为了减少每次查询我们会采用 <em>分区表</em> 的方式存储数据，这样查询时候值需要扫描制定分区的文件即可【对应mysql的数据分表或者分区】，分区表在创建时候需要制定一个字段作为分区字段，insert时候必须带上这个字段。</li></ul><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><ul><li>建外部表使用LOCATION，读取到数据，同时插入数据，会在LOCATION位置新生成文件000000_0，删除外部表，数据文件还在，证明外部表功能还在。</li><li>建立外部表，不使用LOCATION，会在默认在/hive/warehouse/数据库名称/表名，建立目录。然后插入数据，会生成新文件，删除表。目录和文件都还在。符合外部表功能。</li><li>建内部表使用LOCATION，读取到数据，同时插入数据也会生成新文件，但删除内部表，数据文件都会消失，整个目录都会删除掉，也正好符合内部表的功能。</li><li>建立内部表，不使用LOCATION。在相应位置创建新目录，插入数据，一样生成新文件。但是如果删除内部表，目录和数据文件都会删除掉。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据，中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go-sarama的遇到的几个坑</title>
      <link href="Go-sarama%E7%9A%84%E7%9A%84Notifications%E5%AF%BC%E8%87%B4%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
      <url>Go-sarama%E7%9A%84%E7%9A%84Notifications%E5%AF%BC%E8%87%B4%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8D%E6%B6%88%E8%B4%B9%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>sarama是golang对kafka操作的封装，在使用过程中主要遇到如下的问题,总结如下：</p><h2 id="kafka的error的处理"><a href="#kafka的error的处理" class="headerlink" title="kafka的error的处理"></a>kafka的error的处理</h2><p>  kakfa的error处理是通过一个 <strong>chan &lt;-error</strong> 如果不处理error当发生error的时候会造成协程阻塞，导致协程夯住</p><p>  这里建议放在另一个协程处理，防止处理error影响了message的处理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> err := <span class="keyword">range</span> c.consumer.Errors() &#123;</span><br><span class="line">log.Trace.Errorf(context.TODO(), <span class="string">"_kafka_error"</span>, <span class="string">"errorError:%v"</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="sarma-cluster的作用"><a href="#sarma-cluster的作用" class="headerlink" title="sarma-cluster的作用"></a>sarma-cluster的作用</h2><p>  这个包最大的用处是autocommit offset</p><h2 id="封装按照timestamp和condition消费制定offset的数据"><a href="#封装按照timestamp和condition消费制定offset的数据" class="headerlink" title="封装按照timestamp和condition消费制定offset的数据"></a>封装按照timestamp和condition消费制定offset的数据</h2><p>首先，根据key找到partiton，根据timestamp找到offset，然后过滤condition。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PartitionClientConnector 封装kafka的client</span></span><br><span class="line"><span class="comment">// checkTimoutMills，z在拉取消息时候会启动一个ticker检测拉取是否过期，checkTimoutMills用来控制检测器的频率</span></span><br><span class="line"><span class="comment">// timeOutMills，判断上一次拉取消息和当前时间的间隔超过这个值且consumer处于空闲状态会停止拉取消息</span></span><br><span class="line"><span class="keyword">type</span> PartitionClientConnector <span class="keyword">struct</span> &#123;</span><br><span class="line">client           sarama.Client</span><br><span class="line">checkTimoutMills <span class="keyword">int64</span></span><br><span class="line">timeOutMills     <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewPartitionConsumer 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPartitionConsumer</span><span class="params">(brokers []<span class="keyword">string</span>, clientID <span class="keyword">string</span>)</span> <span class="params">(*PartitionClientConnector, error)</span></span> &#123;</span><br><span class="line">client, err := sarama.NewClient(brokers, newSaramaConfig(clientID, sarama.OffsetOldest))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;PartitionClientConnector&#123;</span><br><span class="line">client:           client,</span><br><span class="line">checkTimoutMills: <span class="number">1000</span>,</span><br><span class="line">timeOutMills:     <span class="number">5000</span>,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSaramaConfig</span><span class="params">(clientID <span class="keyword">string</span>, initialOffset <span class="keyword">int64</span>)</span> *<span class="title">sarama</span>.<span class="title">Config</span></span> &#123;</span><br><span class="line">config := sarama.NewConfig()</span><br><span class="line">config.Version = sarama.V0_10_2_0</span><br><span class="line">config.Consumer.Offsets.CommitInterval = time.Second</span><br><span class="line">config.Consumer.Offsets.Initial = initialOffset</span><br><span class="line">config.Consumer.Return.Errors = <span class="literal">true</span></span><br><span class="line">config.ClientID = clientID</span><br><span class="line"></span><br><span class="line"><span class="comment">//sasl</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(conf.ServiceConfig.KafkaConf.SaslUser) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(conf.ServiceConfig.KafkaConf.SaslPassword) &gt; <span class="number">0</span> &#123;</span><br><span class="line">config.Net.SASL.User = conf.ServiceConfig.KafkaConf.SaslUser</span><br><span class="line">config.Net.SASL.Password = conf.ServiceConfig.KafkaConf.SaslPassword</span><br><span class="line">config.Net.SASL.Handshake = <span class="literal">true</span></span><br><span class="line">config.Net.SASL.Enable = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPartition 通过key来取partition的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PartitionClientConnector)</span> <span class="title">GetPartition</span><span class="params">(topic <span class="keyword">string</span>, key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int32</span>, error)</span></span> &#123;</span><br><span class="line">partition, err := pc.client.Partitions(topic)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getPartition(key, <span class="built_in">len</span>(partition)), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetStartOffsetByTime 获取开始的Offset</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PartitionClientConnector)</span> <span class="title">GetStartOffsetByTime</span><span class="params">(topic <span class="keyword">string</span>, partitionID <span class="keyword">int32</span>, time <span class="keyword">int64</span>)</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> pc.client.GetOffset(topic, partitionID, time)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PartitionClientConnector)</span> <span class="title">createPartitionConsumer</span><span class="params">(topic <span class="keyword">string</span>, partitionID <span class="keyword">int32</span>, beginOffset <span class="keyword">int64</span>)</span> <span class="params">(sarama.PartitionConsumer, error)</span></span> &#123;</span><br><span class="line">consumer, err := sarama.NewConsumerFromClient(pc.client)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> consumer.ConsumePartition(topic, partitionID, beginOffset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PullPartitionMessageByCondition  根据key通过javaHash找到指定的partition，根据Condition拉取消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PartitionClientConnector)</span> <span class="title">PullPartitionMessageByCondition</span><span class="params">(topic <span class="keyword">string</span>, key <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">startTime <span class="keyword">int64</span>, endTime <span class="keyword">int64</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">filter ConsumerMsgFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">consumerHandler PullMsgHandler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">partitionID, err := pc.GetPartition(topic, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">startOffset, err := pc.GetStartOffsetByTime(topic, partitionID, startTime)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">consumer, err := pc.createPartitionConsumer(topic, partitionID, startOffset)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> consumer.Close()</span><br><span class="line"></span><br><span class="line">endOffset, err := pc.GetStartOffsetByTime(topic, partitionID, endTime)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">startOffset, endTime, endOffset)</span><br><span class="line"><span class="keyword">var</span> msgOut <span class="keyword">int64</span></span><br><span class="line"><span class="comment">//check timeoout</span></span><br><span class="line">ticker := time.NewTicker(time.Duration(pc.checkTimoutMills) * time.Millisecond)</span><br><span class="line"></span><br><span class="line">lastRecvNano := time.Now().UnixNano()</span><br><span class="line">isIdle := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-consumer.Messages():</span><br><span class="line">msgOut = msg.Offset</span><br><span class="line">isIdle = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> endOffset &gt; startOffset &amp;&amp; msg.Offset &gt; endOffset &#123;</span><br><span class="line">isIdle = <span class="literal">true</span></span><br><span class="line"><span class="keyword">goto</span> stopLoop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msg.Offset &lt; startOffset &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> filter != <span class="literal">nil</span> &amp;&amp; !filter.Conditional(msg) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">consumerHandler.processMsg(msg)</span><br><span class="line">lastRecvNano = time.Now().UnixNano()</span><br><span class="line">isIdle = <span class="literal">true</span></span><br><span class="line"><span class="keyword">case</span> err := &lt;-consumer.Errors():</span><br><span class="line"><span class="keyword">goto</span> stopLoop</span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C: <span class="comment">//检查过期停止阻塞 当现在的事件-上一次拉取的时间&gt;设置的timeOutMills，并且是空闲状态</span></span><br><span class="line"><span class="keyword">if</span> (time.Now().UnixNano()-lastRecvNano)/<span class="keyword">int64</span>(time.Millisecond) &gt;= pc.timeOutMills &amp;&amp;</span><br><span class="line">isIdle &#123;</span><br><span class="line">log.Trace.Infof(context.TODO(), trace.DLTagHTTPFailed, <span class="string">"time out.spent"</span>)</span><br><span class="line"><span class="keyword">goto</span> stopLoop</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stopLoop:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭清理资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *PartitionClientConnector)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">pc.client.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getPartition</span><span class="params">(key <span class="keyword">string</span>, partition <span class="keyword">int</span>)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int32</span>(math.Abs(<span class="keyword">float64</span>(stringutil.JavaHashCode(key) % <span class="keyword">int64</span>(partition))))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计-柔性设计</title>
      <link href="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E6%9F%94%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
      <url>%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E6%9F%94%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>软件的最终目的是为客户服务，但是首先要服务于研发人员，一个设计的好的模型一定是是健壮，且易于扩展的。我们称这种设计为柔性设计.</p><blockquote><p>首先、程序员看到接口就应该明白接口是做什么用的，没有任何的副作用。其次、设计涉及的模型要健壮，利于扩展增加功能，而不能每次修改就面临推倒重来</p></blockquote><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li>INTENTION-REVEALING INTERFACES：接口、Entity、方法命名清晰无歧义，且符合整个模型的通用术语。避免调用者去深究实现含义。</li><li>SIDE-EFFECT-FREE FUNCTION：引起Entity状态改变的（需改操作）逻辑抽象出来放到ValueObject中去【service】中。否则调用方法后开发人员无法预知这个Entity的状态变化。</li><li>ASSERTION：要通过断言告知调用者所有的关键分支，如果java等不支持断言需要提供完备的unit test。</li><li>CONCEPTUALCONTOUR：确定模型的底层轮廓，尽量避免底层轮廓的修改（如果底层轮廓经常修改，说明模型不够健壮）</li><li>STANDALONE CLASS：减少Entity之间的耦合。【剔除无关的属性和功能】</li><li>CLOSER FOR OPERTATION：闭合操作，加强整个系统的内聚。【一个模型只做自己相关的事情】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领域驱动设计-初探(一)</title>
      <link href="%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%88%9D%E6%8E%A2-%E4%B8%80/"/>
      <url>%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%88%9D%E6%8E%A2-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>DDD是什么？为了解决什么问题？</li><li>什么叫领域转件相当于我们什么角色？</li></ul><h2 id="DDD"><a href="#DDD" class="headerlink" title="DDD"></a>DDD</h2><p>  DDD是领域驱动设计(Domain-Driven-Design)，了解它首先我们要了解什么是领域模型呢。</p><p>  我们在现实中遇到了一个问题，需要RD开发一个系统来解决它，这时候就需要将这个问题映射成一个抽象的模型，这个模型作为代码和现实的纽带被叫做领域模型。</p><p>  我们的领域专家和研发工程师对领域模型不断的探讨，精简，逐渐的使其越来越抽象通用，逐步的使我们的系统更完善，功能更强大。</p><p>  上述突出以下几点：</p><ol><li>领域模型是现实和程序的纽带，他反应了一个具体的显示问题。</li><li>它需要被领域专家和研发讨论，所以应该有统一的双方都能理解的术语。</li><li>它不是一成不变的，在做加法的同时也需要在讨论中逐渐做减法。</li><li>它不单单是一个简单的数据集合，他还描述了领域模型间不同的关系。</li><li>它需要不断的演进。</li></ol><h2 id="统一术语"><a href="#统一术语" class="headerlink" title="统一术语"></a>统一术语</h2><p>  在领域模型中我们需要统一术语我们称他们为通用语言，他能减少领域专家和我们的研发的沟通成本，避免翻译带来的语义混淆。</p><p>  两者是通过术语来沟通的：领域专家的模型—-&gt;术语&lt;––研发的系统。</p><p>  对术语的要求：</p><ol><li>对于通用语言来说：模型和代码必须统一，比如模型定义了Goods,那么代码中要有相应的类Goods</li><li>通用语言需要讨论：我们在技术讨论中应该尽量用简短的通用语言来描述</li><li>要有不断完善的文档简短的文档来维护我们的通用语：<ol><li>我们可以通过简短类图+类图备注进行描述，并且文档应该作为代码和模型的叩痛补充；</li><li>在模型演进中通过通用语言的完善来更迭文档；</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 领域驱动设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JPA+Mongodb的Example查询不出数据的问题</title>
      <link href="JPA-Mongodb%E7%9A%84Example%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>JPA-Mongodb%E7%9A%84Example%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>一次查询中发现一个诡异的问题，用jpa写入到mongodb的数据无法查询出来。</p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>  查询采用了SpringCloudData的JPA+Mongodb的Example动态拼接查询条件，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> PageDTO&lt;EmployeeInfoDTO&gt; <span class="title">findByCondition</span><span class="params">(String name, String number, Integer pageNumber, Integer pageSize)</span> </span>&#123;</span><br><span class="line">EmployeeInfoDO query=<span class="keyword">new</span> EmployeeInfoDO();</span><br><span class="line"><span class="comment">//......动态设置query权限</span></span><br><span class="line">      Pageable pageable = PageRequest.of(pageNumber, pageSize, Sort.Direction.DESC, <span class="string">"gmtCreate"</span>);</span><br><span class="line">      Page&lt;EmployeeInfoDO&gt; ret = employeeInfoRepo.findAll(Example.of(query, ExampleMatcher.matchingAll()), pageable);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> pageDTO;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p> 但是这里有个坑，即：jpa的mongodb为了方便将document还原成java对象，会在写入的时候设置一个字段”_class”，而Example在查询时候回将<strong>EmployeeInfoDO 的classname</strong>作为查询条件，而我们写入DB的时候在注入MappingMongoConverter已经忽略调了_class字段，所以当然就查不到数据了。</p><p>  MappingMongoConverter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappingMongoConverter <span class="title">mappingMongoConverter</span><span class="params">(MongoDbFactory factory, MongoMappingContext context, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    DbRefResolver dbRefResolver = <span class="keyword">new</span> DefaultDbRefResolver(factory);</span><br><span class="line"></span><br><span class="line">    MappingMongoConverter mappingConverter = <span class="keyword">new</span> MappingMongoConverter(dbRefResolver, context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mappingConverter.setCustomConversions(beanFactory.getBean(CustomConversions.class));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't save _class to mongo</span></span><br><span class="line">    mappingConverter.setTypeMapper(<span class="keyword">new</span> DefaultMongoTypeMapper(<span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mappingConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>设置有效的ExampleMatcher忽略”_class”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ExampleMatcher EXAMPLE_MATCHER_IGNORE_CLASS = ExampleMatcher.matchingAll().withIgnorePaths(<span class="string">"_class"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mongodb </tag>
            
            <tag> jpa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-painc和recover技巧</title>
      <link href="Go%E8%AF%AD%E8%A8%80-painc%E5%92%8Crecover%E6%8A%80%E5%B7%A7/"/>
      <url>Go%E8%AF%AD%E8%A8%80-painc%E5%92%8Crecover%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>Java程序为了防止意外退出，在处理异常时候有try-catch，golang我们则会想到recover函数来处理painc。</p><h2 id="recover的使用"><a href="#recover的使用" class="headerlink" title="recover的使用"></a>recover的使用</h2><p>recover()是go的内置函数，只能放在defer中，recover的返回值是painc中的对象。常见的用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"捕获到的错误：%s\n"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">painc(<span class="string">"退出"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>recover一定要在defer中，且不能直接调用 比如 <strong>defer recover</strong> 。</li><li>如果循环体中出现了painc，因为recover在defer中，则循环会被break，并且recover会在跳出循环后执行。见下面代码</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们希望的是遇到偶数painc之后recover捕获error，还能继续执行但是循环已经被跳出了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Printf(<span class="string">"捕获到的错误：%s\n"</span>, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"偶数退出：%v"</span>,i))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Recovery</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        process(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(i <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">"捕获到的错误：%s\n"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"偶数退出：%v"</span>,i))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-技巧set类实现</title>
      <link href="Go%E8%AF%AD%E8%A8%80-%E6%8A%80%E5%B7%A7set%E7%B1%BB%E5%AE%9E%E7%8E%B0/"/>
      <url>Go%E8%AF%AD%E8%A8%80-%E6%8A%80%E5%B7%A7set%E7%B1%BB%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>利用slice和map实现了个非线程安全的LinkedSet，map的value是元素的index。也支持排序。代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"encoding/json"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set LinkedHashSet 支持数组排序</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>         <span class="comment">//元素和索引映射</span></span><br><span class="line">list    []<span class="keyword">interface</span>&#123;&#125;               <span class="comment">//元素数组</span></span><br><span class="line">compare <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span> //排序函数</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">NewSet</span> 构造方法</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewSet</span><span class="params">()</span> *<span class="title">Set</span></span> &#123;</span><br><span class="line">s := <span class="built_in">new</span>(Set)</span><br><span class="line">s.initEle()</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initEle 初始化数组元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">initEle</span><span class="params">()</span></span> &#123;</span><br><span class="line">set.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line">set.list = <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortAble 设置排序依据</span></span><br><span class="line"><span class="comment">// compare--用于排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">SortAble</span><span class="params">(compare <span class="keyword">func</span>(i, j <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) *<span class="title">Set</span></span> &#123;</span><br><span class="line">set.compare = compare</span><br><span class="line"><span class="keyword">return</span> set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Add</span><span class="params">(keys ...<span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Set</span></span> &#123;</span><br><span class="line"><span class="comment">//set.Lock()</span></span><br><span class="line"><span class="comment">//defer set.Unlock()</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := set.m[key]; !ok &#123;</span><br><span class="line">set.list = <span class="built_in">append</span>(set.list, key)</span><br><span class="line">set.m[key] = <span class="built_in">len</span>(set.list) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Delete</span><span class="params">(keys ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">//set.Lock()</span></span><br><span class="line"><span class="comment">//defer set.Unlock()</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line"><span class="keyword">if</span> v, ok := set.m[key]; !ok &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(set.list)<span class="number">-1</span> &lt; v &#123;</span><br><span class="line">set.list = <span class="built_in">append</span>(set.list[<span class="number">0</span>:v], set.list[v+<span class="number">1</span>:]...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">delete</span>(set.m, key)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Get</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">if</span> v, ok := set.m[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> set.list[v]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Contains</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line">_, ok := set.m[key]</span><br><span class="line"><span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IndexOf 获取元素下标</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">IndexOf</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">if</span> i, ok := set.m[key]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Any 多个元素有人一个true 则为true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Any</span><span class="params">(cond <span class="keyword">func</span>(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span>) <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> set.list &#123;</span><br><span class="line"><span class="keyword">if</span> cond(key) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Diff 查看俩个set不同的元素，返回新的set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Diff</span><span class="params">(dest *Set)</span> *<span class="title">Set</span></span> &#123;</span><br><span class="line">result := NewSet()</span><br><span class="line">set.Foreach(<span class="function"><span class="keyword">func</span><span class="params">(ele <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dest == <span class="literal">nil</span> || dest.Size() == <span class="number">0</span> || !dest.Contains(ele) &#123;</span><br><span class="line">result.Add(ele)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dest != <span class="literal">nil</span> &amp;&amp; dest.Size() &gt; <span class="number">0</span> &#123;</span><br><span class="line">dest.Foreach(<span class="function"><span class="keyword">func</span><span class="params">(ele <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !set.Contains(ele) &#123;</span><br><span class="line">result.Add(ele)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Difference 取s和dest差集，返回新的set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Difference</span><span class="params">(dest *Set)</span> *<span class="title">Set</span></span> &#123;</span><br><span class="line">result := NewSet()</span><br><span class="line">set.Foreach(<span class="function"><span class="keyword">func</span><span class="params">(ele <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dest == <span class="literal">nil</span> || dest.Size() == <span class="number">0</span> || !dest.Contains(ele) &#123;</span><br><span class="line">result.Add(ele)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union 取交集，返回新的set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Union</span><span class="params">(dest *Set)</span> *<span class="title">Set</span></span> &#123;</span><br><span class="line">result := NewSet()</span><br><span class="line">set.Foreach(<span class="function"><span class="keyword">func</span><span class="params">(ele <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> dest != <span class="literal">nil</span> &amp;&amp; dest.Size() &gt; <span class="number">0</span> &amp;&amp; dest.Contains(ele) &#123;</span><br><span class="line">result.Add(ele)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size  返回set的size</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(set.list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Elements 返回element列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Elements</span><span class="params">()</span> []<span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">return</span> set.list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetIterateFunc 遍历的handler</span></span><br><span class="line"><span class="keyword">type</span> SetIterateFunc <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Foreach</span> 遍历</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(set *Set)</span> <span class="title">Foreach</span><span class="params">(foreach SetIterateFunc)</span></span> &#123;</span><br><span class="line"><span class="comment">//set.RLock()</span></span><br><span class="line"><span class="comment">//defer set.RUnlock()</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(set.list) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> set.list &#123;</span><br><span class="line">foreach(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort 排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Sort</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//set.Lock()</span></span><br><span class="line"><span class="comment">//defer set.Unlock()</span></span><br><span class="line">sort.Sort(set)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">set.list[i], set.list[j] = set.list[j], set.list[i]</span><br><span class="line">set.m[set.list[i]] = i</span><br><span class="line">set.m[set.list[j]] = j</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(set.list) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> set.compare == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set.compare(set.list[i], set.list[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetIsEmpty 判断set是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetIsEmpty</span><span class="params">(set *Set)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> set == <span class="literal">nil</span> || set.Size() == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MarshalJSON 实现json.Marshaler接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">MarshalJSON</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> json.Marshal(set.list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnmarshalJSON 实现json.Unmarshaler接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set *Set)</span> <span class="title">UnmarshalJSON</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">set.initEle()</span><br><span class="line"><span class="keyword">var</span> ele []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">err := json.Unmarshal(b, &amp;ele)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">set.Add(ele...)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(set Set)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, set.list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序方法的使用方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s:=set.NewSet().Add(....).AddOrderBy(OrderByHandlerFunc(i,j <span class="keyword">interface</span>&#123;&#125;)<span class="keyword">bool</span>&#123;</span><br><span class="line"><span class="comment">//排序逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">sort(s)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-技巧之接口函数</title>
      <link href="Go%E8%AF%AD%E8%A8%80-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>Go%E8%AF%AD%E8%A8%80-%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>定义：接口函数顾名思义，他本身是一个函数，但是实现了一个接口，在这个接口中自己调用自己。<br>使用场景：适用于接口里只有一个函数的场景<br>作用：面向接口编程有时候我们为了适配不通的场景，往往需要实现多个接口，这样就会凭空出现很多接口的实现者。如果我们用接口函数就可以很好的规避这一点。<br>命名规范：在接口名称后面加上Func,比如接口是KeyHandler，接口函数就是KeyHandlerFunc</p><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><p>  我最早接触的接口函数就是http.handlerFunc,它实现了接口Handler，见下面代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The HandlerFunc type is an adapter to allow the use of</span></span><br><span class="line"><span class="comment">// ordinary functions as HTTP handlers. If f is a function</span></span><br><span class="line"><span class="comment">// with the appropriate signature, HandlerFunc(f) is a</span></span><br><span class="line"><span class="comment">// Handler that calls f.</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们更多的将它作为接口的拦截器用。这时候会有俩种用法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//第一种. 采用了接口函数，我们只需要实现一个func(w http.ResponseWriter, r *http.Request)，并且强转成http.HandlerFunc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthInterceptor</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="comment">//...before</span></span><br><span class="line">        next.ServeHTTP(w, r)<span class="comment">//业务逻辑</span></span><br><span class="line">        <span class="comment">//...after</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种. 不采用接口函数，这时候你要显示的定义AuthLogic实现http.Handler接口，我们程序中会多出来很多AuthLogic这种结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthInterceptor</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> AuthLogic&#123;next:next&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AuthLogic <span class="keyword">struct</span> &#123;</span><br><span class="line">    next http.Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AuthLogic)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">//...before</span></span><br><span class="line">    a.next.ServeHTTP(w, r)</span><br><span class="line">    <span class="comment">//...after</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  所以函数接口让我们的接口调用更加的简便灵活。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
          <category> 编程技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm启动参数NewRatio不生效</title>
      <link href="jvm%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0NewRatio%E4%B8%8D%E7%94%9F%E6%95%88/"/>
      <url>jvm%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0NewRatio%E4%B8%8D%E7%94%9F%E6%95%88/</url>
      
        <content type="html"><![CDATA[<p>  现象：jvm启动参数的配置，由于-Xmn的值优先级更高，所以NewRatio会被-Xmn覆盖。见下面的测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里NewSize是20MB</span></span><br><span class="line">java -Xmn20M -XX:NewRatio=2 -Xms50M -XX:+PrintFlagsFinal -version | grep -E <span class="string">'(Old|New)Size'</span></span><br><span class="line">    uintx MaxNewSize                               := 20971520                            &#123;product&#125;</span><br><span class="line">    uintx NewSize                                  := 20971520                            &#123;product&#125;</span><br><span class="line">    uintx NewSizeThreadIncrease                     = 5320                                &#123;pd product&#125;</span><br><span class="line">    uintx OldSize                                  := 31457280                            &#123;product&#125;</span><br><span class="line">openjdk version <span class="string">"1.8.0_222"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_222-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode)                       &#123;product&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里是50MB的1/3，可见NewRatio生效了</span></span><br><span class="line">java -XX:NewRatio=2 -Xms50M -XX:+PrintFlagsFinal -version | grep -E <span class="string">'(Old|New)Size'</span></span><br><span class="line">    uintx MaxNewSize                               := 1073741824                          &#123;product&#125;</span><br><span class="line">    uintx NewSize                                  := 17301504                            &#123;product&#125;</span><br><span class="line">    uintx NewSizeThreadIncrease                     = 5320                                &#123;pd product&#125;</span><br><span class="line">    uintx OldSize                                  := 35127296                            &#123;product&#125;</span><br><span class="line">openjdk version <span class="string">"1.8.0_222"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_222-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.222-b10, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm，优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享服务中心的建设之路</title>
      <link href="%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E4%B9%8B%E8%B7%AF/"/>
      <url>%E5%85%B1%E4%BA%AB%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83%E7%9A%84%E5%BB%BA%E8%AE%BE%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-amp-amp-When-为什么什么时候要建立共享服务中心"><a href="#Why-amp-amp-When-为什么什么时候要建立共享服务中心" class="headerlink" title="Why &amp;&amp; When 为什么什么时候要建立共享服务中心"></a>Why &amp;&amp; When 为什么什么时候要建立共享服务中心</h2><p>业务发展到一定阶段，之前的服务都散落在各自的业务领域，那么对于使用者来说这种野蛮发展带来了如下的问题：</p><ol><li>服务数量多业务范围涵盖越来越广，如何快速的找到服务成为了要解决的问题</li><li>应用和架构越分越细，服务越来越专业化，学习成本变高</li><li>服务缺乏缺乏统一的管控，往往会出现不知道这些服务又哪些下游，是如何调用，自己随意发布版本导致服务不稳定；<ol><li>防止恶意调用</li><li>防止认为的错误调用</li><li>管理服务的依赖关系，提供统一的SLA协议规范</li></ol></li><li>缺少治理层：之前服务的标准，接入方式，鉴权方式散落在各个角落（wiki、文档、开发人员的大脑），需要一个平台对服务进行收敛，减少接入成本；</li></ol><h2 id="What-共享服务中心（SPAS-是做什么用的职责是什么"><a href="#What-共享服务中心（SPAS-是做什么用的职责是什么" class="headerlink" title="What 共享服务中心（SPAS)是做什么用的职责是什么"></a>What 共享服务中心（SPAS)是做什么用的职责是什么</h2><p>它的主要职责是将一个个的服务封装成服务组件为服务消费者提供服务的平台，为服务提供者提供统一的服务治理，为服务的消费者降低接入成本，提供更稳定的服务</p><p>建设思路：</p><ol><li>找到服务化的对象</li><li>提供服务化基础设施</li><li>服务下沉为共享服务中心的组件（实施 由服务提供者接入）</li><li>增强服务和基础设施实现服务治理（提供服务鉴权、运营报表、运维工具等）</li></ol><p>阿里巴巴的实现思路</p><ol><li>服务化对象是API：面向API，将API封装成服务（通用）</li><li>提供服务化基础设施【有借鉴意义】<ol><li>服务描述的元信息</li><li>服务注册发现机制（该服务有一个统一的服务发现平台，比如mq的订阅管控关系， hsf的注册中心等）</li><li>服务的访问控制和安全策略</li><li>应用服务的Protal</li><li>服务的依赖管理和运维管理</li><li>服务的SLA协议</li><li>消费者管理工具与支持工具</li><li>服务化辅助工具支持</li><li>服务化的报表与分析工具</li></ol></li><li>服务化实施阶段：<ol><li>API as Service</li><li>Product as Service</li><li>Solution as Service</li></ol></li></ol><h3 id="How-如何协作"><a href="#How-如何协作" class="headerlink" title="How 如何协作"></a>How 如何协作</h3><ul><li>共享服务中心：提供服务的治理能力以及相关基础设施，指导服务的接入</li><li>服务提供者：服务将服务接入到共享中心，管理服务，提供场景化解决方案</li><li>服务消费者：接入服务，按照规范使用服务，并且给于服务反馈</li></ul><p>共享服务中心和前端（前端事业部）</p><ol><li>和前端核心业务简历紧密沟通机制，积极参加这些部门的技术需求会议，及时响应</li><li>分歧上升机制：遇到分歧，采取层层上升机制</li><li>轮岗制度：保证换位思考</li><li>共享服务中心的发展方式，当发现一些服务存在于不同的前端，可以尝试集成、沉淀到共享服务中心<ol><li>共享服务中心的架构师或者RD有独自沉淀能力，和业务方沟通自己实施；</li><li>共享服务中心的架构师暂时没有能力，采用共建的方式，业务方和共享服务中心的人员一起实施保障快速落地，同时也能在参与工程中培养这方面的技术能力。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业的稳定性建设</title>
      <link href="%E4%BC%81%E4%B8%9A%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/"/>
      <url>%E4%BC%81%E4%B8%9A%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%BB%BA%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="限流和降级"><a href="#限流和降级" class="headerlink" title="限流和降级"></a>限流和降级</h2><p>  见<a href="https://liuhao163.github.io/%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%AE%A8%E8%AE%BA/">稳定性看法</a></p><p>  接入层可以在nginx层做，服务层阿里采用的sentinal，相比开源出来的jar包，它是个集成了hsf，集策略配置，下发于一体的限流、降级管控平台。</p><h2 id="流量调度平台"><a href="#流量调度平台" class="headerlink" title="流量调度平台"></a>流量调度平台</h2><p>  有些系统由于发布、网络抖动、故障等原因会导致服务中某个节点出现负载升高，导致高节点响应时间变长，请求排队等情况，进一步可能威胁到上下游的稳定性。</p><p>  相比于上面提到的限流和降级，这种流量调度平台更专注解决服务某一个节点的问题。</p><p>  实现原理</p><blockquote><ol><li>采集系统+业务指标</li><li>通过一定时间维度的指标和故障模型匹配</li><li>后续故障处置：降权（hsf的服务权重）、摘除（踢掉节点）。</li></ol></blockquote><h2 id="开关服务"><a href="#开关服务" class="headerlink" title="开关服务"></a>开关服务</h2><p>  感觉很像spring-cloud全家桶中的config服务的作用，用来下发开关</p><h2 id="容量压测和容量评估"><a href="#容量压测和容量评估" class="headerlink" title="容量压测和容量评估"></a>容量压测和容量评估</h2><ol><li>线上流量引入，测试单机的qps，得到单机服务的性能基线</li><li>根据单机qps来评估集群容量，在双11大促等场景对服务承载能力掌控更精准，节省服务器资源</li></ol><h2 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h2><p>  ！很重要，也是阿里的法宝之一，方法论如下：</p><ol><li>基础数据抽取：对现有的生产数据进行筛选、过滤、抽取</li><li>链路模型构造：构造压测链路的模型</li><li>链路验证：对模型进行验证</li><li>业务改造：业务对于压测的幂等支持，放线上数据污染能</li><li>数据平台：全链路压测的数据极地</li><li>流量平台：操控中心（对压测进行限制，配置），压测引擎（部署在外网cdn中）</li><li>中间件支持：压测标志支持，数据隔离跟踪等。</li><li>影子表：通过设置影子表将压测数据录入到影子表方变后续管理</li><li>安全策略支持：对压测数据的识别，不要误认为攻击，对于压测数据的监控防止恶意模仿</li></ol><h2 id="业务数据一致性"><a href="#业务数据一致性" class="headerlink" title="业务数据一致性"></a>业务数据一致性</h2><p>  阿里内部将BCP(bussiness check platform)，为了不影响业务，是通过时间触发的原理实现。</p><p>  即。感知数据的变化（精卫、mq）之后根据配置的事件类型找到检测模型，进行规则校验，然后结果入库，发现异常发送报警通知。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务管控-分布式服务全链路跟踪和分析系统</title>
      <link href="%E6%9C%8D%E5%8A%A1%E7%AE%A1%E6%8E%A7-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%92%8C%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
      <url>%E6%9C%8D%E5%8A%A1%E7%AE%A1%E6%8E%A7-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%85%A8%E9%93%BE%E8%B7%AF%E8%B7%9F%E8%B8%AA%E5%92%8C%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>系统服务化或者后续的微服务架构，做到了服务隔离，业务解耦，在带来这些便利的同时也回答带来了排查错误不好定位的问题，因为一个请求往往横跨多个服务。还有异步化等等。<br>所以一套好用的满足分布式系统的全链路跟踪分析系统可以说是整个服务化最重要的基础组件。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>俩部分，日志采集，和日志分析</p><h3 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h3><ul><li>采集：业务几乎无感，业务服务只需要向自身所在的服务器写本地log，服务器有一个采集日志的agent，根据采集中心的配置去制定的目录下实时同步log给日志处理中心。</li><li>处理：通过storm spark flink将日志进行清洗，实时的我们可以打到hbase和es中。离线的我们可以存到hadoop中</li><li>日志格式：全局的TraceID（本次调用的全局ID）+RpcID(本次调用中该节点的ID,建议是有顺序的支持嵌套调用比如1，1.1，1.1.1)+时间戳+数据标签（分类）+业务组件+msg</li><li>采集管控：业务高峰可能产生很多log我们对于一段时间内相同的log要进行降频控制防止对业务有影响</li></ul><h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><ul><li>agent开发（java、go）</li><li>数据通道kafka，rocktmq</li><li>日志清洗spark，flink，strom</li><li>数据存储es，hbase，hadoop</li></ul><h2 id="具体应用场景"><a href="#具体应用场景" class="headerlink" title="具体应用场景"></a>具体应用场景</h2><ul><li>监控业务：原始的监控服务器指标已经不满足服务化的需求了，因为有可能服务指标良好，但是服务已经不可用了，我们可以通过这台全链路的跟踪系统通过自己埋点构建有个性的监控系统</li><li>实时全链路排查：加强业务的管控，实时的了解业务调用链路的异常出在哪里，快速排错，进行有针对性的优化</li><li>离线的全链路分析：针对业务架构师，可以分析一段时间内接口调用情况，查看一个接口整体的设计。比如：依赖是否和合理，强依赖是否平均耗时较高，若依赖是否可以异步化等，使我们服务的编排更合理，架构更加贴近业务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步化与缓存原则</title>
      <link href="%E5%BC%82%E6%AD%A5%E5%8C%96%E4%BA%8E%E7%BC%93%E5%AD%98%E5%8E%9F%E5%88%99/"/>
      <url>%E5%BC%82%E6%AD%A5%E5%8C%96%E4%BA%8E%E7%BC%93%E5%AD%98%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="接口异步"><a href="#接口异步" class="headerlink" title="接口异步"></a>接口异步</h2><p>当业务打到一定规模后，接口串行是性能的一大杀手，因为它：</p><ul><li>影响用户体验：一个接口往往会至少调用3~5个甚至更多的服务，对于用户的访问会有极大的延迟。</li><li>降低系统吞吐：比如一个大的事务或者请求往往会长时间占用链接当业务高峰来了后会占用很多链接无法释放，导致请求排队。</li></ul><p>接口的异步化往往是解决这种问题的利器，我们可以使用一些带有顺序消费能力的消息队列来解决这种问题。我们实际开发中往往是将一个大事务通过MQ等手段异步拆成多个小事务来增大并发。</p><h2 id="分布式事务的数据一致性"><a href="#分布式事务的数据一致性" class="headerlink" title="分布式事务的数据一致性"></a>分布式事务的数据一致性</h2><p>  分布式服务必然会带来数据一致性的问题，和事务的CAID相比，基本遵循俩个原则</p><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>C:一致性<br>A:高可用性<br>P:发生故障好，保证分区可用</p><p>分布式事务往往无法完全严格实现CAP，一般是保证P的基础上实现C、A。</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>是CAP的一种延展</p><p>BA：基本可用，对应的是降级<br>S：柔性状态，即允许当前数据存在中间状态，比如mysql同步时候各从库的数据可能不一致<br>E：最终一致性，即一段时间之后数据会达成最终一致</p><h3 id="俩阶段提交"><a href="#俩阶段提交" class="headerlink" title="俩阶段提交"></a>俩阶段提交</h3><p>  原始的分布式事务采用XA俩阶段提交。分为俩个接口：</p><ul><li>XT：客户端–&gt;事务管理器，负责开始事务、提交事务、回滚事务</li><li><p>XA：一般是资源管理器和事务之间交互，比如回滚，提交等。</p><p>在这个协议下整个事务的流程是这样的：</p><ol><li>客户端开启事务;</li><li>客户端操作事务中多个资源管理器（mysql）这时候数据已经持久化</li><li>客户端提交事务<ol><li>第一阶段：prepare，事务管理器去轮询各资源管理器检查状态，返回 READY,NOT_READY,READY_ONLY，</li><li>第二阶段：commit or rollback，根据第一节阶段的结果进行rollbacck（NOT_READY）或者commit（READY）。</li></ol></li></ol></li></ul><h3 id="分布式系统–柔性事务"><a href="#分布式系统–柔性事务" class="headerlink" title="分布式系统–柔性事务"></a>分布式系统–柔性事务</h3><p>  上面的方案在传统项目中是可以的，但是在互联网应用中，这种项目因为锁的存在会极大的降低性能。</p><h4 id="通过日志来进行业务补偿"><a href="#通过日志来进行业务补偿" class="headerlink" title="通过日志来进行业务补偿"></a>通过日志来进行业务补偿</h4><p>  事务日志：记录事务的开始，事务参于者，状态。保存在事物管理器<br>  undo/redolog：用于发生异常后为了实现最终一致性，进行重试( <strong>正想补充 redolog</strong> ) 或者回滚 （ <strong>反向补偿 undolog</strong> ）</p><h4 id="可靠消息传递"><a href="#可靠消息传递" class="headerlink" title="可靠消息传递"></a>可靠消息传递</h4><p>  防止在网路错误时候出现消息丢失情况，我们要实现，<strong>at least once</strong>：即消息可能投递多次</p><p>  主要幂等性：同一条数据执行多次后，结果不能发生改变。实现方案是采用排重表。【如：可能有多条插入数据库的消息，我们应该只能写入一条记录这种是幂等行，解决方案可能会采用一个排重列表，过滤掉重复的消息】</p><h4 id="无锁设计"><a href="#无锁设计" class="headerlink" title="无锁设计"></a>无锁设计</h4><p>  减少锁开销</p><ol><li>表面事务回滚，没有回滚则没有锁</li><li>通过辅助表取代热点数据的修改。如，秒杀系统的库存的预减</li><li>乐观锁</li></ol><h3 id="阿里的实践"><a href="#阿里的实践" class="headerlink" title="阿里的实践"></a>阿里的实践</h3><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>具体叫rocketmq的实践，先发一个half-message给mq此时对消费者即远端事务透明，生产者完成本地事务提交给mq，mq在将事务发给消费者。</p><p>兜底策略：如果mq长期没有half-message的ack,mq会主动问询生产者状态，来确认事务是进一步进行还是丢弃。</p><p>缺点：仅适用于俩个参与者，仅能提供正向补偿。</p><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>为了解决多参与者以及实现反向补偿（rollback），在支付宝场景下实现了TCC(try confirm cancel)</p><ul><li>try:对资源的检验、锁定，实现软隔离</li><li>confirm:事务的真正提交过程，只用try阶段锁定的资源。</li><li>cancel:取消回滚</li></ul><p>tcc只提供了框架，真正的资源回滚还需要业务方自己通过代码进行回滚。</p><h4 id="TXC"><a href="#TXC" class="headerlink" title="TXC"></a>TXC</h4><p>新一大分布式事务处理框架，他是通过在db层上实现了比较薄的代理来实现分布式事物。</p><ul><li>TXC用来开启(register)一个事务，分配一个txid</li><li>之后所有的对db的请求会先通过txc-rm这个代理，他负责解析sql语句如果遇到Insert/delete/update会生成undolog和redolog</li><li>自动回滚：当有回滚需求时候<ul><li>校验当前数据库的值和redolog是否一致，如果一致通过undolog回滚</li><li>如果不一致，说明别的进程和事务已经修改了数据库，这时候回滚可能会导致数据不一致，只能同构redolog进行重试补偿。</li></ul></li></ul><h3 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h3><p>  以大促为例，阿里采用自己开发的Tair作为缓存，我们可以使用redis的方案。</p><p>  以秒杀场景为例，看下缓存的作用：</p><p>  首先要做服务集群的隔离</p><h4 id="小库存的秒杀场景"><a href="#小库存的秒杀场景" class="headerlink" title="小库存的秒杀场景"></a>小库存的秒杀场景</h4><ol><li>商品详情页的缓存降低数据查询压力</li><li>库存校验的的条件判断：在下单前判断库存是否还足够</li><li>下单时候用乐观锁来修改库存</li></ol><h4 id="大库存热点商品的秒杀"><a href="#大库存热点商品的秒杀" class="headerlink" title="大库存热点商品的秒杀"></a>大库存热点商品的秒杀</h4><p>  这种情况不适合用乐观锁的原因是锁所冲突很大，并且会出现后下单的反而抢到了商品情况。</p><p>  我们这时候在下单时候，可以按照如下逻辑，注意括号中的备注</p><blockquote><p>预订单对用户不可见(用于缓存崩溃等情况恢复用的快照)–&gt;发送消息给mq（保证下订单的顺序）–&gt; 缓存中扣减库存（事务交给缓存）–&gt;修改订单状态，完单。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库拆分实现业务线性能力扩展</title>
      <link href="%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E7%BA%BF%E6%80%A7%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%86%E5%88%86%E5%AE%9E%E7%8E%B0%E4%B8%9A%E5%8A%A1%E7%BA%BF%E6%80%A7%E8%83%BD%E5%8A%9B%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>在业务达到一定规模后，由于数据库是中心架构的，一个设计糟糕的数据库将会给业务带来非常严重的灾难，这方面阿里提出了很多宝贵的经验和方法论。</p><h2 id="阿里数据库的分布式方案"><a href="#阿里数据库的分布式方案" class="headerlink" title="阿里数据库的分布式方案"></a>阿里数据库的分布式方案</h2><ol><li>垂直拆分：根据不同的业务以高内聚、低耦合的原则，将数据拆分到不同的数据库中</li><li>读写分离：垂直拆分后有些服务的请求量依然很大，我们首先想到的是读/写分离，因为往往业务场景决定这读远远大于写，这时候进行读写分离可以有效降低写的压力，且从库可以追加多个</li><li>分库分表：读写分离无法解决单表写的性能问题，以及单表数据量大的问题，针对这个问题我们可以采用水平分库/表的方案，根绝业务特点对表、库进行水平拆分，分表可以减小单表数据量，分库可以减少单库连接数的上线，从而满足业务的需求。</li></ol><p>阿里开发了TDDL，作为数据库的拆分方案，特点是：全面支持jdbc，对业务无侵入。</p><ol><li>matrix：根据业务配置分表规则针对sql语句进行解析，选择需要执行的groupDS</li><li>groupDS：负责读写分离，以及根据权重选择atomDS；</li><li>atomDs:持有数据库的原子链接；</li></ol><h2 id="数据库分表的原则"><a href="#数据库分表的原则" class="headerlink" title="数据库分表的原则"></a>数据库分表的原则</h2><ol><li>数据尽量均匀：防止数据倾斜；</li><li>减少事务边界：尽量减少违反分表分库规则的事务，否则需要进行全表扫描，因为需要在内存中进行聚合，就会降低系统性能，且系统的性能指标就降为单库的指标。</li><li>异构索引表来满足跨表查询的场景；</li><li><p>提供其他搜索方案来解决复杂的查询、搜索场景；</p><p>其中异构索引表，大部分小企业可以采用业务来解决，阿里提供了精卫系统在系统层面来解决数据同步需求：</p></li><li><p>原理是消费binlog，通过配置进行过滤，同步；</p></li><li>支持多线程同时同步，为了保证数据在并发情况的一致性，同一条语句根据规则打到同一个线程执行；</li><li>强大的UI工具支持；</li><li><p>数据的安全性：</p><ol><li>采用zookeeper做调度、管控；</li><li>手动主从切换、宕机回复；</li></ol><p>PS：</p><p>数据库分表分数据遇到了”数据均匀”，”减少事务边界”这两种情况冲突的情况，应该优先解决数据均匀的问题，因为减少事务边界可以采用异构索引表的方式解决。</p><p>实际开发中我们采用82原则，针对80%的情况下有20%的场景出现没有分表字段的情况，采用异构索引的方式处理，其他小概率的查询我们可以全表扫描等方案。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享中心建设原则</title>
      <link href="%E5%85%B1%E4%BA%AB%E4%B8%AD%E5%BF%83%E5%BB%BA%E8%AE%BE%E5%8E%9F%E5%88%99/"/>
      <url>%E5%85%B1%E4%BA%AB%E4%B8%AD%E5%BF%83%E5%BB%BA%E8%AE%BE%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>中台不是一成不变的要能跟这业务一起成长，提供多样的接口，作为业务的沉淀</p><h2 id="共享服务考量指标"><a href="#共享服务考量指标" class="headerlink" title="共享服务考量指标"></a>共享服务考量指标</h2><ul><li>设计：遵循面向对象的原则<br>运营：中台要切实能够解决业务问题，业务能够运营</li><li><ul><li>工程：在做拆分时候要考虑投入的成本</li></ul></li></ul><h2 id="建设中台的几个原则"><a href="#建设中台的几个原则" class="headerlink" title="建设中台的几个原则"></a>建设中台的几个原则</h2><ol><li>高内聚，低耦合</li><li>数据完整性</li><li>业务可运营性</li><li>循序渐进</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中台演进之路</title>
      <link href="%E4%B8%AD%E5%8F%B0%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/"/>
      <url>%E4%B8%AD%E5%8F%B0%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>与大部分企业的服务化的演进之路如初一辙</p><h2 id="单体应用阶段"><a href="#单体应用阶段" class="headerlink" title="单体应用阶段"></a>单体应用阶段</h2><p>单体应用，所有的服务跑在一个war包中，这个war包200多MB。之后遇到了如下的问题</p><ol><li>数据库的链接到了瓶颈：因为所有的程序在一个war包中，这个工程的数据库连接池非常大，已经逼近了单机数据库的连接池的上限；</li><li>所有功能耦合在一起：牵一发而懂全身，很可能一个小改动就引起宕机;</li><li>性能问题：没法做业务的隔离，一个接口慢，会拖垮整个项目</li><li>业务膨胀导致没有一个人能了解所有的代码，祖传代码盛行。</li></ol><h2 id="服务化"><a href="#服务化" class="headerlink" title="服务化"></a>服务化</h2><p>飞行中换发动机，采用去中心化的分布式架构逐步用服务替换掉单体应用。</p><h3 id="淘宝的微服务化"><a href="#淘宝的微服务化" class="headerlink" title="淘宝的微服务化"></a>淘宝的微服务化</h3><p>  淘宝采用去中心化的微服务架构。与之相对的是中心化架构，著名的“ESB”架构，这个架构有个致命的问题，ESB作为真个架构的路由，所有的服务都会落在ESB上，那么他就会成为整个系统的瓶颈，维护成本很高，并且会制约业务发展。这些是互联网业务无法容忍的，所以淘宝就采用了HSF这种去中心化的分布式架构，服务直接点对点的直接调用。（它的特点naming服务只做服务发现、订阅和配置更新的推送，在服务之间大量的请求并没有走naming）。</p><p>  这种架构也就是现在的微服务架构，因为它：</p><ol><li>以服务方式提供应用</li><li>以服务的方式而非项目的方式组织架构</li><li>通过服务的只能编排提供业务支撑</li><li><p>智能运维，以及健壮的平台稳定性（降级、限流、熔断）</p><p>当然微服务话我们也要接受如下挑战：</p></li><li><p>服务的管控：服务的配置中心，服务的全链路跟踪等需要支持否则排错，自我运维闭环是无法实现的；</p></li><li>分布式事务的支持：与单体不同，对于数据一致性要求高的场景我们要想办法支持分布式事务的场景;</li><li>只能运维的支持以及平台稳定性挑战;</li><li>组织架构的变化：要根据服务特点组织组织架构的变化;</li></ol><h2 id="演进史"><a href="#演进史" class="headerlink" title="演进史"></a>演进史</h2><p>建立共享服务中心，前期根据业务拆分了4个中心用户中心，商品中心，交易中心，店铺中心。</p><h3 id="用户中心"><a href="#用户中心" class="headerlink" title="用户中心"></a>用户中心</h3><p>改造成本低相较于其他模块功能简单，受益巨大上游调用次数多，所以是很好的🕙。</p>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要构建中台</title>
      <link href="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9E%84%E5%BB%BA%E4%B8%AD%E5%8F%B0/"/>
      <url>%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9E%84%E5%BB%BA%E4%B8%AD%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要有中台"><a href="#为什么要有中台" class="headerlink" title="为什么要有中台"></a>为什么要有中台</h2><p>  由于企业的业务不断发展，出现很多功能重复的系统，导致整个技术部门烟囱临立的情况。</p><p>  <strong>烟囱的危害具体有</strong></p><ul><li>功能重复导致资源浪费，道理不说了。</li><li>打通不同系统的成本很高，不同的系统，数据、业务都是独立的，想打通需要耗费很大的精力，并且之后的修改很有可能牵一发而动全身。</li><li>由于数据、业务分散在不同的系统中，这种无法收敛的状态也不利于公司的技术、业务沉淀，比如：随着业务的发展，A业务原有的系统无法满足，如果没有中台那么A就很有可能在开发一套新的系统，抛弃原有的系统。如果有中台就可以通过中台不断迭代，甚至有可能复用给其他的业务。</li></ul><p><strong>搭建一个合格的中台的条件</strong></p><ul><li>首先，来自于企业和团队的决心，耐心。我们都知道阿里巴巴的中台策略很出名，原因在于整个集团对于共享服务的态度，要求业务部门必须接入共享服务中心，哪怕初期功能在简陋、在粗糙，否则搭建的中台就是另一个又昂贵，又脱离业务的新烟囱。</li><li>其次，中台的开发者要深入到业务当中，对现有的不同部门、团队的业务进行抽象提取共性，以服务重用的目标来建立、思考中台，而不是简单的将服务打通，堆积在一起。</li><li>再次，中台的开发者要有长期迭代的心态，不是上线这个项目或者这个服务就完了。上线这个项目才仅仅是迈出这个中台服务的第一步。后续的迭代成长才是关键。</li></ul><p><strong>搭建中台的具体好处</strong></p><ul><li>便于业务的创新：每个业务都只是从自己业务的角度看待问题，但是如果从中台的角度看待问题，横跨多个业务，在整合的过程中可能碰撞出新的想法。</li><li>快速迭代、业务试错：supercell和阿里巴巴的大中台小前台策略，可以保证在最小的资源投入前提下进行快速的试错。</li><li>数据打通：真正体现大数据的威力，并且懂业务的人才：因为如果还是传统项目制度，研发只会关注现有功能开发和维护，而不会从业务方面思考问题，通过构建中台，研发更加贴近业务会去思考技术如何更好的为业务服务。</li><li>改变组织形式提高效能：从自上而下的流失组织架构，改为以共享服务为中心的小团队协作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读后感 </category>
          
          <category> 企业IT架构转型之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 中台 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-方法论-分析问题的套路总结</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98%E7%9A%84%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="系统资源瓶颈"><a href="#系统资源瓶颈" class="headerlink" title="系统资源瓶颈"></a>系统资源瓶颈</h2><h3 id="CPU-性能分析"><a href="#CPU-性能分析" class="headerlink" title="CPU 性能分析"></a>CPU 性能分析</h3><p><img src="/系统优化-方法论-分析问题的套路总结/cpu.png" alt="avator"></p><h4 id="CPU优化思路"><a href="#CPU优化思路" class="headerlink" title="CPU优化思路"></a>CPU优化思路</h4><p>从这几个方面出发，我相信你已经想到了很多的优化方法。这里，我主要强调一下，最典型的三种优化方法。</p><ol><li>把进程绑定到一个或者多个 CPU 上，充分利用 CPU 缓存的本地性，并减少进程间的相互影响。</li><li>为中断处理程序开启多 CPU 负载均衡，以便在发生大量中断时，可以充分利用多 CPU 的优势分摊负载。</li><li>使用 Cgroups 等方法，为进程设置资源限制，避免个别进程消耗过多的 CPU。同时，为核心应用程序设置更高的优先级，减少低优先级任务的影响。</li></ol><h3 id="内存-性能分析"><a href="#内存-性能分析" class="headerlink" title="内存 性能分析"></a>内存 性能分析</h3><p><img src="/系统优化-方法论-分析问题的套路总结/mem.png" alt="avator"></p><h4 id="内存优化思路"><a href="#内存优化思路" class="headerlink" title="内存优化思路"></a>内存优化思路</h4><ol><li>除非有必要，Swap 应该禁止掉。这样就可以避免 Swap 的额外 I/O ，带来内存访问变慢的问题。</li><li>使用 Cgroups 等方法，为进程设置内存限制。这样就可以避免个别进程消耗过多内存，而影响了其他进程。对于核心应用，还应该降低 oom_score，避免被 OOM 杀死。</li><li>使用大页、内存池等方法，减少内存的动态分配，从而减少缺页异常。</li></ol><h3 id="磁盘IO-性能分析"><a href="#磁盘IO-性能分析" class="headerlink" title="磁盘IO 性能分析"></a>磁盘IO 性能分析</h3><p><img src="/系统优化-方法论-分析问题的套路总结/io.png" alt="avator"></p><h4 id="磁盘IO-优化思路"><a href="#磁盘IO-优化思路" class="headerlink" title="磁盘IO 优化思路"></a>磁盘IO 优化思路</h4><ol><li>也是最简单的方法，通过 SSD 替代 HDD、或者使用 RAID 等方法，提升 I/O 性能。</li><li>针对磁盘和应用程序 I/O 模式的特征，选择最适合的 I/O 调度算法。比如，SSD 和虚拟机中的磁盘，通常用的是 noop 调度算法；而数据库应用，更推荐使用 deadline 算法。</li><li>优化文件系统和磁盘的缓存、缓冲区，比如优化脏页的刷新频率、脏页限额，以及内核回收目录项缓存和索引节点缓存的倾向等等</li></ol><h3 id="网络-性能分析"><a href="#网络-性能分析" class="headerlink" title="网络 性能分析"></a>网络 性能分析</h3><p><img src="/系统优化-方法论-分析问题的套路总结/nat.png" alt="avator"></p><p>而要分析网络的性能，自然也是要从这几个协议层入手，通过使用率、饱和度以及错误数这几类性能指标，观察是否存在性能问题。比如 ：</p><ul><li>在链路层，可以从网络接口的吞吐量、丢包、错误以及软中断和网络功能卸载等角度分析；</li><li>在网络层，可以从路由、分片、叠加网络等角度进行分析；</li><li>在传输层，可以从 TCP、UDP 的协议原理出发，从连接数、吞吐量、延迟、重传等角度进行分析；</li><li>在应用层，可以从应用层协议（如 HTTP 和 DNS）、请求数（QPS）、套接字缓存等角度进行分析。</li></ul><h4 id="网络-优化思路"><a href="#网络-优化思路" class="headerlink" title="网络 优化思路"></a>网络 优化思路</h4><ol><li>你可以增大套接字缓冲区、连接跟踪表、最大半连接数、最大文件描述符数、本地端口范围等内核资源配额；</li><li>也可以减少 TIMEOUT 超时时间、SYN+ACK 重传数、Keepalive 探测时间等异常处理参数；</li><li>还可以开启端口复用、反向地址校验，并调整 MTU 大小等降低内核的负担。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-方法论-如何建立监控体系</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E7%9B%91%E6%8E%A7%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>我们如何建立有效的监控体系？我们可以从俩个维度来看，系统指标，应用指标。</p><h2 id="系统指标"><a href="#系统指标" class="headerlink" title="系统指标"></a>系统指标</h2><p>在开始监控系统之前，你肯定最想知道，怎么才能用简洁的方法，来描述系统资源的使用情况。不过不要忘记，每种资源的性能指标可都有很多，使用过多指标本身耗时耗力不说，也不容易为你建立起系统整体的运行状况。在这里，我为你介绍一种专门用于性能监控的 USE（Utilization Saturation and Errors）法。USE 法把系统资源的性能指标，简化成了三个类别，即使用率、饱和度以及错误数。</p><ul><li>使用率，表示资源用于服务的时间或容量百分比。100% 的使用率，表示容量已经用尽或者全部时间都用于服务。</li><li>饱和度，表示资源的繁忙程度，通常与等待队列的长度相关。100% 的饱和度，表示资源无法接受更多的请求。</li><li>错误数表示发生错误的事件个数。错误数越多，表明系统的问题越严重。</li></ul><p><img src="/系统优化-方法论-如何建立监控体系/use.png" alt="avator"></p><p>工具有:zabix，Prometheus等</p><p><img src="/系统优化-方法论-如何建立监控体系/prometheus.png" alt="avator"></p><h2 id="应用指标"><a href="#应用指标" class="headerlink" title="应用指标"></a>应用指标</h2><p>应用指标可以直观的反应出服务的运行状况，我们更关注，请求数，延迟，错误率等，分布式系统、微服务还需要把握整个请求链路。</p><ul><li>全链路分析：掌握整个请求链路的响应时间、成功率，有zipkin,还有各大公司的trace方案</li><li>指标分析：还需要对重点的业务，逻辑字日志中大点进行监控，解决方案可以采用：elk或者efk。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-方法论-排查系统吞吐下降的问题</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E8%A7%A3%E5%86%B3%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%9E%E5%90%90/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%96%B9%E6%B3%95%E8%AE%BA-%E8%A7%A3%E5%86%B3%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%9E%E5%90%90/</url>
      
        <content type="html"><![CDATA[<p>接文章[/系统优化-案例分析-网络丢包分析]</p><p>当服务的请求数变大时候，我们往往发现系统吞吐下降。排查思路如下：</p><h2 id="优化连接数"><a href="#优化连接数" class="headerlink" title="优化连接数"></a>优化连接数</h2><p>用ss命令发现estab的很少，timewait很多。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss -s</span><br><span class="line">查看</span><br><span class="line">TCP:   53 (estab 9, closed 38, orphaned 0, synrecv 0, timewait 38/0), ports 0</span><br></pre></td></tr></table></figure><p>通过dmsg命令，查看系统的error信息排查是否是conntrack的问题。通过修改参数来解决。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dmsg |tail</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看最大值</span></span><br><span class="line">sysctl net.netfilter.nf_conntrack_max</span><br><span class="line"><span class="comment">#查看当前值</span></span><br><span class="line">sysctl net.netfilter.nf_conntrack_count</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置最大值</span></span><br><span class="line">sysctl -w net.netfilter.nf_conntrack_max</span><br></pre></td></tr></table></figure><h2 id="排查应用问题"><a href="#排查应用问题" class="headerlink" title="排查应用问题"></a>排查应用问题</h2><p>比如nginx和tomcat等我们可以查看应用错误的原因，因为大部分采用master+worker的方案，我们可以增加worker的进程</p><h2 id="排查tcp方面的原因"><a href="#排查tcp方面的原因" class="headerlink" title="排查tcp方面的原因"></a>排查tcp方面的原因</h2><p>用netstat -s|grep tcp 查看丢包原因，如果发现丢包原因是socket overflowed，则用ss -ltnp命令看下Linsterner端口的队列情况,增大backlog相关的参数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -ltnp</span><br></pre></td></tr></table></figure><h2 id="优化端口范围"><a href="#优化端口范围" class="headerlink" title="优化端口范围"></a>优化端口范围</h2><p>如果出现类似这样的错误，我们可以看下是否是端口范围过小导致没法创建新连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(99: Cannot assign requested address)</span><br><span class="line"></span><br><span class="line">sysctl net.ipv4.ip_local_port_range</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 方法论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-案例分析-如何定位软中断问题</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%BD%AF%E4%B8%AD%E6%96%AD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>linux系统有几个进程号比较小的进程</p><ul><li>0号进程：idel进程用来初始化1号进程和2号进程</li><li>1号进程：systemd进程也叫init进程，用来初始化所有的用户进程</li><li>2号进程：kthreadd，在内核态运行，用来管理内核线程</li></ul><p>常见的几个内核线程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ ps -f --ppid 2 -p 2</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          2      0  0 12:02 ?        00:00:01 [kthreadd]</span><br><span class="line">root          9      2  0 12:02 ?        00:00:21 [ksoftirqd/0]</span><br><span class="line">root         10      2  0 12:02 ?        00:11:47 [rcu_sched]</span><br><span class="line">root         11      2  0 12:02 ?        00:00:18 [migration/0]</span><br><span class="line">...</span><br><span class="line">root      11094      2  0 14:20 ?        00:00:00 [kworker/1:0-eve]</span><br><span class="line">root      11647      2  0 14:27 ?        00:00:00 [kworker/0:2-cgr]</span><br></pre></td></tr></table></figure><ul><li>ksoftirqd:软中断线程</li><li>kworker:用于执行内核工作队列，分为绑定 CPU （名称格式为 kworker/CPU86330）和未绑定 CPU（名称格式为 kworker/uPOOL86330）两类</li><li>migration:在负载均衡过程中，把进程迁移到 CPU 上。每个 CPU 都有一个 migration 内核线程。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>场景准备：俩台服务器，服务器一运行docker，服务器二压力机，</p><p>服务器一：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 运行Nginx服务并对外开放80端口</span></span><br><span class="line">$ docker run -itd --name=nginx -p 80:80 nginx</span><br></pre></td></tr></table></figure><p>服务器二发压命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sync_flood攻击</span></span><br><span class="line">$ hping3 -S -p 80 -i u10 192.168.1.2</span><br></pre></td></tr></table></figure><p>这时候服务器变慢，top观察如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ top</span><br><span class="line">top - 08:31:43 up 17 min,  1 user,  load average: 0.00, 0.00, 0.02</span><br><span class="line">Tasks: 128 total,   1 running,  69 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.3 us,  0.3 sy,  0.0 ni, 66.8 id,  0.3 wa,  0.0 hi, 32.4 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 65.2 id,  0.0 wa,  0.0 hi, 34.5 si,  0.0 st</span><br><span class="line">KiB Mem :  8167040 total,  7234236 free,   358976 used,   573828 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7560460 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">    9 root      20   0       0      0      0 S   7.0  0.0   0:00.48 ksoftirqd/0</span><br><span class="line">   18 root      20   0       0      0      0 S   6.9  0.0   0:00.56 ksoftirqd/1</span><br><span class="line"> 2489 root      20   0  876896  38408  21520 S   0.3  0.5   0:01.50 docker-containe</span><br><span class="line"> 3008 root      20   0   44536   3936   3304 R   0.3  0.0   0:00.09 top</span><br><span class="line">    1 root      20   0   78116   9000   6432 S   0.0  0.1   0:11.77 systemd</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>cpu的idel下降，si很高，且进程ksoftirqd占用比较高，初步判断软中断出现了问题，我们之前通过sar和vmstat抓包去看，现在我们可以通过perf家火焰图工具查看，使用方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装 FlameGraph</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/brendangregg/FlameGraph</span><br><span class="line"><span class="built_in">cd</span> FlameGraph</span><br><span class="line"></span><br><span class="line"><span class="comment">#录制</span></span><br><span class="line">perf record -a -g -p 9 -- sleep 30</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成火焰图</span></span><br><span class="line">perf script -i perf.data|./stackcollapse-perf.pl --all|./flamegraph.pl &gt;flame.svg</span><br></pre></td></tr></table></figure><p>生成的火焰图如下：</p><p><img src="/系统优化-案例分析-如何定位软中断问题/flame.svg" alt="avator"></p><h2 id="动态分析"><a href="#动态分析" class="headerlink" title="动态分析"></a>动态分析</h2><p>工具如图</p><p><img src="/系统优化-案例分析-如何定位软中断问题/img1.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 案例分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-案例分析-网络丢包分析</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>见图：</p><p><img src="/系统优化-案例分析-网络丢包分析/img0.png" alt="avator"></p><p>应用层：应用程序错误<br>Socket：读写缓冲区溢出。排查方案，查看socket参数，抓包<br>TCP：资源或者链接跟踪超限。排查方案，netstat -s<br>IP：MTU获取路由错误。排查方案，netstat -i<br>网络链路层：QoSor校验错误。排查方案，tc<br>网卡：网络拥塞，DMA的ringBuffer溢出。排查方案，netstat -i，抓包</p><h2 id="案例排查链路"><a href="#案例排查链路" class="headerlink" title="案例排查链路"></a>案例排查链路</h2><h3 id="看网络包收发状态"><a href="#看网络包收发状态" class="headerlink" title="看网络包收发状态"></a>看网络包收发状态</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       100      106      0     32 0            43      0      0      0 BMRU</span><br><span class="line">lo       65536        0      0      0 0             0      0      0      0 LRU</span><br></pre></td></tr></table></figure><h3 id="查看QoS策略"><a href="#查看QoS策略" class="headerlink" title="查看QoS策略"></a>查看QoS策略</h3><p>如下有一个丢包30%的策略删除之</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/<span class="comment"># tc -s qdisc show dev eth0</span></span><br><span class="line">qdisc netem 8001: root refcnt 2 <span class="built_in">limit</span> 1000 loss 30%</span><br><span class="line"> Sent 2450 bytes 43 pkt (dropped 18, overlimits 0 requeues 0)</span><br><span class="line"> backlog 0b 0p requeues 0</span><br><span class="line"></span><br><span class="line"><span class="comment">##删除策略</span></span><br><span class="line">root@nginx:/<span class="comment"># tc qdisc del dev eth0 root netem loss 30%</span></span><br></pre></td></tr></table></figure><h3 id="看tcp收发情况"><a href="#看tcp收发情况" class="headerlink" title="看tcp收发情况"></a>看tcp收发情况</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@nginx:/<span class="comment"># netstat -s</span></span><br><span class="line">Ip:</span><br><span class="line">    Forwarding: 1          //开启转发</span><br><span class="line">    31 total packets received    //总收包数</span><br><span class="line">    0 forwarded            //转发包数</span><br><span class="line">    0 incoming packets discarded  //接收丢包数</span><br><span class="line">    25 incoming packets delivered  //接收的数据包数</span><br><span class="line">    15 requests sent out      //发出的数据包数</span><br><span class="line">Icmp:</span><br><span class="line">    0 ICMP messages received    //收到的ICMP包数</span><br><span class="line">    0 input ICMP message failed    //收到ICMP失败数</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">    0 ICMP messages sent      //ICMP发送数</span><br><span class="line">    0 ICMP messages failed      //ICMP失败数</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">Tcp:</span><br><span class="line">    0 active connection openings  //主动连接数</span><br><span class="line">    0 passive connection openings  //被动连接数</span><br><span class="line">    11 failed connection attempts  //失败连接尝试数</span><br><span class="line">    0 connection resets received  //接收的连接重置数</span><br><span class="line">    0 connections established    //建立连接数</span><br><span class="line">    25 segments received      //已接收报文数</span><br><span class="line">    21 segments sent out      //已发送报文数</span><br><span class="line">    4 segments retransmitted    //重传报文数</span><br><span class="line">    0 bad segments received      //错误报文数</span><br><span class="line">    0 resets sent          //发出的连接重置数</span><br><span class="line">Udp:</span><br><span class="line">    0 packets received</span><br><span class="line">    ...</span><br><span class="line">TcpExt:</span><br><span class="line">    11 resets received <span class="keyword">for</span> embryonic SYN_RECV sockets  //半连接重置数</span><br><span class="line">    0 packet headers predicted</span><br><span class="line">    TCPTimeouts: 7    //超时数</span><br><span class="line">    TCPSynRetrans: 4  //SYN重传数</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><h3 id="查看iptables"><a href="#查看iptables" class="headerlink" title="查看iptables"></a>查看iptables</h3><p>查看各种链的策略</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iptables -t filter -nvL  ip是数字 verbose list [--line-number-]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除策略</span></span><br><span class="line">iptables -t filter -D [INPUT or OUTPUT 等链名] [line-number]</span><br></pre></td></tr></table></figure><h3 id="注意MTU的大小"><a href="#注意MTU的大小" class="headerlink" title="注意MTU的大小"></a>注意MTU的大小</h3><p>hping3 -S通过，但是http访问依然，原因可能和MTU有关，排查后调整</p><blockquote><p>curl: (28) Operation timed out after 3005 milliseconds with 0 bytes received</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@nginx:/<span class="comment"># netstat -i</span></span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       100      106      0     32 0            43      0      0      0 BMRU</span><br><span class="line">lo       65536        0      0      0 0             0      0      0      0 LRU</span><br><span class="line"></span><br><span class="line"><span class="comment">##调整</span></span><br><span class="line">root@nginx:/<span class="comment"># ifconfig eth0 mtu 1500</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 案例分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
            <tag> 系统优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-阶段性总结</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="确认优化的目标"><a href="#确认优化的目标" class="headerlink" title="确认优化的目标"></a>确认优化的目标</h2><p>根据服务器应用的场景来确定我们优化的目标</p><p>防火墙：类似线性转发关注PPS<br>数据库：关注响应延迟和BPS<br>web应用：关注响应延迟和BPS以及每秒的请求数</p><h2 id="针对应用的场景制定测试的基准"><a href="#针对应用的场景制定测试的基准" class="headerlink" title="针对应用的场景制定测试的基准"></a>针对应用的场景制定测试的基准</h2><p>根据我们的网络协议栈，分别对每一层进行基准测试</p><p><img src="/系统优化-网络-阶段性总结/img0.png" alt="avator"></p><ol><li>数据接口层 and IP层：关注pps</li><li>传输层：关注包的BPS,网络延迟,连接数</li><li>应用层：关注包的BPS，网络延迟,每秒请求数</li></ol><h2 id="相关工具表"><a href="#相关工具表" class="headerlink" title="相关工具表"></a>相关工具表</h2><p><img src="/系统优化-网络-阶段性总结/img1.png" alt="avator"></p><p><img src="/系统优化-网络-阶段性总结/img2.png" alt="avator"></p><h2 id="制定优化策略"><a href="#制定优化策略" class="headerlink" title="制定优化策略"></a>制定优化策略</h2><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><ul><li>在IO模型上采用epool，取代pool或者select；或者AIO</li><li>在进程工作模型上：采用master+worker机制</li></ul><h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>  套接字可以屏蔽掉Linux内核中不同协议的差异，为应用程序提供统一的访问接口。每个套接字，都有一个读写缓冲区。</p><ul><li>读缓冲区：缓存了远端发过来的数据。如果读缓冲区已满，就不能再接收新的数据。</li><li><p>写缓冲区：缓存了要发出去的数据。如果写缓冲区已满，应用程序的写操作就会被阻塞</p><p>为了提高吞吐我们可以调整缓冲区大小：</p></li><li><p>增大每个套接字的缓冲区大小 net.core.optmem_max；</p></li><li>增大套接字接收缓冲区大小 net.core.rmem_max 和发送缓冲区大小 net.core.wmem_max；</li><li><p>增大 TCP 接收缓冲区大小 net.ipv4.tcp_rmem 和发送缓冲区大小 net.ipv4.tcp_wmem</p><p>具体参数如图：<br><img src="/系统优化-网络-阶段性总结/img3.png" alt="avator"></p><p>除此之外，套接字接口还提供了一些配置选项，用来修改网络连接的行为：</p></li><li><p>为 TCP 连接设置 TCP_NODELAY 后，就可以禁用 Nagle 算法；</p></li><li>为 TCP 连接开启 TCP_CORK 后，可以让小包聚合成大包后再发送（注意会阻塞小包的发送）；</li><li>使用 SO_SNDBUF 和 SO_RCVBUF ，可以分别调整套接字发送缓冲区和接收缓冲区的大小。</li></ul><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>  我第一类，在请求数比较大的场景下，你可能会看到大量处于 TIME_WAIT 状态的连接，它们会占用大量内存和端口资源。这时，我们可以优化与 TIME_WAIT 状态相关的内核选项，比如采取下面几种措施。</p><ol><li>增大处于 TIME_WAIT 状态的连接数量 net.ipv4.tcp_max_tw_buckets ，并增大连接跟踪表的大小 net.netfilter.nf_conntrack_max。</li><li>减小 net.ipv4.tcp_fin_timeout 和 net.netfilter.nf_conntrack_tcp_timeout_time_wait ，让系统尽快释放它们所占用的资源。</li><li>开启端口复用 net.ipv4.tcp_tw_reuse。这样，被 TIME_WAIT 状态占用的端口，还能用到新建的连接中。</li><li>增大本地端口的范围 net.ipv4.ip_local_port_range 。这样就可以支持更多连接，提高整体的并发能力。</li><li><p>增加最大文件描述符的数量。你可以使用 fs.nr_open 和 fs.file-max ，分别增大进程和系统的最大文件描述符数；或在应用程序的 systemd 配置文件中，配置 LimitNOFILE ，设置应用程序的最大文件描述符数。</p><p>第二类，为了缓解 SYN FLOOD 等，利用 TCP 协议特点进行攻击而引发的性能问题，你可以考虑优化与 SYN 状态相关的内核选项，比如采取下面几种措施。</p></li><li><p>增大 TCP 半连接的最大数量 net.ipv4.tcp_max_syn_backlog</p></li><li>开启 TCP SYN Cookies net.ipv4.tcp_syncookies ，来绕开半连接数量限制的问题（注意，这两个选项不可同时使用）。</li><li><p>减少 SYN_RECV 状态的连接重传 SYN+ACK 包的次数 net.ipv4.tcp_synack_retries。</p><p>第三类，在长连接的场景中，通常使用 Keepalive 来检测 TCP 连接的状态，以便对端连接断开后，可以自动回收。但是，系统默认的 Keepalive 探测间隔和重试次数，一般都无法满足应用程序的性能要求。所以，这时候你需要优化与 Keepalive 相关的内核选项，比如：</p></li><li><p>缩短最后一次数据包到 Keepalive 探测包的间隔时间 net.ipv4.tcp_keepalive_time；</p></li><li>缩短发送 Keepalive 探测包的间隔时间 net.ipv4.tcp_keepalive_intvl；</li><li><p>减少 Keepalive 探测失败后，一直到通知应用程序前的重试次数 net.ipv4.tcp_keepalive_probes。</p><p>具体的参数如下：<br><img src="/系统优化-网络-阶段性总结/img4.png" alt="avator"></p></li></ol><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>  网络层，负责网络包的封装、寻址和路由，包括 IP、ICMP 等常见协议。在网络层，最主要的优化，其实就是对路由、 IP 分片以及 ICMP 等进行调优。</p><p>  第一种，从路由和转发的角度出发，你可以调整下面的内核选项。在需要转发的服务器中，</p><ol><li>比如用作 NAT 网关的服务器或者使用 Docker 容器时，开启 IP 转发，即设置 net.ipv4.ip_forward = 1。</li><li>调整数据包的生存周期 TTL，比如设置 net.ipv4.ip_default_ttl = 64。注意，增大该值会降低系统性能。</li><li><p>开启数据包的反向地址校验，比如设置 net.ipv4.conf.eth0.rp_filter = 1。这样可以防止 IP 欺骗，并减少伪造 IP 带来的 DDoS 问题。</p><p>第二种，从分片的角度出发，最主要的是调整 MTU（Maximum Transmission Unit）的大小。通常，MTU 的大小应该根据以太网的标准来设置。</p><p>以太网标准规定，一个网络帧最大为 1518B，那么去掉以太网头部的 18B 后，剩余的 1500 就是以太网 MTU 的大小。</p><p>在使用 VXLAN、GRE 等叠加网络技术时，要注意，网络叠加会使原来的网络包变大，导致 MTU 也需要调整。比如，就以 VXLAN 为例，它在原来报文的基础上，增加了 14B 的以太网头部、 8B 的 VXLAN 头部、8B 的 UDP 头部以及 20B 的 IP 头部。换句话说，每个包比原来增大了 50B。所以，我们就需要把交换机、路由器等的 MTU，增大到 1550， 或者把 VXLAN 封包前（比如虚拟化环境中的虚拟网卡）的 MTU 减小为 1450。</p><p>另外，现在很多网络设备都支持巨帧，如果是这种环境，你还可以把 MTU 调大为 9000，以提高网络吞吐量。</p><p>第三种，从 ICMP 的角度出发，为了避免 ICMP 主机探测、ICMP Flood 等各种网络问题，你可以通过内核选项，来限制 ICMP 的行为。比如，</p></li><li><p>你可以禁止 ICMP 协议，即设置 net.ipv4.icmp_echo_ignore_all = 1。这样，外部主机就无法通过 ICMP 来探测主机。</p></li><li>你还可以禁止广播 ICMP，即设置 net.ipv4.icmp_echo_ignore_broadcasts = 1。</li></ol><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>  网络层的下面是链路层，所以最后，我们再来看链路层的优化方法。链路层负责网络包在物理网络中的传输，比如 MAC 寻址、错误侦测以及通过网卡传输网络帧等。自然，链路层的优化，也是围绕这些基本功能进行的。接下来，我们从不同的几个方面分别来看。</p><ol><li>由于网卡收包后调用的中断处理程序（特别是软中断），需要消耗大量的 CPU。所以，将这些中断处理程序调度到不同的 CPU 上执行，就可以显著提高网络吞吐量。这通常可以采用下面两种方法。</li><li><p>可以为网卡硬中断配置 CPU 亲和性（smp_affinity），或者开启 irqbalance 服务。再如，你可以开启 RPS（Receive Packet Steering）和 RFS（Receive Flow Steering），将应用程序和软中断的处理，调度到相同 CPU 上，这样就可以增加 CPU 缓存命中率，减少网络延迟。</p><p>另外，现在的网卡都有很丰富的功能，原来在内核中通过软件处理的功能，可以卸载到网卡中，通过硬件来执行。</p></li></ol><ul><li>TSO（TCP Segmentation Offload）和 UFO（UDP Fragmentation Offload）：在 TCP/UDP 协议中直接发送大包；而 TCP 包的分段（按照 MSS 分段）和 UDP 的分片（按照 MTU 分片）功能，由网卡来完成 。</li><li>GSO（Generic Segmentation Offload）：在网卡不支持 TSO/UFO 时，将 TCP/UDP 包的分段，延迟到进入网卡前再执行。这样，不仅可以减少 CPU 的消耗，还可以在发生丢包时只重传分段后的包。</li><li>LRO（Large Receive Offload）：在接收 TCP 分段包时，由网卡将其组装合并后，再交给上层网络处理。不过要注意，在需要 IP 转发的情况下，不能开启 LRO，因为如果多个包的头部信息不一致，LRO 合并会导致网络包的校验错误。</li><li>GRO（Generic Receive Offload）：GRO 修复了 LRO 的缺陷，并且更为通用，同时支持 TCP 和 UDP。</li><li>RSS（Receive Side Scaling）：也称为多队列接收，它基于硬件的多个接收队列，来分配网络接收进程，这样可以让多个 CPU 来处理接收到的网络包。</li><li>VXLAN 卸载：也就是让网卡来完成 VXLAN 的组包功能。</li></ul><h2 id="DKDP-and-XDP"><a href="#DKDP-and-XDP" class="headerlink" title="DKDP and XDP"></a>DKDP and XDP</h2><ol><li>使用 DPDK 技术，跳过内核协议栈，直接由用户态进程用轮询的方式，来处理网络请求。同时，再结合大页、CPU 绑定、内存对齐、流水线并发等多种机制，优化网络包的处理效率。</li><li>使用内核自带的 XDP 技术，在网络包进入内核协议栈前，就对其进行处理，这样也可以实现很好的性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-NAT相关的知识以及优化</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-NAT%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-NAT%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="NAT概念"><a href="#NAT概念" class="headerlink" title="NAT概念"></a>NAT概念</h2><p>  NAT技术可以重写IP数据包的源IP或者目的IP，被普遍地用来解决公网IP地址短缺的问题。</p><p>  原理：网络中的多台主机，通过共享同一个公网IP地址，来访问外网资源。同时，由于 NAT 屏蔽了内网网络，自然也就为局域网中的机器提供了安全隔离。你既可以在支持网络地址转换的路由器（称为 NAT网关）中配置NAT，也可以在Linux服务器中配置 NAT。如果采用第二种方式，Linux服务器实际上充当的是“软”路由器的角色。</p><p>  根据实现方式的不同，NAT 可以分为三类：</p><ul><li>静态NAT，即内网IP与公网IP是一对一的永久映射关系；</li><li>动态NAT，即内网IP从公网IP池中，动态选择一个进行映射；网络地址端口转换</li><li><p>NAPT（Network Address and Port Translation），即把内网IP映射到公网IP的不同端口上，让多个内网IP可以共享同一个公网IP地址。</p><p>我们基本上都会采用NAPT。</p><p>根据转换方式不同，我们又可以把NAPT分为三类。</p></li><li><p>SNAT，即目的地址不变，只替换源IP或源端口。SNAT主要用于，多个内网IP共享同一个公网IP ，来访问外网资源的场景。</p></li><li>DNAT，即源IP保持不变，只替换目的IP或者目的端口。DNAT 主要通过公网IP的不同端口号，来访问内网的多种服务，同时会隐藏后端服务器的真实IP地址。</li><li><p>双向地址转换，即同时使用SNAT和DNAT。当接收到网络包时，执行DNAT，把目的IP转换为内网IP；而在发送网络包时，执行SNAT，把源IP替换为外部 IP。</p><p>这3种方式如图<br><img src="/系统优化-网络-NAT相关的知识以及优化/img0.png" alt="avator"></p></li></ul><h2 id="iptables和NAT"><a href="#iptables和NAT" class="headerlink" title="iptables和NAT"></a>iptables和NAT</h2><p>  我们可以通过设置iptables来做NAT的映射,其中：</p><p>  POSTROUTING：在经过路由之后，用来设置SNAT<br>  PREROUTING：在经过路由之前，用来设置DNAT</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># POSTROUTING 经过路由 设置-s realServer内网IP  -j SNAT  --to-source  外网IP</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.2 -j SNAT --to-source 100.100.100.100</span><br><span class="line"><span class="comment"># PREROUTING 未进过路由 设置-d 外网IP -j DNAT --to-destination realServer内网IP</span></span><br><span class="line">iptables -t nat -A PREROUTING -d 100.100.100.100 -j DNAT --to-destination 192.168.0.2</span><br></pre></td></tr></table></figure><h2 id="NAT影响性能的原因"><a href="#NAT影响性能的原因" class="headerlink" title="NAT影响性能的原因"></a>NAT影响性能的原因</h2><p>  测试步骤</p><ol><li>在服务器上运行nginx-docker，使用HOST网络，不使用NAT，用ab测试观察每秒请求书，请求平均延迟，建立连接访问延迟</li><li>在服务器上运行nginx-docker，使用NAT，用ab测试观察每秒请求书，请求平均延迟，建立连接访问延迟。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-hostnet --privileged --network=host -itd feisky/nginx:80</span><br><span class="line">docker run --name nginx --privileged -p 8080:8080 -itd feisky/nginx:nat</span><br></pre></td></tr></table></figure><p>  NAT的工作原理：网络包的流向以及NAT的原理，你会发现，要保证NAT正常工作，就至少需要两个步骤：</p><ol><li>利用 Netfilter 中的钩子函数（Hook），修改源地址或者目的地址。</li><li>利用连接跟踪模块 conntrack ，关联同一个连接的请求和响应。</li></ol><h3 id="通过SystemTap来追踪内核"><a href="#通过SystemTap来追踪内核" class="headerlink" title="通过SystemTap来追踪内核"></a>通过SystemTap来追踪内核</h3><p>我们编写如下脚本，之后执行 <strong>stap –all-modules dropwatch.stp</strong> 将脚本编译进内核状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env stap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"><span class="comment"># Dropwatch.stp</span></span><br><span class="line"><span class="comment"># Author: Neil Horman &lt;nhorman@redhat.com&gt;</span></span><br><span class="line"><span class="comment"># An example script to mimic the behavior of the dropwatch utility</span></span><br><span class="line"><span class="comment"># http://fedorahosted.org/dropwatch</span></span><br><span class="line"><span class="comment">############################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Array to hold the list of drop points we find</span></span><br><span class="line">global locations</span><br><span class="line"></span><br><span class="line"><span class="comment"># Note when we turn the monitor on and off</span></span><br><span class="line">probe begin &#123; <span class="built_in">printf</span>(<span class="string">"Monitoring for dropped packets\n"</span>) &#125;</span><br><span class="line">probe end &#123; <span class="built_in">printf</span>(<span class="string">"Stopping dropped packet monitor\n"</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># increment a drop counter for every location we drop at</span></span><br><span class="line">probe kernel.trace(<span class="string">"kfree_skb"</span>) &#123; locations[<span class="variable">$location</span>] &lt;&lt;&lt; 1 &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Every 5 seconds report our drop locations</span></span><br><span class="line">probe timer.sec(5)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>)</span><br><span class="line">  foreach (l <span class="keyword">in</span> locations-) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d packets dropped at %s\n"</span>,</span><br><span class="line">           @count(locations[l]), symname(l))</span><br><span class="line">  &#125;</span><br><span class="line">  delete locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 再进行ab压测发现丢包都发生在nf_hook_slow</p><p>  整个请求的原理如下，我们知道了原理，可以有针对的进行性优化，调整内核参数。</p><ol><li>接收网络包时，在连接跟踪表中查找连接，并为新的连接分配跟踪对象（Bucket）。</li><li>在 Linux 网桥中转发包。这是因为案例 Nginx 是一个 Docker 容器，而容器的网络通过网桥来实现；</li><li>接收网络包时，执行 DNAT，即把 8080 端口收到的包转发给容器。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sysctl -a | grep conntrack</span><br><span class="line">net.netfilter.nf_conntrack_count = 180 <span class="comment">## 表示当前连接跟踪数；</span></span><br><span class="line">net.netfilter.nf_conntrack_max = 1000 <span class="comment">## 表示最大连接跟踪数；可以改大为nf_conntrack_buckets俩倍</span></span><br><span class="line">net.netfilter.nf_conntrack_buckets = 65536 <span class="comment">## 表示连接跟踪表的大小。</span></span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>conntrack工具查看链接表内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -L表示列表，-o表示以扩展格式显示</span></span><br><span class="line">$ conntrack -L -o extended | head</span><br><span class="line">ipv4     2 tcp      6 7 TIME_WAIT src=192.168.0.2 dst=192.168.0.96 sport=51744 dport=8080 src=172.17.0.2 dst=192.168.0.2 sport=8080 dport=51744 [ASSURED] mark=0 use=1</span><br><span class="line">ipv4     2 tcp      6 6 TIME_WAIT src=192.168.0.2 dst=192.168.0.96 sport=51524 dport=8080 src=172.17.0.2 dst=192.168.0.2 sport=8080 dport=51524 [ASSURED] mark=0 use=1</span><br></pre></td></tr></table></figure><p>dmsg查看系统错误日志</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-延迟ACK和Nagle算法对网络延迟的影响</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%BB%B6%E8%BF%9FACK%E5%92%8CNagle%E7%AE%97%E6%B3%95%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%BB%B6%E8%BF%9FACK%E5%92%8CNagle%E7%AE%97%E6%B3%95%E5%AF%B9%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h2><p>  开启方式，设置标记为： <strong>TCP_NODELAY</strong></p><p>  说明：我们在开启这个选项时候就启用了Nagle算法，Negle算法的初衷本质是想充分利用带宽资源，将小包汇总到一起发送出去，它规定了网络中只能存在一个为ack的包。</p><h2 id="延迟ACK"><a href="#延迟ACK" class="headerlink" title="延迟ACK"></a>延迟ACK</h2><p>  开启方式，默认为开启，关闭设置 <strong>TCP_QUICKACK</strong></p><p>  说明：为了减少网络交互客户端不用每个包都Ack。会等一段时间(40ms)之后一起发送出去</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当延迟ACK遇上TCP_NODELAY,就会有可能出现明显的网络延迟。如下图：</p><p><img src="/系统优化-网络-延迟ACK和Nagle算法对网络延迟的影响/img0.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-如何环境DDoS攻击</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%A6%82%E4%BD%95%E7%8E%AF%E5%A2%83DDoS%E6%94%BB%E5%87%BB/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%A6%82%E4%BD%95%E7%8E%AF%E5%A2%83DDoS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="DDoS-简介"><a href="#DDoS-简介" class="headerlink" title="DDoS 简介"></a>DDoS 简介</h2><p>  DDoS 的前身是 DoS（Denail of Service），即拒绝服务攻击，指利用大量的合理请求，来占用过多的目标资源，从而使目标服务无法响应正常请求。</p><p>  DDoS（Distributed Denial of Service） 则是在 DoS 的基础上，采用了分布式架构，利用多台主机同时攻击目标主机。这样，即使目标服务部署了网络防御设备，面对大量网络请求时，还是无力应对。</p><h2 id="DDos攻击以及缓解方法"><a href="#DDos攻击以及缓解方法" class="headerlink" title="DDos攻击以及缓解方法"></a>DDos攻击以及缓解方法</h2><p>  常见的有半连接攻击，攻击者发送大量的SYNC包给服务器，大量的链接处于SYN_REV状态，很快链接表被占满，比如用这个命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-S 发sync包</span><br><span class="line">-i 间隔</span><br><span class="line">-p 目标端口</span><br><span class="line">hping3 -S -p 80 -i u10 192.168.1.1</span><br></pre></td></tr></table></figure><p>  现象：端口响应变慢，甚至中断所有操作都慢。</p><p>  排查思路：<br>  用sar -n DEV 1看到如下结果，rxpack很大，但是rxkB很小，是典型的小包问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">07:11:19 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">07:11:20 PM      eth0  37279.00  18651.00   1966.75   1057.48      0.00      0.00      0.00</span><br><span class="line">07:11:20 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><p>  如何排查，我们可以用netstat看统计有多少SYN_RECV的链接发现大量的SYN_RECV，大概有190+，因为默认的链接表只有256个，所以我们的正常请求会变慢。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -np|grep SYN_RECV|wc -l</span><br></pre></td></tr></table></figure><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>  优化系统参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/sysctl.conf</span><br><span class="line">net.ipv4.tcp_syncookies = 1 <span class="comment">#通过cookie，来取代半连接</span></span><br><span class="line">net.ipv4.tcp_synack_retries = 1 <span class="comment">#重试次数，可通过减少次数</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024 <span class="comment">#半链接容量</span></span><br></pre></td></tr></table></figure><p>  优化系统：通过XDP、DKDP来缓解</p><p>  借用外部工具：通过WAF、CDN等来缓解</p><p>  彻底解决：<em>通过专业的流量清洗工具</em></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><img src="/系统优化-网络-如何环境DDoS攻击/img0.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-常用工具</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS相关"><a href="#DNS相关" class="headerlink" title="DNS相关"></a>DNS相关</h2><p>  DNS：即域名系统，是互联网中最基础的一项服务，主要提供域名和 IP 地址之间映射关系的查询服务。</p><p>  我们常见的DNS记录有以下几种：</p><ul><li>A：用来把域名转换成 IP 地址；</li><li>CNAME：用来创建别名</li><li><p>NS：则表示该域名对应的域名服务器地址。</p><p>DNS的域名查找从跟(.)开始进行递归查找，我们可以通过nslookup后者dig这俩个工具查看DNS解析的全过程</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup time.geekbang.org</span><br><span class="line"><span class="comment"># 域名服务器及端口信息</span></span><br><span class="line">Server:    114.114.114.114</span><br><span class="line">Address:  114.114.114.114<span class="comment">#53</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非权威查询结果</span></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:  time.geekbang.org</span><br><span class="line">Address: 39.106.233.17</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># +trace表示开启跟踪查询</span></span><br><span class="line"><span class="comment"># +nodnssec表示禁止DNS安全扩展</span></span><br><span class="line">$ dig +trace +nodnssec time.geekbang.org</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.11.3-1ubuntu1.3-Ubuntu &lt;&lt;&gt;&gt; +trace +nodnssec time.geekbang.org</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.      322086  IN  NS  m.root-servers.net.</span><br><span class="line">.      322086  IN  NS  a.root-servers.net.</span><br><span class="line">.      322086  IN  NS  i.root-servers.net.</span><br><span class="line">.      322086  IN  NS  d.root-servers.net.</span><br><span class="line">.      322086  IN  NS  g.root-servers.net.</span><br><span class="line">.      322086  IN  NS  l.root-servers.net.</span><br><span class="line">.      322086  IN  NS  c.root-servers.net.</span><br><span class="line">.      322086  IN  NS  b.root-servers.net.</span><br><span class="line">.      322086  IN  NS  h.root-servers.net.</span><br><span class="line">.      322086  IN  NS  e.root-servers.net.</span><br><span class="line">.      322086  IN  NS  k.root-servers.net.</span><br><span class="line">.      322086  IN  NS  j.root-servers.net.</span><br><span class="line">.      322086  IN  NS  f.root-servers.net.</span><br><span class="line">;; Received 239 bytes from 114.114.114.114<span class="comment">#53(114.114.114.114) in 1340 ms</span></span><br><span class="line"></span><br><span class="line">org.      172800  IN  NS  a0.org.afilias-nst.info.</span><br><span class="line">org.      172800  IN  NS  a2.org.afilias-nst.info.</span><br><span class="line">org.      172800  IN  NS  b0.org.afilias-nst.org.</span><br><span class="line">org.      172800  IN  NS  b2.org.afilias-nst.org.</span><br><span class="line">org.      172800  IN  NS  c0.org.afilias-nst.info.</span><br><span class="line">org.      172800  IN  NS  d0.org.afilias-nst.org.</span><br><span class="line">;; Received 448 bytes from 198.97.190.53<span class="comment">#53(h.root-servers.net) in 708 ms</span></span><br><span class="line"></span><br><span class="line">geekbang.org.    86400  IN  NS  dns9.hichina.com.</span><br><span class="line">geekbang.org.    86400  IN  NS  dns10.hichina.com.</span><br><span class="line">;; Received 96 bytes from 199.19.54.1<span class="comment">#53(b0.org.afilias-nst.org) in 1833 ms</span></span><br><span class="line"></span><br><span class="line">time.geekbang.org.  600  IN  A  39.106.233.176</span><br><span class="line">;; Received 62 bytes from 140.205.41.16<span class="comment">#53(dns10.hichina.com) in 4 ms</span></span><br></pre></td></tr></table></figure><p>  设置DNS的方法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br></pre></td></tr></table></figure><p>  如果DNS的解析不稳定我们可以开启dnsmasq dns缓存来加速</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/dnsmasq start</span><br><span class="line">* Starting DNS forwarder and DHCP server dnsmasq                    [ OK ]</span><br></pre></td></tr></table></figure><h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><p>常用的抓包工具有tcpdump和wireshark，其中tcpdump用于服务器抓包，wireshark由于有图形界面适合我们对tcpdump导出的文件在本地分析</p><p>tcpdump的常用参数</p><p><img src="/系统优化-网络-常用工具/img0.png" alt="avator"></p><p>tcpdump的常用表达式</p><p><img src="/系统优化-网络-常用工具/img1.png" alt="avator"></p><p>tcpdump的输出格式</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间戳 协议 源地址.源端口 &gt; 目的地址.目的端口 网络包详细信息</span><br></pre></td></tr></table></figure><p>wireshark</p><p><img src="/系统优化-网络-常用工具/img2.png" alt="avator"></p><p>你可以看到</p><ul><li>IP 层（Internet Protocol）的源地址和目的地址</li><li>传输层的 UDP 协议（Uder Datagram Protocol）</li><li>应用层的 DNS 协议（Domain Name System）的概要信息。</li></ul><p>继续点击每层左边的箭头，就可以看到该层协议头的所有信息。比如点击 DNS 后，就可以看到 Transaction ID、Flags、Queries 等 DNS 协议各个字段的数值以及含义。当然，Wireshark 的功能远不止如此。接下来我再带你一起，看一个 HTTP 的例子，并理解 TCP 三次握手和四次挥手的工作原理。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-C10K和C1000K回顾-系统调优方案</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-C10K%E5%92%8CC1000K%E5%9B%9E%E9%A1%BE-%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98%E6%96%B9%E6%A1%88/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-C10K%E5%92%8CC1000K%E5%9B%9E%E9%A1%BE-%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>C10K的C只的是client客户端的意思，意思是支持1W的客户端连接。C1000K则是指100W的客户端连接。为了达到C10K,我们就要对系统进行优化，一般会从俩方面考虑。</p><h2 id="IO方面的优化"><a href="#IO方面的优化" class="headerlink" title="IO方面的优化"></a>IO方面的优化</h2><p>  因为传统的BIO一个线程只能同时处理一个IO请求效率比较低。为了增大并发处理的能力，我们往往会采用IO多路复用的思路去解决问题。I/O多路复用是什么意思呢？</p><p>  我们先来普及俩个概念</p><ul><li>水平触发：只要文件描述符可以非阻塞地执行 I/O ，就会触发通知。也就是说，应用程序可以随时检查文件描述符的状态，然后再根据状态，进行 I/O 操作。</li><li>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，直到无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了。</li></ul><h3 id="select或者pool的水平触发"><a href="#select或者pool的水平触发" class="headerlink" title="select或者pool的水平触发"></a>select或者pool的水平触发</h3><p>  select 和 poll 需要从文件描述符列表中，找出哪些可以执行I/O ，然后进行真正的网络I/O读写。由于I/O是非阻塞的，<strong>一个线程中就可以同时监控一批套接字的文件描述符，这样就达到了单线程处理多请求的目的</strong>。【多路复用指的就是粗体部分】</p><p>  缺点：</p><ul><li>select采用标量位，32位系统默认只能支持1024个描述符，且select的fd的状态位是也是用标量位来表示的，获取每个fd的状态需要轮询这个标量位。时间复杂度是o(n^2)</li><li>pool采用了个无界数组，没有了1024的限制，时间复杂度是o(n)，但是他俩都需要将能读写的fd，从用户态转移到内核态修改状态每次都要进行切换会造成损耗</li></ul><h3 id="epool的边缘触发"><a href="#epool的边缘触发" class="headerlink" title="epool的边缘触发"></a>epool的边缘触发</h3><p>  epool采用红黑树管理fd，时间复杂度o(log2n)，epool在内核态管理fd没有切换的损耗。</p><h2 id="系统并发度方面的优化"><a href="#系统并发度方面的优化" class="headerlink" title="系统并发度方面的优化"></a>系统并发度方面的优化</h2><p>  master+worker的方案，nginx或者我们的netty架构几乎都是这种方案master和worker可以是进程也可以是线程。这种情况要考虑避免惊群效应,即多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠、</p><ul><li>其中，accept() 的惊群问题，已经在 Linux 2.6 中解决了；</li><li><p>而epoll的问题，到了 Linux 4.5 ，才通过EPOLLEXCLUSIVE解决。</p><blockquote><p>Nginx是如何避免惊群问题， Nginx在每个worker进程中，都增加一个了全局锁（accept_mutex）。这些worker进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到epoll中，这样就确保只有一个worker子进程被唤醒。</p></blockquote><p>监听到相同端口的多进程模型。在这种方式下，所有的进程都监听相同的接口，并且开启 SO_REUSEPORT 选项，由内核负责将请求负载均衡到这些监听进程中去。这一过程如下图所示</p><p><img src="/系统优化-网络-C10K和C1000K回顾-系统调优方案/img0.png" alt="avator"></p><p>这由于内核确保了只有一个进程被唤醒，就不会出现惊群问题了。比如，Nginx在1.9.1中就已经支持了这种模式。</p><p><img src="/系统优化-网络-C10K和C1000K回顾-系统调优方案/img1.png" alt="avator"></p><p>我们从C10K-C100K都可以用这种方案+不断升级我们的硬件来解决。但是到了更高C1000K因为中断、网络包链路过长等等原因采取一些新的手段比如</p></li></ul><h2 id="DKDP"><a href="#DKDP" class="headerlink" title="DKDP"></a>DKDP</h2><p>  允许我们在用户态直接处理请求包并且调用网卡发送出去，需要支持DKDP网卡</p><p>  <img src="/系统优化-网络-C10K和C1000K回顾-系统调优方案/DKDP.png" alt="avator"></p><h2 id="XDP"><a href="#XDP" class="headerlink" title="XDP"></a>XDP</h2><p>  允许我们在进入网络协议栈之前先处理网络包</p><p>  <img src="/系统优化-网络-C10K和C1000K回顾-系统调优方案/XDP.png" alt="avator"></p><p>但是：其实我们C10K就几乎够用了因为我们还要考虑业务等因素，我们还是推荐拆分到不同的服务器中。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-网络-基础概念以及指标</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%8C%87%E6%A0%87/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E7%BD%91%E7%BB%9C-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>  前面我们讲了CPU、内存、磁盘IO，下面我们来看网络这部分，网络处理的流程最复杂，跟我们前面讲到的进程调度、中断处理、内存管理以及 I/O 等都密不可分。</p><p>  OSI的网络七层模型，以及TCP/IP的四层or五层模型,如下：</p><p>  <img src="/系统优化-网络-基础概念以及指标/img0.png" alt="avator"></p><h2 id="TCP-IP网络栈"><a href="#TCP-IP网络栈" class="headerlink" title="TCP/IP网络栈"></a>TCP/IP网络栈</h2><p>  有了linux根据tcp/ip模型，我们的网络栈的收发数据实际上就是按照这4层模型对数据层层进行处理，对上层发送发送来的数据进行分析，然后将本层的数据进行封装发给下层</p><ul><li>应用层–&gt;数据</li><li>传输层–&gt;TCP头+数据</li><li>网络层–&gt;IP头+TCP头+数据</li><li><p>网络接口层–&gt;根据MTU切分数据包 and 帧头+IP头+TCP头+数据+栈帧</p><p>下图是整个网络栈<br><img src="/系统优化-网络-基础概念以及指标/img1.png" alt="avator"></p></li></ul><h2 id="TCP-IP的手法"><a href="#TCP-IP的手法" class="headerlink" title="TCP/IP的手法"></a>TCP/IP的手法</h2><h3 id="接收网络包"><a href="#接收网络包" class="headerlink" title="接收网络包"></a>接收网络包</h3><ol><li>网卡通过DMA获取网络数据，放到待接收队列</li><li>系统的硬中断程序通知系统接收网络数据，并且申请sk_buff，并且将数据放入到sk_buff中</li><li>通过系统的软中断开始处理网络数据</li><li>网络接口层校验包完整性，去掉帧头和帧尾，数据传递给网络层</li><li>网络层根据IP信息确定吓一跳是本机还是转发，如果是本机，数据传递给传输层</li><li>传输层解析TCP头，找到4元祖通过套接字发送给程序</li></ol><h3 id="发送网络包"><a href="#发送网络包" class="headerlink" title="发送网络包"></a>发送网络包</h3><p>和接收相反</p><ol><li>程序通过系统内核调用套接字的sendMsg发送网络包</li><li>传输层封装TCP头信息，发送给IP层</li><li>IP层根据IP找到吓一跳的地址封装IP头，传递给网络接口层</li><li>网络接口层根据MTU对包进行切分，添加帧头、帧尾等信息</li><li>拆分好的包进行物理寻址找到对应的MAC地址，之后将自己添加到待发送队列</li><li>系统的软中断通知系统有网络包待发送</li><li>之后网卡驱动会通过DMA，将待发送队列的数据通过网卡发送出去</li></ol><p>如图：<br>  <img src="/系统优化-网络-基础概念以及指标/img2.png" alt="avator"></p><h2 id="查看网络情况的基础指标和工具"><a href="#查看网络情况的基础指标和工具" class="headerlink" title="查看网络情况的基础指标和工具"></a>查看网络情况的基础指标和工具</h2><h3 id="查看网卡信息"><a href="#查看网卡信息" class="headerlink" title="查看网卡信息"></a>查看网卡信息</h3><p>ifconfig or ip</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth0</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500</span><br><span class="line">      inet 10.240.0.30 netmask 255.240.0.0 broadcast 10.255.255.255</span><br><span class="line">      inet6 fe80::20d:3aff:fe07:cf2a prefixlen 64 scopeid 0x20&lt;link&gt;</span><br><span class="line">      ether 78:0d:3a:07:cf:3a txqueuelen 1000 (Ethernet)</span><br><span class="line">      RX packets 40809142 bytes 9542369803 (9.5 GB)</span><br><span class="line">      RX errors 0 dropped 0 overruns 0 frame 0</span><br><span class="line">      TX packets 32637401 bytes 4815573306 (4.8 GB)</span><br><span class="line">      TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</span><br><span class="line">​</span><br><span class="line">$ ip -s addr show dev eth0</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">  link/ether 78:0d:3a:07:cf:3a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">  inet 10.240.0.30/12 brd 10.255.255.255 scope global eth0</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  inet6 fe80::20d:3aff:fe07:cf2a/64 scope link</span><br><span class="line">      valid_lft forever preferred_lft forever</span><br><span class="line">  RX: bytes packets errors dropped overrun mcast</span><br><span class="line">   9542432350 40809397 0       0       0       193</span><br><span class="line">  TX: bytes packets errors dropped carrier collsns</span><br><span class="line">   4815625265 32637658 0       0       0       0</span><br></pre></td></tr></table></figure><ol><li>网络接口的状态标志。ifconfig 输出中的 RUNNING ，或 ip 输出中的 LOWER_UP ，都表示物理网络是连通的，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</li><li>MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</li><li>网络接口的 IP 地址、子网以及 MAC 地址。这些都是保障网络功能正常工作所必需的，你需要确保配置正确。</li><li>网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：<ul><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等；</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包；</li><li>overruns 表示超限数据包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包；</li><li>carrier 表示发生 carrirer 错误的数据包数，比如双工模式不匹配、物理电缆出现问题等；</li><li>collisions 表示碰撞数据包数。</li></ul></li></ol><h3 id="查看套接字信息"><a href="#查看套接字信息" class="headerlink" title="查看套接字信息"></a>查看套接字信息</h3><p>netstat or ss</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># head -n 3 表示只显示前面3行</span></span><br><span class="line"><span class="comment"># -l 表示只显示监听套接字</span></span><br><span class="line"><span class="comment"># -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="comment"># -p 表示显示进程信息</span></span><br><span class="line">$ netstat -nlp | head -n 3</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      840/systemd-resolve</span><br><span class="line"></span><br><span class="line"><span class="comment"># -l 表示只显示监听套接字</span></span><br><span class="line"><span class="comment"># -t 表示只显示 TCP 套接字</span></span><br><span class="line"><span class="comment"># -n 表示显示数字地址和端口(而不是名字)</span></span><br><span class="line"><span class="comment"># -p 表示显示进程信息</span></span><br><span class="line">$ ss -ltnp | head -n 3</span><br><span class="line">State    Recv-Q    Send-Q        Local Address:Port        Peer Address:Port</span><br><span class="line">LISTEN   0         128           127.0.0.53%lo:53               0.0.0.0:*        users:((<span class="string">"systemd-resolve"</span>,pid=840,fd=13))</span><br><span class="line">LISTEN   0         128                 0.0.0.0:22               0.0.0.0:*        users:((<span class="string">"sshd"</span>,pid=1459,fd=3))</span><br></pre></td></tr></table></figure><ul><li>当套接字处于连接状态（Established）时，<ul><li>Recv-Q 表示套接字缓冲还没有被应用程序取走的字节数（即接收队列长度）。</li><li>Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）。</li></ul></li><li>当套接字处于监听状态（Listening）时，<ul><li>Recv-Q 表示全连接队列的长度。</li><li>Send-Q 表示全连接队列的最大长度。</li></ul></li></ul><h3 id="统计协议栈信息"><a href="#统计协议栈信息" class="headerlink" title="统计协议栈信息"></a>统计协议栈信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ netstat -s</span><br><span class="line">...</span><br><span class="line">Tcp:</span><br><span class="line">    3244906 active connection openings</span><br><span class="line">    23143 passive connection openings</span><br><span class="line">    115732 failed connection attempts</span><br><span class="line">    2964 connection resets received</span><br><span class="line">    1 connections established</span><br><span class="line">    13025010 segments received</span><br><span class="line">    17606946 segments sent out</span><br><span class="line">    44438 segments retransmitted</span><br><span class="line">    42 bad segments received</span><br><span class="line">    5315 resets sent</span><br><span class="line">    InCsumErrors: 42</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ ss -s</span><br><span class="line">Total: 186 (kernel 1446)</span><br><span class="line">TCP:   4 (estab 1, closed 0, orphaned 0, synrecv 0, timewait 0/0), ports 0</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*    1446      -         -</span><br><span class="line">RAW    2         1         1</span><br><span class="line">UDP    2         2         0</span><br><span class="line">TCP    4         3         1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="查看网络的吞吐等指标"><a href="#查看网络的吞吐等指标" class="headerlink" title="查看网络的吞吐等指标"></a>查看网络的吞吐等指标</h3><p>sar</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数字1表示每隔1秒输出一组数据</span></span><br><span class="line">$ sar -n DEV 1</span><br><span class="line">Linux 4.15.0-1035-azure (ubuntu)   01/06/19   _x86_64_  (2 CPU)</span><br><span class="line"></span><br><span class="line">13:21:40        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">13:21:41         eth0     18.00     20.00      5.79      4.25      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41      docker0      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">13:21:41           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br></pre></td></tr></table></figure><h3 id="连通性和RTT"><a href="#连通性和RTT" class="headerlink" title="连通性和RTT"></a>连通性和RTT</h3><p>ping</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># -c3表示发送三次ICMP包后停止</span><br><span class="line">$ ping -c3 114.114.114.114</span><br><span class="line">PING 114.114.114.114 (114.114.114.114) 56(84) bytes of data.</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=1 ttl=54 time=244 ms</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=2 ttl=47 time=244 ms</span><br><span class="line">64 bytes from 114.114.114.114: icmp_seq=3 ttl=67 time=244 ms</span><br><span class="line"></span><br><span class="line">--- 114.114.114.114 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2001ms</span><br><span class="line">rtt min/avg/max/mdev = 244.023/244.070/244.105/0.034 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-优化套路</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E4%BC%98%E5%8C%96%E5%A5%97%E8%B7%AF/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E4%BC%98%E5%8C%96%E5%A5%97%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><p>用fio+blktrace</p><p>fio用于基准测试，blktrace可以进行io的录制通过fio的回放功能得到系统真实场景的io情况</p><h2 id="优化套路"><a href="#优化套路" class="headerlink" title="优化套路"></a>优化套路</h2><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li>追加写替代随机写</li><li>采用有缓存的io</li><li>采用标准库缓存或者外部缓存介绍io</li><li>如果对大文件写考虑用mmap(zero copy)</li><li>用fsync替代O_SYNC</li><li>做好进程隔离防止某个进程占有所有的io资源，比如采用cgroup对进程的io做限制</li><li>如果io的调度采用CFQ，考虑对ionice进行设置<ul><li>ionice 支持三个优先级类：Idle、Best-effort 和 Realtime。其中， Best-effort 和 Realtime 还分别支持 0-7 的级别，数值越小，则表示优先级别越高。</li></ul></li></ul><h3 id="文件系统优化"><a href="#文件系统优化" class="headerlink" title="文件系统优化"></a>文件系统优化</h3><ul><li>采用适合的文件系统</li><li>对文件系统参数调优</li><li>优化文件系统的缓存<ul><li>可以优化 pdflush 脏页的刷新频率（比如设置 dirty_expire_centisecs 和 dirty_writeback_centisecs）以及脏页的限额（比如调整 dirty_background_ratio 和 dirty_ratio 等）。</li></ul></li></ul><h3 id="磁盘优化"><a href="#磁盘优化" class="headerlink" title="磁盘优化"></a>磁盘优化</h3><ul><li>硬件优化用SDD取代HDD等</li><li>采用RAID方案提高读写能力</li><li>采用适合的线程调度算法</li><li>如果磁盘读写负担较大，可以单独配置磁盘</li><li>对顺序读取增加磁盘的预读能力<ul><li>调整内核选项 /sys/block/sdb/queue/read_ahead_kb，默认大小是 128 KB，单位为 KB。</li><li>使用 blockdev 工具设置，比如 blockdev –setra 8192 /dev/sdb，注意这里的单位是 512B（0.5KB），所以它的数值总是 read_ahead_kb 的两倍。</li></ul></li><li>通过调整请求队列增加磁盘吞吐<ul><li>可以调整磁盘队列的长度 /sys/block/sdb/queue/nr_requests，适当增大队列长度，可以提升磁盘的吞吐量（当然也会导致 I/O 延迟增大）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-总结</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E6%80%BB%E7%BB%93/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="IO的原理"><a href="#IO的原理" class="headerlink" title="IO的原理"></a>IO的原理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>  磁盘是块状设备，用来持久化数据，磁盘的性能明显劣于内存，系统用了缓存（cache）和缓冲（buffer）来弥补这部分的性能差异。</p><p>  磁盘有许多类型有:IDE(hd)，SATA(sd)还有网络存储等，序号一般从a-z。我们在这些设备上还可以进行分区，分区用0-9表示。</p><p>  我们将磁盘分区挂载到文件系统的某个目录中使用</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>  linux通过文件系统操作磁盘中的数据。文件系统由目录项、索引块、超级块、逻辑块组成。</p><ul><li>逻辑块：数据的最小单位是扇出一般是512b,磁盘为了加速访问将8个相邻的扇区组成了一个逻辑块进行操作，一个逻辑块4kb。逻辑块用来存储文件数据</li><li>索引块：存储索引节点（inode），索引节点存储了文件的原信息。比如大小、创建时间、权限、地址</li><li>目录项：存储文件和目录项之间的关系。</li><li><p>超级块：用来表示索引块、逻辑快使用情况。</p><p>缓存：</p><p>页缓存：加速磁盘IO访问<br>索引节点缓存：加速索引节点的访问<br>目录项缓存：加速目录项查找和访问</p><p>vfs:隐藏各种磁盘的实现提供统一的接口<br>通用区：在vfs下层隐藏多种磁盘系统的实现，对上提供统一接口；对下提供多种io请求合并优化的策略。</p></li></ul><h3 id="重点指标"><a href="#重点指标" class="headerlink" title="重点指标"></a>重点指标</h3><p>如图</p><p><img src="/系统优化-IO-总结/img0.png" alt="avator"></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>下面的表格是提供I/O的性能指标的工具：</p><p><img src="/系统优化-IO-总结/img1.png" alt="avator"></p><p>以指标的维度看：</p><p><img src="/系统优化-IO-总结/img2.png" alt="avator"></p><p>按照常用的排查思路我们看各工具：</p><p><img src="/系统优化-IO-总结/img3.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-案例redis引起的io问题</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E6%A1%88%E4%BE%8Bredis%E5%BC%95%E8%B5%B7%E7%9A%84io%E9%97%AE%E9%A2%98/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E6%A1%88%E4%BE%8Bredis%E5%BC%95%E8%B5%B7%E7%9A%84io%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h2><p>容器准备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=redis -itd -p 10000:80 feisky/redis-server</span><br><span class="line">docker run --name=app --network=container:redis -itd feisky/redis-app</span><br><span class="line"></span><br><span class="line">docker ps <span class="comment">#确定启动了俩个容器</span></span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                             NAMES</span><br><span class="line">e8aa78bb2a42        feisky/redis-app      <span class="string">"python /app.py"</span>         15 minutes ago      Up 15 minutes                                         app</span><br><span class="line">5567d2ba22c7        feisky/redis-server   <span class="string">"docker-entrypoint..."</span>   21 minutes ago      Up 21 minutes       6379/tcp, 0.0.0.0:10000-&gt;80/tcp   redis</span><br></pre></td></tr></table></figure><p>数据准备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:10000/init/5000</span><br><span class="line"><span class="comment"># 返回 &#123;"elapsed_seconds":23.771671295166016,"keys_initialized":5000&#125;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> curl http://192.168.0.10:10000/get_cache; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>接口响应要7s，用top查看cpu0的us是11.1，wa是35.6，初步判断是io的问题，cpu占用较高的进程是Pyhton和redis-server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">top - 12:37:23 up 4 days, 13:13,  2 users,  load average: 0.51, 0.25, 0.20</span><br><span class="line">Tasks: 102 total,   2 running, 100 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  : 11.1 us,  8.8 sy,  0.0 ni, 40.6 id, 35.6 wa,  0.0 hi,  1.1 si,  2.7 st</span><br><span class="line">KiB Mem :  1014884 total,   106288 free,   229516 used,   679080 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   524716 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 2335 root      20   0  192992  23796   5148 S 17.6  2.3   0:06.97 python</span><br><span class="line">  394 100       20   0   28340   3020   1128 R  8.6  0.3   0:06.05 redis-server</span><br></pre></td></tr></table></figure><p>我们用iostat -d -x进一步定位io的问题，发现很奇怪的发现一个查询接口居然有大量的write</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -x 1</span><br><span class="line">Linux 3.10.0-957.27.2.el7.x86_64 (10-254-192-16)        05/16/2020      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     0.26    0.53    5.36   105.01   107.24    72.00     0.13   35.83   57.35   33.69   0.75   0.44</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     0.00    1.08  504.30     8.60  1259.68     5.02     0.43    1.62   54.00    1.51   0.74  37.53</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">vda               0.00     0.00    0.00  576.14     0.00  1459.09     5.07     0.36    1.41    0.00    1.41   0.63  36.36</span><br></pre></td></tr></table></figure><p>用pidstat -d 定位发现是redis-server在写，接着我们用strace定位，发现有大量的write和fdatasync，经过排查发现我们的redis-server用的是AOF策略是alwalys，每条指令都需要write和fsync，会产生大量的write。我们改变策略改为everysec，问题解决大部分，为什么是大部分，我们看到西面的命令存在大量的SADD。这些是没必要的，我们可以通过修改代码优化。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">strace -f -T -tt -p 394</span><br><span class="line">[pid   394] 12:49:57.864317 fdatasync(7) = 0 &lt;0.003447&gt;</span><br><span class="line">[pid   394] 12:49:57.867921 write(8, <span class="string">":1\r\n"</span>, 4) = 4 &lt;0.000285&gt;</span><br><span class="line">[pid   394] 12:49:57.868293 epoll_pwait(5, [&#123;EPOLLIN, &#123;u32=8, u64=8&#125;&#125;], 10128, 55, NULL, 8) = 1 &lt;0.000078&gt;</span><br><span class="line">[pid   394] 12:49:57.868481 <span class="built_in">read</span>(8, <span class="string">"*2\r\n<span class="variable">$3</span>\r\nGET\r\n<span class="variable">$41</span>\r\nuuid:510df338-"</span>..., 16384) = 61 &lt;0.000040&gt;</span><br><span class="line">[pid   394] 12:49:57.868609 <span class="built_in">read</span>(3, 0x7fffaef0dce7, 1) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000047&gt;</span><br><span class="line">[pid   394] 12:49:57.868754 write(8, <span class="string">"<span class="variable">$3</span>\r\nbad\r\n"</span>, 9) = 9 &lt;0.000249&gt;</span><br><span class="line">[pid   394] 12:49:57.869108 epoll_pwait(5, [&#123;EPOLLIN, &#123;u32=8, u64=8&#125;&#125;], 10128, 54, NULL, 8) = 1 &lt;0.000037&gt;</span><br><span class="line">[pid   394] 12:49:57.869226 <span class="built_in">read</span>(8, <span class="string">"*2\r\n<span class="variable">$3</span>\r\nGET\r\n<span class="variable">$41</span>\r\nuuid:52aa4944-"</span>..., 16384) = 61 &lt;0.000062&gt;</span><br><span class="line">[pid   394] 12:49:57.869403 <span class="built_in">read</span>(3, 0x7fffaef0dce7, 1) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000036&gt;</span><br><span class="line">[pid   394] 12:49:57.869505 write(8, <span class="string">"<span class="variable">$3</span>\r\nbad\r\n"</span>, 9) = 9 &lt;0.000205&gt;</span><br><span class="line">[pid   394] 12:49:57.869833 epoll_pwait(5, [&#123;EPOLLIN, &#123;u32=8, u64=8&#125;&#125;], 10128, 54, NULL, 8) = 1 &lt;0.000038&gt;</span><br><span class="line">[pid   394] 12:49:57.869939 <span class="built_in">read</span>(8, <span class="string">"*4\r\n<span class="variable">$4</span>\r\nSCAN\r\n<span class="variable">$4</span>\r\n1590\r\n<span class="variable">$5</span>\r\nMATC"</span>..., 16384) = 47 &lt;0.000038&gt;</span><br><span class="line">[pid   394] 12:49:57.870071 <span class="built_in">read</span>(3, 0x7fffaef0dce7, 1) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000036&gt;</span><br><span class="line">[pid   394] 12:49:57.870172 write(8, <span class="string">"*2\r\n<span class="variable">$4</span>\r\n5942\r\n*10\r\n<span class="variable">$41</span>\r\nuuid:4bd"</span>..., 499) = 499 &lt;0.000352&gt;</span><br><span class="line">[pid   394] 12:49:57.870600 epoll_pwait(5, [&#123;EPOLLIN, &#123;u32=8, u64=8&#125;&#125;], 10128, 53, NULL, 8) = 1 &lt;0.000037&gt;</span><br><span class="line">[pid   394] 12:49:57.870753 <span class="built_in">read</span>(8, <span class="string">"*2\r\n<span class="variable">$3</span>\r\nGET\r\n<span class="variable">$41</span>\r\nuuid:4bdfcf62-"</span>..., 16384) = 61 &lt;0.000057&gt;</span><br><span class="line">[pid   394] 12:49:57.870887 <span class="built_in">read</span>(3, 0x7fffaef0dce7, 1) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000036&gt;</span><br><span class="line">[pid   394] 12:49:57.870987 write(8, <span class="string">"<span class="variable">$4</span>\r\ngood\r\n"</span>, 10) = 10 &lt;0.000196&gt;</span><br><span class="line">[pid   394] 12:49:57.871297 epoll_pwait(5, [&#123;EPOLLIN, &#123;u32=8, u64=8&#125;&#125;], 10128, 52, NULL, 8) = 1 &lt;0.000105&gt;</span><br></pre></td></tr></table></figure><p>经过修改AOF的策略和优化掉SADD命令相关代码接口响应市场降为0.16034674644470215ms</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-IO问题导致的接口延迟过高</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-IO%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%BB%B6%E8%BF%9F%E8%BF%87%E9%AB%98/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-IO%E9%97%AE%E9%A2%98%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%BB%B6%E8%BF%9F%E8%BF%87%E9%AB%98/</url>
      
        <content type="html"><![CDATA[<p>案例准备:启动一个web应用，用另一个中端请求，发现响应极慢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=app -p 10000:80 -itd feisky/word-pop</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.0.10:1000/popularity/word</span><br></pre></td></tr></table></figure><p>top、iostat发现磁盘的io很高，用strace的套路查看代码发现没有write的痕迹，这时候我们可以用bcc-tools下的filetop查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到工具目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/share/bcc/tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># -C 选项表示输出新内容时不清空屏幕</span></span><br><span class="line">$ ./filetop -C</span><br><span class="line"></span><br><span class="line">TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE</span><br><span class="line">514    python           0      1      0       2832    R 669.txt</span><br><span class="line">514    python           0      1      0       2490    R 667.txt</span><br><span class="line">514    python           0      1      0       2685    R 671.txt</span><br><span class="line">514    python           0      1      0       2392    R 670.txt</span><br><span class="line">514    python           0      1      0       2050    R 672.txt</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE</span><br><span class="line">514    python           2      0      5957    0       R 651.txt</span><br><span class="line">514    python           2      0      5371    0       R 112.txt</span><br><span class="line">514    python           2      0      4785    0       R 861.txt</span><br><span class="line">514    python           2      0      4736    0       R 213.txt</span><br><span class="line">514    python           2      0      4443    0       R 45.txt</span><br></pre></td></tr></table></figure><p>我们可以看到 线程ID，命令，读/写的次数、大小，文件类型，文件名称找到了创建了xxx.txt文件，我们通过ps找到tid所属的进程</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps efT|grep 514</span><br></pre></td></tr></table></figure><p>在通过bcc下的opensnoop找到具体的文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ opensnoop</span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/650.txt</span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/651.txt</span><br><span class="line">12280  python              6   0 /tmp/9046db9e-fe25-11e8-b13f-0242ac110002/652.txt</span><br></pre></td></tr></table></figure><p>猜测是程序接到请求后，创建了一堆临时文件，在读取到内存，然后删除了文件导致的，修改程序问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-写log引起的问题IO问题</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E5%86%99log%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98IO%E9%97%AE%E9%A2%98/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E5%86%99log%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98IO%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>  以下场景是一个典型的由于写log导致IO问题的场景。</p><blockquote><p>注：我的测试环境是1c2g内存的虚拟机，所以无法模拟案例，案例的需求是2c8g，所以这里只罗列除了排查思路。</p></blockquote><p>  准备工作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /tmp:/tmp --name=app -itd feisky/logapp</span><br></pre></td></tr></table></figure><p>  启动后发现系统响应变慢</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按1切换到每个CPU的使用情况</span></span><br><span class="line">$ top</span><br><span class="line">top - 14:43:43 up 1 day,  1:39,  2 users,  load average: 2.48, 1.09, 0.63</span><br><span class="line">Tasks: 130 total,   2 running,  74 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu0  :  0.7 us,  6.0 sy,  0.0 ni,  0.7 id, 92.7 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">%Cpu1  :  0.0 us,  0.3 sy,  0.0 ni, 92.3 id,  7.3 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  8169308 total,   747684 free,   741336 used,  6680288 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.  7113124 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">18940 root      20   0  656108 355740   5236 R   6.3  4.4   0:12.56 python</span><br><span class="line">1312 root      20   0  236532  24116   9648 S   0.3  0.3   9:29.80 python3</span><br></pre></td></tr></table></figure><ol><li>cpu0 的wa已经到了92.7</li><li>pyhton占了6.3的是你用率</li><li><p>内存的buff/cache占了6个g</p><p>综上觉得是io的问题，pyhton这个进程导致的，内存的占用有可能是因为大量的io读写文件导致的</p><p>用iostat查看下io的情况</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d表示显示I/O性能指标，-x表示显示扩展统计（即所有I/O指标）</span></span><br><span class="line">$ iostat -x -d 1</span><br><span class="line">Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util</span><br><span class="line">loop0            0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br><span class="line">sdb              0.00    0.00      0.00      0.00     0.00     0.00   0.00   0.00    0.00    0.00   0.00     0.00     0.00   0.00   0.00</span><br><span class="line">sda              0.00   64.00      0.00  32768.00     0.00     0.00   0.00   0.00    0.00 7270.44 1102.18     0.00   512.00  15.50  99.20</span><br></pre></td></tr></table></figure><p>系统sda的写到了32mb每秒，w_waite到了7s，私用率几乎100%，进一步印证了才想</p><p>下面我们该用pidstat查看具体时间那个进程导致的了，这里看到是18904-python导致的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -d 1</span><br><span class="line"></span><br><span class="line">15:08:35      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">15:08:36        0     18940      0.00  45816.00      0.00      96  python</span><br><span class="line"></span><br><span class="line">15:08:36      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">15:08:37        0       354      0.00      0.00      0.00     350  jbd2/sda1-8</span><br><span class="line">15:08:37        0     18940      0.00  46000.00      0.00      96  python</span><br><span class="line">15:08:37        0     20065      0.00      0.00      0.00    1503  kworker/u4:2</span><br></pre></td></tr></table></figure><p>strace -p pid来查看源码，发现程序会给句柄为3的文件写入300mb的数据，stat(“/tmp/logtest.txt.1”，找到了文件所在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ strace -p 18940</span><br><span class="line">strace: Process 18940 attached</span><br><span class="line">...</span><br><span class="line">mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f7aee9000</span><br><span class="line">mmap(NULL, 314576896, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f0f682e8000</span><br><span class="line">write(3, <span class="string">"2018-12-05 15:23:01,709 - __main"</span>..., 314572844</span><br><span class="line">) = 314572844</span><br><span class="line">munmap(0x7f0f682e8000, 314576896)       = 0</span><br><span class="line">write(3, <span class="string">"\n"</span>, 1)                       = 1</span><br><span class="line">munmap(0x7f0f7aee9000, 314576896)       = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line"><span class="built_in">stat</span>(<span class="string">"/tmp/logtest.txt.1"</span>, &#123;st_mode=S_IFREG|0644, st_size=943718535, ...&#125;) = 0</span><br></pre></td></tr></table></figure><p>我们可以用lsof -p进一步印证是哪些文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ lsof -p 18940</span><br><span class="line">COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF    NODE NAME</span><br><span class="line">python  18940 root  cwd    DIR   0,50      4096 1549389 /</span><br><span class="line">python  18940 root  rtd    DIR   0,50      4096 1549389 /</span><br><span class="line">…</span><br><span class="line">python  18940 root    2u   CHR  136,0       0t0       3 /dev/pts/0</span><br><span class="line">python  18940 root    3w   REG    8,1 117944320     303 /tmp/logtest.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-运行原理和重要的指标</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%92%8C%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E6%A0%87/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%E5%92%8C%E9%87%8D%E8%A6%81%E7%9A%84%E6%8C%87%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><p>  按照存储介质来来分类：</p><ul><li>机械硬盘HDD：包含磁头和磁片，读取数据通过改变磁头和磁道来进行数据的读取，随机IO因为寻址和改变磁道性能很差，在IO压力比较大的场景要尽量避免随机IO。</li><li><p>固态硬盘SSD：由电子元件组成，不需要磁道读取,所以随机IO和顺序IO性能都要比机械硬盘好得多。</p><p>但是，固态硬盘的随机IO因为也遵循擦除、写入所以随机IO会引起大量的垃圾回收，并且无法用到预读性能也不高。、</p><p>此外，机械磁盘和固态磁盘还分别有一个最小的读写单位。机械磁盘的最小读写单位是扇区，一般大小为 512 字节。而固态磁盘的最小读写单位是页，通常大小是 4KB、8KB 等。</p><p>按照接口来分类：比如可以把硬盘分为 IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel） 等。</p><p>IDE：后缀一般为hd<br>SCSI或者SATA：后缀一般为sd</p><p>根据设备编号后面一般跟小写字母a、b、c,我们在设备上还可以分区用0~9数字表示比如：/dev/sda1</p></li></ul><h2 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h2><p>  和VFS类似在文件系统到驱动程序之间实现了通用块层，俩个作用：</p><ol><li>向上为程序和文件系统提供统一的访问接口，向下屏蔽个文件系统程序之间的差异，提供统一框架管理各系统的驱动程序</li><li>实现IO的调度一般有：NONE、NOOP、CFQ、DeadLine<ol><li>NONE ，更确切来说，并不能算 I/O 调度算法。因为它完全不使用任何 I/O 调度器，对文件系统和应用程序的 I/O 其实不做任何处理，常用在虚拟机中（此时磁盘 I/O 调度完全由物理机负责）。</li><li>NOOP ，是最简单的一种 I/O 调度算法。它实际上是一个先入先出的队列，只做一些最基本的请求合并，常用于 SSD 磁盘。、</li><li>CFQ（Completely Fair Scheduler），也被称为完全公平调度器，是现在很多发行版的默认 I/O 调度器，它为每个进程维护了一个 I/O 调度队列，并按照时间片来均匀分布每个进程的 I/O 请求。类似于进程 CPU 调度，CFQ 还支持进程 I/O 的优先级调度，所以它适用于运行大量进程的系统，像是桌面环境、多媒体应用等。、</li><li>DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保达到最终期限（deadline）的请求被优先处理。DeadLine 调度算法，多用在 I/O 压力比较重的场景，比如数据库等。</li></ol></li></ol><h2 id="I-O栈"><a href="#I-O栈" class="headerlink" title="I/O栈"></a>I/O栈</h2><p>  如图：</p><p>  <img src="/系统优化-IO-运行原理和重要的指标/img0.png" alt="avator"></p><ul><li>文件系统层：对上为程序提供统一访问接口，对下会通过通用块层，来存储和管理磁盘数据。</li><li>通用块层：包括块设备I/O队列和I/O调度器，负责I/O请求的排队、合并等调度工作</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作。</li></ul><h2 id="常用的查看工具"><a href="#常用的查看工具" class="headerlink" title="常用的查看工具"></a>常用的查看工具</h2><p>我们主要关注的几个指标</p><ul><li>使用率：如果io的使用率过高，表示系统存在瓶颈。</li><li>饱和度：是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着磁盘存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求。</li><li>请求数/S：是指每秒的 I/O 请求数。</li><li>吞吐：是指每秒的 I/O 请求大小。</li><li>响应时间：是指 I/O 请求从发出到收到响应的间隔时间。</li></ul><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -d -x表示显示所有磁盘I/O的指标</span></span><br><span class="line">$ iostat -d -x 1</span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sdb               0.00     0.04    0.56    1.74    29.28    50.93    69.51     0.00    1.28    0.21    1.63   0.04   0.01</span><br><span class="line">sda               0.00     0.67    0.03    1.74     0.25    28.85    32.91     0.00    0.04    0.13    0.04   0.02   0.00</span><br></pre></td></tr></table></figure><p>  图内指标如下：</p><p>  <img src="/系统优化-IO-运行原理和重要的指标/img1.png" alt="avator"></p><p>  这些指标中，你要注意：</p><ul><li>%util ，就是我们前面提到的磁盘 I/O 使用率；</li><li>r/s+ w/s ，就是 IOPS；</li><li>rkB/s+wkB/s ，就是吞吐量；</li><li><p>r_await+w_await ，就是响应时间。</p><p>在观测指标时，也别忘了结合请求的大小（ rareq-sz 和 wareq-sz）一起分析。你可能注意到，从 iostat 并不能直接得到磁盘饱和度。事实上，饱和度通常也没有其他简单的观测方法，不过，你可以把观测到的，平均请求队列长度或者读写请求完成的等待时间，跟基准测试的结果（比如通过 fio）进行对比，综合评估磁盘的饱和情况。</p></li></ul><h3 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h3><p>类似于top可以查看整体的io情况</p><h3 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h3><p>如果想查看进程的io情况我们要用pidstat加参数-d</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pidstat -d</span></span><br><span class="line">03:02:23 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">03:02:23 PM     0         1    145.77     25.49      0.72  systemd</span><br><span class="line">03:02:23 PM     0        30      0.00      0.00      0.00  kswapd0</span><br><span class="line"></span><br><span class="line"><span class="comment"># kB_ccwr/s 是每秒取消的写请求</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-IO-基础概念</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-IO-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>  在讲内存的时候我们提到了buffer用于加速磁盘的读写，cache用于加速文件的读写，那么磁盘和文件它们俩个的区别是什么呢？linux的文件系统的机制又是什么？</p><h2 id="磁盘和文件系统"><a href="#磁盘和文件系统" class="headerlink" title="磁盘和文件系统"></a>磁盘和文件系统</h2><ul><li>磁盘：是块设备，用于数据的持久化；</li><li><p>文件系统：在磁盘基础上提供管理文件的树状结构；</p><p>文件系统为每个文件都分配了俩种数据结构：</p></li><li><p>索引节点:【inode】记录文件的原信息，如：数据位置、修改时间、权限等</p></li><li><p>目录项：【dentry】，多个目录项组成的树状结构就是我们的文件系统，保存，父节点、子节点其他目录项的关联关系、文件名称、inode地址等信息，多个目录项组成了文件树</p><p>整个文件系统由目录项、超级块、索引块、数据块四部分组成，他们的关系如图：</p></li></ul><p><img src="/系统优化-IO-基础概念/img0.png" alt="avator"></p><p>  其中，磁盘读写的最小单位是扇区，然而扇区只有512B大小，如果每次都读写这么小的单位，效率一定很低。所以，文件系统又把连续的扇区组成了逻辑块，然后每次都以逻辑块为最小单元，来管理数据。常见的逻辑块大小为 4KB，也就是由连续的 8 个扇区组成。</p><p>  目录项是缓存在内存中。<br>  索引项是记录磁盘的信息的但是，CPU为了弥补磁盘和内存的访问差异，会将inode也缓存到内存的cache页中。</p><h2 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h2><p>  Liunx在各种文件系统的实现上定义了一层虚拟文件系统【VFS】，它定义了一组所有文件系统都支持的数据结构和标准接口。这样，用户进程和内核中的其他子系统，只需要通过VFS提供的统一接口和磁盘进行交互，而不需要再关心底层各种文件系统的实现细节。</p><ul><li>磁盘文件系统：也就是把数据直接存储在计算机本地挂载的磁盘中。常见的 Ext4、XFS、OverlayFS 等，都是这类文件系统。</li><li>内存文件系统：这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。我们经常用到的 /proc 文件系统，其实就是一种最常见的虚拟文件系统。此外，/sys 文件系统也属于这一类，主要向用户空间导出层次化的内核对象。</li><li>网络文件系统：也就是用来访问其他计算机数据的文件系统，比如 NFS、SMB、iSCSI 等</li></ul><h2 id="文件系统的I-O"><a href="#文件系统的I-O" class="headerlink" title="文件系统的I/O"></a>文件系统的I/O</h2><ul><li>是否利用标准库缓存的I/O:<strong>标准库</strong>为了加速I/O的访问效率，会实现一层缓冲，在进行系统调用，比如java里的各种BufferedStream。注意这里的缓冲是标准库实现的</li><li>是否利用内存缓存I/O:我们I/O的系统调用，默认都会用到内存的cache页和buffer页，如果采用直接I/O，在I/O操作时候要使用O_DIRECT。</li><li>阻塞和非阻塞I/O:如果是阻塞I/O是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务;是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。访问管道或者网络套接字时，设置O_NONBLOCK标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。</li><li><p>同步I/O和异步I/O:是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，响应会用事件通知的方式，告诉应用程序。</p><p>举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。<br>再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。</p></li></ul><h2 id="如何查看I-O"><a href="#如何查看I-O" class="headerlink" title="如何查看I/O"></a>如何查看I/O</h2><p>我们可以采用df命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ df -h /dev/sda1</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1        29G  3.1G   26G  11% /</span><br></pre></td></tr></table></figure><p>这里的数据是不包括inode的信息的，所以会出现一种情况，明明我们的文件系统还有很大的空间，但是却提示磁盘空间不足了，原因就在于inode是会写入磁盘的，很有可能是小文件太多inode占用了太大的空间，我们可以铜鼓df的-i参数查看inode的信息</p><p>如果想查看inode信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ df -i /dev/sda1</span><br><span class="line">Filesystem      Inodes  IUsed   IFree IUse% Mounted on</span><br><span class="line">/dev/sda1      3870720 157460 3713260    5% /</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>我们CPU为了加速I/O的性能，会将的目录项和索引节点加载到内存中，他们处于内存的内核空间由slab控制，可以通过/proc/slabinfo查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/slabinfo | grep -E <span class="string">'^#|dentry|inode'</span></span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">xfs_inode              0      0    960   17    4 : tunables    0    0    0 : slabdata      0      0      0</span><br><span class="line">...sh</span><br><span class="line">ext4_inode_cache   32104  34590   1088   15    4 : tunables    0    0    0 : slabdata   2306   2306      0hugetlbfs_inode_cache     13     13    624   13    2 : tunables    0    0    0 : slabdata      1      1      0</span><br><span class="line">sock_inode_cache    1190   1242    704   23    4 : tunables    0    0    0 : slabdata     54     54      0</span><br><span class="line">shmem_inode_cache   1622   2139    712   23    4 : tunables    0    0    0 : slabdata     93     93      0</span><br><span class="line">proc_inode_cache    3560   4080    680   12    2 : tunables    0    0    0 : slabdata    340    340      0</span><br><span class="line">inode_cache        25172  25818    608   13    2 : tunables    0    0    0 : slabdata   1986   1986      0</span><br><span class="line">dentry             76050 121296    192   21    1 : tunables    0    0    0 : slabdata   5776   5776      0</span><br></pre></td></tr></table></figure><p>主要查看inode_cache、proc_inode_cache、dentry大小。</p><p>注意我们如果用下面命令查找文件的时候因为开始没有缓存，会增加dentry、inode_cache、proc_inode_cache用量。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / --name &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> I/O </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-阶段性总结</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>本文主要是针对之前的内存方面的学习进行阶段性的总结，重点在于我们去看内存的哪些重要指标，常用工具是哪些，排查内存问题的思路。</p><h2 id="重要指标"><a href="#重要指标" class="headerlink" title="重要指标"></a>重要指标</h2><p>如下的脑图：</p><p><img src="/系统优化-内存-阶段性总结/内存性能指标.png" alt="avator"></p><p>  系统内存：</p><ul><li>已用内存和剩余内存很容易理解，就是已经使用和还未使用的内存。</li><li>剩余内存：只进程可以分配的内存。</li><li>缺页异常：系统在分配内存，会产生缺页异常，当访问到该内存地址发现异常会切换到内存完成真正的物理内存分配<ul><li>主缺页异常（majflt）:从磁盘中加载分配（Swap）</li><li>次缺页异常（minflt）:直接从内存中分配</li></ul></li><li>共享内存:通过 tmpfs 实现的，所以它的大小也就是 tmpfs 使用的内存大小。tmpfs 其实也是一种特殊的缓存。</li><li><p>缓存包括两部分，一部分是磁盘读取文件的页缓存，用来缓存从磁盘读取的数据，可以加快以后再次访问的速度。另一部分，则是 Slab 分配器中的可回收内存。</p><p>程序的内存：</p></li><li><p>VIRT:包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算作虚拟内存。</p></li><li>RSS:进程实际使用的物理内存，不过它不包括Swap和共享内存。</li><li>PSS:进程自己独自占有的+共享的/共享的数目。</li><li><p>USS:进程独自占用的物理内存（不包含共享库占用的内存）。</p><p>Swap</p></li><li><p>用量</p></li><li>换入/换出</li></ul><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>性能指标和工具的联系，如图1</p><p><img src="/系统优化-内存-阶段性总结/img0.png" alt="avator"></p><p>从性能工具出发，整理了这些常见工具能提供的内存指标。，如图2</p><p><img src="/系统优化-内存-阶段性总结/img1.png" alt="avator"></p><h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>常见的如：</p><ul><li>内存泄露：内存持续增长直至进程被Kill,可以用memleak排查，然后修改代码</li><li>Swap过高：查看用vmstat、sar、top先看换入换出的情况，然后调整swapiness或者关闭swap大内存场景建议关闭swap</li><li>buffer/cache的优化：可以用cachestat和cachetop看缓存的命中率，如果过低，去相关代码排查</li><li>内存占用过高：可以用pmap或者smap找到内存分配的地方。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-Swap机制</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-Swap%E6%9C%BA%E5%88%B6/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-Swap%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>  之前提到当linux的内存不足时候会通过oom机制来kill程序加速释放内存，除了这种方法，linux还可以在资源不足时候释放可以回收的内存。哪些是可回收的内存呢？</p><ul><li>buffer/cache：这些被成为文件页（File-backed Page）大部分文件页可以直接回收，需要了在从磁盘读取，如果系统只修改了内存还没有写入到磁盘，我们成为脏页，需要写回磁盘在就进行回收<ul><li>可以在应用程序中，通过系统调用 fsync ，把脏页同步到磁盘中；</li><li>也可以交给系统，由内核线程 pdflush 负责这些脏页的刷新；</li></ul></li><li>应用程序动态分配的内存，我们称之为匿名页（Anonymous Page），会通过Swap换入/换出的方式将内存写入到磁盘中来释放内存。</li></ul><h2 id="Swap的机制介绍"><a href="#Swap的机制介绍" class="headerlink" title="Swap的机制介绍"></a>Swap的机制介绍</h2><p>  swap将补偿访问的内存通过换入将内存数据写到磁盘中，需要了再从磁盘读取这实际上是一种用时间换空间的思想。</p><h3 id="回收方式"><a href="#回收方式" class="headerlink" title="回收方式"></a>回收方式</h3><ol><li>直接回收：大部分动态分配的内存都可以直接回收</li><li><p>kswapd0：一个专门的内核线程用来定期回收内存。为了衡量内存的使用情况，kswapd0定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（page min)，页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。这里，我画了一张图表示它们的关系。</p><p><img src="/系统优化-内存-Swap机制/img0.png" alt="avator"></p><p>kswapd0的运行机制如下：</p><p>小于pages_min:内存页耗尽<br>小于pages_low:内存页不足，kswapd0 会执行内存回收，直到剩余内存大于高阈值为止<br>小于pages_high:内存资源还可以满足申请的需求<br>大于pages_high:内存资源充足</p><p>我们可以通过修改/proc/sys/vm/min_free_kbytes来修改pages_min,其他的pages_low和pages_high都是通过pages_min计算出来的。</p></li></ol><h3 id="NUMA-与-Swap"><a href="#NUMA-与-Swap" class="headerlink" title="NUMA 与 Swap"></a>NUMA 与 Swap</h3><p>  NUMBA是（Non-Uniform Memory Access），多个cpu会被划分到不通的node中，我们可以用numbactl看到如下的情况，只有一个node,对应了0，1俩个cpu,有7977MB的内存，空余内存是4416MB。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available: 1 nodes (0)</span><br><span class="line">node 0 cpus: 0 1</span><br><span class="line">node 0 size: 7977 MB</span><br><span class="line">node 0 free: 4416 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>实际上，前面提到的三个内存阈值（页最小阈值、页低阈值和页高阈值），都可以通过内存域在 proc 文件系统中的接口 /proc/zoneinfo 来查看。比如，下面就是一个 /proc/zoneinfo 文件的内容示例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cat /proc/zoneinfo</span><br><span class="line">...</span><br><span class="line">Node 0, zone   Normal</span><br><span class="line"> pages free     227894</span><br><span class="line">       min      14896 <span class="comment">## 三个水位线</span></span><br><span class="line">       low      18620</span><br><span class="line">       high     22344</span><br><span class="line">...</span><br><span class="line"> <span class="comment">##空闲page和上面的free对应</span></span><br><span class="line">     nr_free_pages 227894</span><br><span class="line"> <span class="comment">##活跃和非活跃的匿名页数</span></span><br><span class="line">     nr_zone_inactive_anon 11082</span><br><span class="line">     nr_zone_active_anon 14024</span><br><span class="line"> <span class="comment">##活跃和非活跃的文件页数</span></span><br><span class="line">     nr_zone_inactive_file 539024</span><br><span class="line">     nr_zone_active_file 923986</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  内存资源紧张时候,默认采用回收匿名页数以及文件页数的方式来回收内存,可以通过/proc/sys/vm/zone_reclaim_mode调整</p><ul><li>默认的 0 ，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地回收内存。</li><li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据回收内存，4 表示可以用 Swap 方式回收内存。</li></ul><h3 id="swappiness"><a href="#swappiness" class="headerlink" title="swappiness"></a>swappiness</h3><p>  内存回收有俩种方式</p><ol><li>回收文件页：通过fsync将buffer和cache写入到磁盘来释放这一部分内存</li><li><p>回收匿名页：通过swap来释放匿名页内存</p><p>Linux 提供了一个 /proc/sys/vm/swappiness 选项，用来调整使用 Swap 的积极程度。范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><p>注意swappiness只是一个趋势。</p></li></ol><h3 id="案例排查"><a href="#案例排查" class="headerlink" title="案例排查"></a>案例排查</h3><p>首先确认swap开启,通过free确认，如果没开启可用下面方法开启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建Swap文件</span></span><br><span class="line">$ fallocate -l 8G /mnt/swapfile</span><br><span class="line"><span class="comment"># 修改权限只有根用户可以访问</span></span><br><span class="line">$ chmod 600 /mnt/swapfile</span><br><span class="line"><span class="comment"># 配置Swap文件</span></span><br><span class="line">$ mkswap /mnt/swapfile</span><br><span class="line"><span class="comment"># 开启Swap</span></span><br><span class="line">$ swapon /mnt/swapfile</span><br></pre></td></tr></table></figure><p>测试方案：用命令dd</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入空设备，实际上只有磁盘的读请求</span></span><br><span class="line">$ dd <span class="keyword">if</span>=/dev/sda1 of=/dev/null bs=1G count=2048</span><br></pre></td></tr></table></figure><p>这时候我们用sar -r命令观察，我们发现kbmemfree值越来越少，%memused越来越大，且kbbuffers越来越大，因为dd直接和磁盘交互，符合预期。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔1秒输出一组数据</span></span><br><span class="line"><span class="comment"># -r表示显示内存使用情况，-S表示显示Swap使用情况</span></span><br><span class="line">$ sar -r -S 1</span><br><span class="line">04:39:56    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">04:39:57      6249676   6839824   1919632     23.50    740512     67316   1691736     10.22    815156    841868         4</span><br><span class="line"></span><br><span class="line">04:39:56    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">04:39:57      8388604         0      0.00         0      0.00</span><br><span class="line"></span><br><span class="line">04:39:57    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">04:39:58      6184472   6807064   1984836     24.30    772768     67380   1691736     10.22    847932    874224        20</span><br><span class="line"></span><br><span class="line">04:39:57    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">04:39:58      8388604         0      0.00         0      0.00</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">04:44:06    kbmemfree   kbavail kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">04:44:07       152780   6525716   8016528     98.13   6530440     51316   1691736     10.22    867124   6869332         0</span><br><span class="line"></span><br><span class="line">04:44:06    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">04:44:07      8384508      4096      0.05        52      1.27</span><br></pre></td></tr></table></figure><ul><li>刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区。</li><li>一段时间后，剩余内存已经很小，而缓冲区占用了大部分内存。这时候，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动。</li></ul><p>为什么缓冲区只在小范围内波动？由哪些进程导致，这时候我们用cachetop进行进一步排查发现是dd导致的，他的READ_HIT只有50%命中率且Miss的page已经到了41022页，可见也符合我们猜测的预期。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cachetop 5</span><br><span class="line">12:28:28 Buffers MB: 6349 / Cached MB: 87 / Sort: HITS / Order: ascending</span><br><span class="line">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%</span><br><span class="line">   18280 root     python                 22        0        0     100.0%       0.0%</span><br><span class="line">   18279 root     dd                  41088    41022        0      50.0%      50.0%</span><br></pre></td></tr></table></figure><p>  为什么Swap开始升高了？不是应该释放buffer么？我们查看/proc/zoneinfo返现，内存小于low,内存就开始执行回收才做恢复到high附近，周而复始。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -d 表示高亮变化的字段</span></span><br><span class="line"><span class="comment"># -A 表示仅显示Normal行以及之后的15行输出</span></span><br><span class="line">$ watch -d grep -A 15 <span class="string">'Normal'</span> /proc/zoneinfo</span><br><span class="line">Node 0, zone   Normal</span><br><span class="line">  pages free     21328</span><br><span class="line">        min      14896</span><br><span class="line">        low      18620</span><br><span class="line">        high     22344</span><br><span class="line">        spanned  1835008</span><br><span class="line">        present  1835008</span><br><span class="line">        managed  1796710</span><br><span class="line">        protection: (0, 0, 0, 0, 0)</span><br><span class="line">      nr_free_pages 21328</span><br><span class="line">      nr_zone_inactive_anon 79776</span><br><span class="line">      nr_zone_active_anon 206854</span><br><span class="line">      nr_zone_inactive_file 918561</span><br><span class="line">      nr_zone_active_file 496695</span><br><span class="line">      nr_zone_unevictable 2251</span><br><span class="line">      nr_zone_write_pending 0</span><br></pre></td></tr></table></figure><p>我们发现有时候释放的是未知页即直接内存有时候是文件页即buffer，这是由于我们swappiness配置导致的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br><span class="line">60</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-常用的内存泄露的排查方案</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%20copy/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%20copy/</url>
      
        <content type="html"><![CDATA[<p>linux动态分配内存经常会遇到俩个问题：</p><ol><li>内存没有及时回收，发生内存泄露</li><li>访问的是已分配边界外的内存，造成内存越界</li></ol><p>这章我们来讲下内存泄露、以及排查内存泄露的方法</p><h2 id="内存分配以及回收"><a href="#内存分配以及回收" class="headerlink" title="内存分配以及回收"></a>内存分配以及回收</h2><p>我们的内存主要分为以下部分、堆、栈、只读端、数据段、内存映射段。</p><ul><li>栈：主要存放局部变量，由系统统一管理，所以不需要主动回收内存，一旦程序的作用域超过局部变量，就需要在堆中动态分配内存，在栈中的内存不会导致内存泄露</li><li>堆：程序通过malloc申请内存，除非程序退出否则申请的内存不会释放。这部分内存会导致内存泄露</li><li>只读段：保存程序的代码和常量，由于不需要继续申请内存，这部分会导致引起内存泄露</li><li>数据段：保存静态变量和全局变量，由于申请时候已经知道了大小所以也不需要释放，这部分会导致引起内存泄露</li><li><p>内存映射段：保存动态链接库和共享内存，由于共享内存的存在，</p><p>综上，堆、和内存映射段会导致内存泄露</p><p>内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用。内存泄漏不断累积，甚至会耗尽系统内存。虽然oom会Kill程序，但是在kill程序前会有很多严重的问题</p></li></ul><h2 id="如何定位内存泄露"><a href="#如何定位内存泄露" class="headerlink" title="如何定位内存泄露"></a>如何定位内存泄露</h2><p>我们可以使用bcc-tools下的memleak，如图下面就是一个简单的内存泄露场景，child会分配内存而且没有回收</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp app:/app /app</span><br><span class="line">$ /usr/share/bcc/tools/memleak -p $(pidof app) -a</span><br><span class="line">Attaching to pid 12512, Ctrl+C to quit.</span><br><span class="line">[03:00:41] Top 10 stacks with outstanding allocations:</span><br><span class="line">    addr = 7f8f70863220 size = 8192</span><br><span class="line">    addr = 7f8f70861210 size = 8192</span><br><span class="line">    addr = 7f8f7085b1e0 size = 8192</span><br><span class="line">    addr = 7f8f7085f200 size = 8192</span><br><span class="line">    addr = 7f8f7085d1f0 size = 8192</span><br><span class="line">    40960 bytes <span class="keyword">in</span> 5 allocations from stack</span><br><span class="line">        fibonacci+0x1f [app]</span><br><span class="line">        child+0x4f [app]</span><br><span class="line">        start_thread+0xdb [libpthread-2.27.so]</span><br></pre></td></tr></table></figure><p>解决后的如下面所示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新执行 memleak工具检查内存泄漏情况</span></span><br><span class="line">$ /usr/share/bcc/tools/memleak -a -p $(pidof app)</span><br><span class="line">Attaching to pid 18808, Ctrl+C to quit.</span><br><span class="line">[10:23:18] Top 10 stacks with outstanding allocations:</span><br><span class="line">[10:23:23] Top 10 stacks with outstanding allocations:</span><br></pre></td></tr></table></figure><p>由mMemleak在centos中需要内核4.1以上支持，所以在老系统中我们用到valgrind的memcheck</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> valgrind  --tool=memcheck --leak-check=summary ./xxx-api</span><br><span class="line"></span><br><span class="line"> ==20474==</span><br><span class="line">==20474== HEAP SUMMARY:</span><br><span class="line">==20474==     <span class="keyword">in</span> use at <span class="built_in">exit</span>: 4,064 bytes <span class="keyword">in</span> 8 blocks</span><br><span class="line">==20474==   total heap usage: 16 allocs, 8 frees, 4,288 bytes allocated</span><br><span class="line">==20474==</span><br><span class="line">==20474== LEAK SUMMARY:</span><br><span class="line">==20474==    definitely lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474==    indirectly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474==      possibly lost: 4,032 bytes <span class="keyword">in</span> 7 blocks</span><br><span class="line">==20474==    still reachable: 32 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==20474==         suppressed: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">==20474==</span><br><span class="line">==20474== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==20474== Use --track-origins=yes to see <span class="built_in">where</span> uninitialised values come from</span><br><span class="line">==20474== ERROR SUMMARY: 28 errors from 4 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>上面的definitely lost代表必然的内存泄露，他包括indirectly【非直接】和directly【直接俩种， possibly lost是可能的内存泄露。我们只需要查看definitely lost即可</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-常用的内存泄露的排查方案</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>linux动态分配内存经常会遇到俩个问题：</p><ol><li>内存没有及时回收，发生内存泄露</li><li>访问的是已分配边界外的内存，造成内存越界</li></ol><p>这章我们来讲下内存泄露、以及排查内存泄露的方法</p><h2 id="内存分配以及回收"><a href="#内存分配以及回收" class="headerlink" title="内存分配以及回收"></a>内存分配以及回收</h2><p>我们的内存主要分为以下部分、堆、栈、只读端、数据段、内存映射段。</p><ul><li>栈：主要存放局部变量，由系统统一管理，所以不需要主动回收内存，一旦程序的作用域超过局部变量，就需要在堆中动态分配内存，在栈中的内存不会导致内存泄露</li><li>堆：程序通过malloc申请内存，除非程序退出否则申请的内存不会释放。这部分内存会导致内存泄露</li><li>只读段：保存程序的代码和常量，由于不需要继续申请内存，这部分会导致引起内存泄露</li><li>数据段：保存静态变量和全局变量，由于申请时候已经知道了大小所以也不需要释放，这部分会导致引起内存泄露</li><li><p>内存映射段：保存动态链接库和共享内存，由于共享内存的存在，</p><p>综上，堆、和内存映射段会导致内存泄露</p><p>内存泄漏的危害非常大，这些忘记释放的内存，不仅应用程序自己不能访问，系统也不能把它们再次分配给其他应用。内存泄漏不断累积，甚至会耗尽系统内存。虽然oom会Kill程序，但是在kill程序前会有很多严重的问题</p></li></ul><h2 id="如何定位内存泄露"><a href="#如何定位内存泄露" class="headerlink" title="如何定位内存泄露"></a>如何定位内存泄露</h2><p>我们可以使用bcc-tools下的memleak，如图下面就是一个简单的内存泄露场景，child会分配内存而且没有回收</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp app:/app /app</span><br><span class="line">$ /usr/share/bcc/tools/memleak -p $(pidof app) -a</span><br><span class="line">Attaching to pid 12512, Ctrl+C to quit.</span><br><span class="line">[03:00:41] Top 10 stacks with outstanding allocations:</span><br><span class="line">    addr = 7f8f70863220 size = 8192</span><br><span class="line">    addr = 7f8f70861210 size = 8192</span><br><span class="line">    addr = 7f8f7085b1e0 size = 8192</span><br><span class="line">    addr = 7f8f7085f200 size = 8192</span><br><span class="line">    addr = 7f8f7085d1f0 size = 8192</span><br><span class="line">    40960 bytes <span class="keyword">in</span> 5 allocations from stack</span><br><span class="line">        fibonacci+0x1f [app]</span><br><span class="line">        child+0x4f [app]</span><br><span class="line">        start_thread+0xdb [libpthread-2.27.so]</span><br></pre></td></tr></table></figure><p>解决后的如下面所示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新执行 memleak工具检查内存泄漏情况</span></span><br><span class="line">$ /usr/share/bcc/tools/memleak -a -p $(pidof app)</span><br><span class="line">Attaching to pid 18808, Ctrl+C to quit.</span><br><span class="line">[10:23:18] Top 10 stacks with outstanding allocations:</span><br><span class="line">[10:23:23] Top 10 stacks with outstanding allocations:</span><br></pre></td></tr></table></figure><p>由mMemleak在centos中需要内核4.1以上支持，所以在老系统中我们用到valgrind的memcheck</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> valgrind  --tool=memcheck --leak-check=summary ./xxx-api</span><br><span class="line"></span><br><span class="line"> ==20474==</span><br><span class="line">==20474== HEAP SUMMARY:</span><br><span class="line">==20474==     <span class="keyword">in</span> use at <span class="built_in">exit</span>: 4,064 bytes <span class="keyword">in</span> 8 blocks</span><br><span class="line">==20474==   total heap usage: 16 allocs, 8 frees, 4,288 bytes allocated</span><br><span class="line">==20474==</span><br><span class="line">==20474== LEAK SUMMARY:</span><br><span class="line">==20474==    definitely lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474==    indirectly lost: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474==      possibly lost: 4,032 bytes <span class="keyword">in</span> 7 blocks</span><br><span class="line">==20474==    still reachable: 32 bytes <span class="keyword">in</span> 1 blocks</span><br><span class="line">==20474==         suppressed: 0 bytes <span class="keyword">in</span> 0 blocks</span><br><span class="line">==20474== Rerun with --leak-check=full to see details of leaked memory</span><br><span class="line">==20474==</span><br><span class="line">==20474== For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">==20474== Use --track-origins=yes to see <span class="built_in">where</span> uninitialised values come from</span><br><span class="line">==20474== ERROR SUMMARY: 28 errors from 4 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure><p>上面的definitely lost代表必然的内存泄露，他包括indirectly【非直接】和directly【直接俩种， possibly lost是可能的内存泄露。我们只需要查看definitely lost即可</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-通过优化buffer和cache来优化程序</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E9%80%9A%E8%BF%87%E4%BC%98%E5%8C%96buffer%E5%92%8Ccache%E6%9D%A5%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E9%80%9A%E8%BF%87%E4%BC%98%E5%8C%96buffer%E5%92%8Ccache%E6%9D%A5%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>Buffer:是优化磁盘的读写</li><li><p>Cache:是优化文件的读写</p><p>我们的程序可以通过优化Buffer和Cache来提高我们程序的运行效率。所谓工欲善其事必先利其器，我们下面介绍下如何去看我们内存的cache情况。</p></li></ul><h2 id="指标和工具"><a href="#指标和工具" class="headerlink" title="指标和工具"></a>指标和工具</h2><p>  查看cache的命中情况我们主要会去查看cache的命中率。我们可以使用bcc-tools下的cachestat和cachetop</p><ul><li>cachestat:统计整体内存的cache情况</li><li>cachetop:统计进程的内存cache情况</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cachestat 1 3</span><br><span class="line">   TOTAL   MISSES     HITS  DIRTIES   BUFFERS_MB  CACHED_MB</span><br><span class="line">       2        0        2        1           17        279</span><br><span class="line">       2        0        2        1           17        279</span><br><span class="line">       2        0        2        1           17        279</span><br></pre></td></tr></table></figure><ul><li>TOTAL:表示总的 I/O 次数</li><li>MISSES:缓存未命中</li><li>HITS:缓存命中</li><li>DIRTIES:脏页</li><li>BUFFERS_MB:buffer的数据</li><li>CACHED_MB:cache的数据</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cachetop</span><br><span class="line">11:58:50 Buffers MB: 258 / Cached MB: 347 / Sort: HITS / Order: ascending</span><br><span class="line">PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%</span><br><span class="line">   13029 root     python                  1        0        0     100.0%       0.0%</span><br></pre></td></tr></table></figure><p>  它的输出跟 top 类似，默认按照缓存的命中次数（HITS）排序，展示了每个进程的缓存命中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES ，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存命中次数、未命中次数以及新增到缓存中的脏页数。而 READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率。</p><p>  还有一个缓存数据的大小的指标我们一般也会很关心，我们可以通过go语言写的pcstat查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ pcstat /bin/ls</span><br><span class="line">+---------+----------------+------------+-----------+---------+</span><br><span class="line">| Name    | Size (bytes)   | Pages      | Cached    | Percent |</span><br><span class="line">|---------+----------------+------------+-----------+---------|</span><br><span class="line">| /bin/ls | 133792         | 33         | 0         | 000.000 |</span><br><span class="line">+---------+----------------+------------+-----------+---------+</span><br></pre></td></tr></table></figure><p>这个就是/bin/ls的缓存情况</p><h2 id="查找问题思路"><a href="#查找问题思路" class="headerlink" title="查找问题思路"></a>查找问题思路</h2><p>我们通过cachetop找到问题的缓存命中率情况，有一种情况缓存命中率很高。但是缓存命中的数据很少【计算方式，HITS命中数*4k,因为缓存死以page为单位存的以page为4k】</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-内存的Buffer和Cache</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%86%85%E5%AD%98%E7%9A%84Buffer%E5%92%8CCache/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-%E5%86%85%E5%AD%98%E7%9A%84Buffer%E5%92%8CCache/</url>
      
        <content type="html"><![CDATA[<p>我们用free去查看内存</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            251          70         152           2          27         171</span><br><span class="line">Swap:           135          17         118</span><br></pre></td></tr></table></figure><p>  我们可以看到Mem和Swap的场景。今天我们主要聊下buff和cache这俩个指标，它俩分别代表什么呢？他们来源于哪里呢</p><p>  来源：/proc/meminfo,我们可以通过man free来看到下面的说明</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buffers</span><br><span class="line">       Memory used by kernel buffers (Buffers <span class="keyword">in</span> /proc/meminfo)</span><br><span class="line"></span><br><span class="line">cache  Memory used by the page cache and slabs (Cached and Slab <span class="keyword">in</span> /proc/meminfo)</span><br><span class="line"></span><br><span class="line">buff/cache</span><br><span class="line">       Sum of buffers and cache</span><br></pre></td></tr></table></figure><ul><li>buffers对应的/proc/meminfo的buffers值</li><li><p>cache对应的是/proc/meminfo的Cached值，和SReclaimable值</p><p>它们分别是</p></li><li><p>Buffers 是对原始磁盘块的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写合并成单次大的写等等。</p></li><li>Cached 是从磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li><li><p>SReclaimable 是 Slab 的一部分。Slab 包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</p><p>buffer：主要针对磁盘操作，对磁盘的读、写都会影响buffer。<br>cache：主要针对文件操作，对磁盘的读、写都会影响cache。</p><p>注意：</p></li><li><p>关于磁盘和文件的区别，磁盘是一个块设备，可以划分为不同的分区；</p></li><li>在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-内存-Linux内存工作原理</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-Linux%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-%E5%86%85%E5%AD%98-Linux%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>  日常生活中我们常提起的内存主要指物理内存，又称为主存。一般指DRAM。linux的进程出于系统保护的目的不能直接访问物理能存，而是为每一个进程开辟了一块虚拟内存，它的地址是连续的，进程可以很方便的访问内存。</p><p>  虚拟内存又分为用户空间和内核空间。</p><ul><li>32位系统中虚拟内存最大支持4gb，系统空间大小是1gb占虚拟内存的高位，用户空间大小是0~3gb占虚拟内存的低位</li><li><p>64位操作系统则是内核空间大小是128T占虚拟内存的高位，中间是未定义，用户空间大小是128T占虚拟内存的低位</p><p>如图：<br><img src="/系统优化-内存-Linux内存工作原理/img1.png" alt="avator"></p><p>进程处于用户态只能访问虚拟内存的用户空间，比如程序的赋值等简单操作，当进程处于内核态时才能操作虚拟内存的内核空间。</p></li></ul><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>  这样如果所有的进程的虚拟内存加起来可能会远远大于物理内存，而linux实际上并不是给所有的虚拟内存分配物理内存，只会在进程需要时候才会分配物理内存。并且分配后的物理内存是通过内存映射来管理的。</p><p>  由于进程不能直接操作物理内存，所以每一个进程就会持有一个内存页，用来维护虚拟内存和物理内存的映射关系，可以很方便的操作物理内存。这些内存页被保存在CPU的MMU模块中，CPU可以通过MMU模块来访问进程需要的内存。如图：</p><p>  <img src="/系统优化-内存-Linux内存工作原理/img2.png" alt="avator"></p><p>  注意：由于分配虚拟内存的进程并不会直接去分配物理内存，而是MMU发现没有找到内存的物理地址时候出现缺页异常，这时候进程会切换到内核态分配内存，再刷新MMU和内存页返回到用户态继续执行用户程序。</p><p>  MMU的单位是4KB成为PTE（page table entity），每一次内存映射，都需要关联4KB或者4KB整数倍的内存空间。这样有个问题，会需要大量的页表项比如一个4gb的内存就要100万个PTE。一般用多级表和大表来解决。多级表实际上就是索引的概念，linux采用4级表来解决。</p><p>  <img src="/系统优化-内存-Linux内存工作原理/img3.png" alt="avator"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>  内核空间我们暂不讨论，用户空间分为</p><p>  <img src="/系统优化-内存-Linux内存工作原理/img4.png" alt="avator"></p><ol><li>只读段，包括代码和常量等。</li><li>数据段，包括全局变量等。</li><li>堆，包括动态分配的内存，从低地址开始向上增长。</li><li>文件映射段，包括动态库、共享内存等，从高地址开始向下增长。</li><li>栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB</li></ol><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><ol><li>对于小于（128k）的内存采用brk()来分配，通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。优点：不会立刻归还系统可以重复利用，缺点：频繁申请、释放会造成内存碎片</li><li>对于大于（128k）的内存采用mmap()来分配，则直接使用内存映射 mmap() 来分配，也就是在文件映射段找一块空闲内存分配出去。优点：减少磁盘碎片。缺点：释放归还系统所以频繁出现缺页异常增大系统负担</li></ol><p>对内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽系统内存。所以，在应用程序用完内存后，还需要调用 free() 或 unmap() ，来释放这些不用的内存。当然，系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：</p><ol><li>回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；</li><li>回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；</li><li><p>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。</p><p>可以通过以下文件调整oom的权重，越大越容易杀死</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -16 &gt; /proc/$(pidof sshd)/oom_adj</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何查看内存使用"><a href="#如何查看内存使用" class="headerlink" title="如何查看内存使用"></a>如何查看内存使用</h2><p>  Swap，资源紧张时候Linux会将内存数据映射到磁盘上，这种情况会严重的影响系统性能，要尽量避免。</p><p>  top or  ps：主要查看VIRT-虚拟内存 RES–常驻内存 SHR–共享内存 SWAP–文件交换区  %MEM–使用率</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-阶段性总结</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h2><p>  首先我们判断CPU的问题应该先看CPU使用率【CPU的idel也行】，和其类似的还有CPU的平均负载,使用率表示的是瞬时状态，平均负载表示的是趋势。<br>  查看的工具我们可以用top、uptime、vmstat等</p><p>  常见的几个指标：</p><ul><li>user+ni过高一般我们去优化程序</li><li>sy过高有可能是cpu内核线程调度出问题</li><li>iowait高有可能是硬件除了问题。</li><li>软中断和硬中断高，通常说明系统发生了大量的中断。</li></ul><p>具体哪些指标见下图：</p><p><img src="/系统优化-CPU-阶段性总结/cpu-summary-1.png" alt="avator"></p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p><img src="/系统优化-CPU-阶段性总结/cpu-summary-2.png" alt="avator"></p><p><img src="/系统优化-CPU-阶段性总结/cpu-summary-3.png" alt="avator"></p><h2 id="排查问题路径"><a href="#排查问题路径" class="headerlink" title="排查问题路径"></a>排查问题路径</h2><p><img src="/系统优化-CPU-阶段性总结/cpu-summary-4.png" alt="avator"></p><h2 id="性能优化的经典"><a href="#性能优化的经典" class="headerlink" title="性能优化的经典"></a>性能优化的经典</h2><p><img src="/系统优化-CPU-阶段性总结/cpu-tools.png" alt="avator"></p><p>性能之巅：<a href="https://book.douban.com/subject/26586598/" target="_blank" rel="noopener">https://book.douban.com/subject/26586598/</a></p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-软中断以及软中断过多带来的危害</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E8%BD%AF%E4%B8%AD%E6%96%AD%E4%BB%A5%E5%8F%8A%E8%BD%AF%E4%B8%AD%E6%96%AD%E8%BF%87%E5%A4%9A%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8D%B1%E5%AE%B3/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E8%BD%AF%E4%B8%AD%E6%96%AD%E4%BB%A5%E5%8F%8A%E8%BD%AF%E4%B8%AD%E6%96%AD%E8%BF%87%E5%A4%9A%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%8D%B1%E5%AE%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是软中断"><a href="#什么是软中断" class="headerlink" title="什么是软中断"></a>什么是软中断</h2><p>  因为响应硬件的事件优先级高于我们正在运行的进程，所以CPU为了响应硬件，需要中断正在运行的进程。这个中断就是我们今天要讨论的中断。</p><p>  当cpu响应中断的时候回临时关闭中断，也就是说其他的中断都需要响应完现有的中断才行，这时候就会出现中断丢失或者中断延迟比较大的现象，那linux是如何解决的呢？</p><p>  linux将中断变为上下俩部分</p><p>  -上部分：主要处理响应和硬件相关的事件，它会关闭中断响应，特点是速度很快，处理完毕后会发送软中断信号，我们称他为硬中断；<br>  -下部分：根据中断的类型处理具体的事件逻辑，它由内核线程负责，在Linux中，每个CPU都对应一个软中断内核线程，名字是ksoftirqd/【CPU编号】，处理硬中断中的数据然后发送给需要的用户线程，我们称他为软中断，特点是延迟执行。</p><h2 id="软中断的类型"><a href="#软中断的类型" class="headerlink" title="软中断的类型"></a>软中断的类型</h2><p>我们可以通过查看/proc/softirqs来看各cpu的中断情况，由于软中断是内核线程所以在top中我们看到的软中断进程是[ksoftirqd/0]这样的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:     811613    1972736</span><br><span class="line">      NET_TX:         49          7</span><br><span class="line">      NET_RX:    1136736    1506885</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     304787       3691</span><br><span class="line">       SCHED:     689718    1897539</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1330771    1354737</span><br></pre></td></tr></table></figure><p>一般来讲每种软中断应该在各cpu上运行的次数差不多，但是TASKLET例外，它是最常用的软中断实现机制，每次运行一次就会推出，且只在调用它的cpu上运行。</p><h2 id="软中断带来的CPU使用率够高的性能问题"><a href="#软中断带来的CPU使用率够高的性能问题" class="headerlink" title="软中断带来的CPU使用率够高的性能问题"></a>软中断带来的CPU使用率够高的性能问题</h2><h3 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h3><ul><li>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报告历史统计数据。</li><li>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙测试等。</li><li><p>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</p><p>测试的方案</p></li></ul><ol><li>我们准备一个nginx的容器</li><li><p>我们通过hping3来模拟对nginx的SYNC_FLOOD攻击。</p><p>现象：系统的吞吐会降低，响应变慢，用top查看结果发现cpu占用不高，但是都用在软中断上，我们可以去查看软中断。</p></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#watch可以查看变化并且-d可以看到变化的数据</span></span><br><span class="line">$ watch -d cat /proc/softirqs</span><br><span class="line">                    CPU0       CPU1</span><br><span class="line">          HI:          0          0</span><br><span class="line">       TIMER:    1083906    2368646</span><br><span class="line">      NET_TX:         53          9</span><br><span class="line">      NET_RX:    1550643    1916776</span><br><span class="line">       BLOCK:          0          0</span><br><span class="line">    IRQ_POLL:          0          0</span><br><span class="line">     TASKLET:     333637       3930</span><br><span class="line">       SCHED:     963675    2293171</span><br><span class="line">     HRTIMER:          0          0</span><br><span class="line">         RCU:    1542111    1590625</span><br></pre></td></tr></table></figure><p> 发现NET_RX变化很快，初步判断是网络引发用sar来看下玩过的情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -n DEV 表示显示网络收发的报告，间隔1秒输出一组数据</span></span><br><span class="line">$ sar -n DEV 1</span><br><span class="line">15:03:46        IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line">15:03:47         eth0  12607.00   6304.00    664.86    358.11      0.00      0.00      0.00      0.01</span><br><span class="line">15:03:47      docker0   6302.00  12604.00    270.79    664.66      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47           lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00</span><br><span class="line">15:03:47    veth9f6bbcd   6302.00  12604.00    356.95    664.66      0.00      0.00      0.00      0.05</span><br></pre></td></tr></table></figure><ul><li>第一列：表示报告的时间。</li><li>第二列：IFACE 表示网卡。</li><li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li><li>第五、六列：rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。后面的其他参数基本接近 0，显然跟今天的问题没有直接关系，你可以先忽略掉。</li></ul><p>eth0这个网卡接收远大于发送，查看报文的大小，664*1024/12607=54字节，这是一个小包。</p><p>我们用tcpdump抓包</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -i eth0 只抓取eth0网卡，-n不解析协议名和主机名</span></span><br><span class="line"><span class="comment"># tcp port 80表示只抓取tcp协议并且端口号为80的网络帧</span></span><br><span class="line">$ tcpdump -i eth0 -n tcp port 80</span><br><span class="line">15:11:32.678966 IP 192.168.0.2.18238 &gt; 192.168.0.30.80: Flags [S], seq 458303614, win 512, length 0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>从 tcpdump 的输出中，你可以发现192.168.0.2.18238 &gt; 192.168.0.30.80 ，表示网络帧从 192.168.0.2 的 18238 端口发送到 192.168.0.30 的 80 端口，也就是从运行 hping3 机器的 18238 端口发送网络帧，目的为 Nginx 所在机器的 80 端口。</li><li>Flags [S] 则表示这是一个 SYN 包。再加上前面用 sar 发现的， PPS 超过 12000 的现象，现在我们可以确认，这就是从 192.168.0.2 这个地址发送过来的 SYN FLOOD 攻击。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-排查僵尸进程和io问题</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E6%8E%92%E6%9F%A5%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8Cio/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E6%8E%92%E6%9F%A5%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8Cio/</url>
      
        <content type="html"><![CDATA[<p>我们的系统如果遇到io问题和过多僵尸进程的排查思路</p><h2 id="io问题"><a href="#io问题" class="headerlink" title="io问题"></a>io问题</h2><p> 老规矩用top查看系统的进程，如果发现cpu很高但是user,sys,nic等指标不高，但是wa很高，说明可能存在了io问题<br> 我们可以采用新的工具dstat,他可以同时查看cpu和io问题</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 间隔1秒输出10组数据</span></span><br><span class="line">$ dstat 1 10</span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">--total-cpu-usage-- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai stl| <span class="built_in">read</span>  writ| recv  send|  <span class="keyword">in</span>   out | int   csw</span><br><span class="line">  0   0  96   4   0|1219k  408k|   0     0 |   0     0 |  42   885</span><br><span class="line">  0   0   2  98   0|  34M    0 | 198B  790B|   0     0 |  42   138</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  42   135</span><br><span class="line">  0   0  84  16   0|5633k    0 |  66B  342B|   0     0 |  52   177</span><br><span class="line">  0   3  39  58   0|  22M    0 |  66B  342B|   0     0 |  43   144</span><br><span class="line">  0   0   0 100   0|  34M    0 | 200B  450B|   0     0 |  46   147</span><br><span class="line">  0   0   2  98   0|  34M    0 |  66B  342B|   0     0 |  45   134</span><br><span class="line">  0   0   0 100   0|  34M    0 |  66B  342B|   0     0 |  39   131</span><br><span class="line">  0   0  83  17   0|5633k    0 |  66B  342B|   0     0 |  46   168</span><br><span class="line">  0   3  39  59   0|  22M    0 |  66B  342B|   0     0 |  37   134</span><br></pre></td></tr></table></figure><p>图中所示，idl掉的时候都是read升高。于此我们判断io出现问题，通过perf和pidstat工具进一步排查</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 间隔 1 秒输出多组数据 (这里是 20 组)</span></span><br><span class="line">$ pidstat -d 1 20</span><br><span class="line">...</span><br><span class="line">06:48:46      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:47        0      4615      0.00      0.00      0.00       1  kworker/u4:1</span><br><span class="line">06:48:47        0      6080  32768.00      0.00      0.00     170  app</span><br><span class="line">06:48:47        0      6081  32768.00      0.00      0.00     184  app</span><br><span class="line"></span><br><span class="line">06:48:47      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:48        0      6080      0.00      0.00      0.00     110  app</span><br><span class="line"></span><br><span class="line">06:48:48      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:49        0      6081      0.00      0.00      0.00     191  app</span><br><span class="line"></span><br><span class="line">06:48:49      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line"></span><br><span class="line">06:48:50      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:51        0      6082  32768.00      0.00      0.00       0  app</span><br><span class="line">06:48:51        0      6083  32768.00      0.00      0.00       0  app</span><br><span class="line"></span><br><span class="line">06:48:51      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:52        0      6082  32768.00      0.00      0.00     184  app</span><br><span class="line">06:48:52        0      6083  32768.00      0.00      0.00     175  app</span><br><span class="line"></span><br><span class="line">06:48:52      UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s iodelay  Command</span><br><span class="line">06:48:53        0      6083      0.00      0.00      0.00     105  app</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  看到app没次有32MB的数据的读取</p><p>  然后同过perf top去查看代码</p><h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><p>首先通过top看进程状态我们常见的几种状态</p><ul><li>R:Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。</li><li>D:Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。</li><li>Z:是Zombie 的缩写，表示进程已经结束但是父进程还没有回收它</li><li>S:是Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。</li><li>I:是 Idle 的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上，不会引起某些负载的升高。</li><li>T:也就是 Stopped 或 Traced 的缩写，表示进程处于暂停或者跟踪状态。</li><li><p>X:进程消亡，top不会出现。</p><p>我们系统应该尽量避免Z出现，Zombie是如何产生的？如果系统出现了大量的Zombie我们该如何排查？</p></li></ul><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>正常情况下，当一个进程创建了子进程后，它应该通过系统调用 <strong>wait() 或者 waitpid()</strong> 等待子进程结束，回收子进程的资源；而子进程在结束时，会向它的父进程发送 SIGCHLD 信号，所以，父进程还可以注册 <strong>SIGCHLD</strong> 信号的处理函数，异步回收资源。如果一个子进程被销毁父进程还没来得及对子进程进行回收就会出现Zombie。短暂的Zombie是没问题的，但是大量的Zombie进程我们就需要关注了。</p><h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><p>通过pstree查看僵尸进程的父进程,比如下面的4009进程，然后去查看4009的程序代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># -a 表示输出命令行选项</span><br><span class="line"># p表PID</span><br><span class="line"># s表示指定进程的父进程</span><br><span class="line">$ pstree -aps <span class="number">3084</span></span><br><span class="line">systemd,<span class="number">1</span></span><br><span class="line">  └─dockerd,<span class="number">15006</span> -H fd:<span class="comment">//</span></span><br><span class="line">      └─docker-containe,<span class="number">15024</span> --config /<span class="keyword">var</span>/run/docker/containerd/containerd.toml</span><br><span class="line">          └─docker-containe,<span class="number">3991</span> -namespace moby -workdir...</span><br><span class="line">              └─app,<span class="number">4009</span></span><br><span class="line">                  └─(app,<span class="number">3084</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-排查短时进程的工具</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E6%8E%92%E6%9F%A5%E7%9F%AD%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E6%8E%92%E6%9F%A5%E7%9F%AD%E6%97%B6%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>  我们在排查问题时候并不一定能找到引起CPU升高的“罪魁祸首”，他们可能隐藏在一些进程的子进程中。这时候的排查思路就是</p><p>  top看哪些是进场活跃的进程，然后看这些进程的pid是否一直存在，如果他是不停的在变化的说明可能又以下俩种情况</p><ol><li>短时进程：频繁的创建、销毁</li><li>创建的过程中出现错误会被销毁，</li></ol><h2 id="查看问题"><a href="#查看问题" class="headerlink" title="查看问题"></a>查看问题</h2><p>  对于短时进程可以通过pstree</p><p>  我们通过perf top分析找到问题所在，在通过grep ‘xxx’ -r ./app 查看源代码找到结果取修改。</p><h2 id="execsnoop工具"><a href="#execsnoop工具" class="headerlink" title="execsnoop工具"></a>execsnoop工具</h2><ol><li>cd /usr/bin</li><li>wget <a href="https://raw.githubusercontent.com/brendangregg/perf-tools/master/execsnoop" target="_blank" rel="noopener">https://raw.githubusercontent.com/brendangregg/perf-tools/master/execsnoop</a></li><li>chmod 755 execsnoop</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 按 Ctrl+C 结束</span></span><br><span class="line">$ execsnoop</span><br><span class="line">PCOMM            PID    PPID   RET ARGS</span><br><span class="line">sh               30394  30393    0</span><br><span class="line">stress           30396  30394    0 /usr/<span class="built_in">local</span>/bin/stress -t 1 -d 1</span><br><span class="line">sh               30398  30393    0</span><br><span class="line">stress           30399  30398    0 /usr/<span class="built_in">local</span>/bin/stress -t 1 -d 1</span><br><span class="line">sh               30402  30400    0</span><br><span class="line">stress           30403  30402    0 /usr/<span class="built_in">local</span>/bin/stress -t 1 -d 1</span><br><span class="line">sh               30405  30393    0</span><br><span class="line">stress           30407  30405    0 /usr/<span class="built_in">local</span>/bin/stress -t 1 -d 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次堆外内存泄露的排查</title>
      <link href="%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5/"/>
      <url>%E4%B8%80%E6%AC%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们的一个后端java服务，采用的jetty+spring，堆内存1个g,但是一运行很快内存会占到4个g，启动参数以及top见下图：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true -DappName=uapi -server -Xms1g -Xmx1g -XX:SurvivorRatio=8 -Xss256k -XX:ReservedCodeCacheSize=64m -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:+CMSScavengeBeforeRemark -XX:+UseFastAccessorMethods -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=80 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC -XX:+PrintTenuringDistribution -Xloggc:./gc.logs -jar xxx.jar &gt; nohup.txt 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p><img src="/一次堆外内存泄露的排查/img1.png" alt="avator"></p><h2 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h2><p>jmap分析结果如下，堆和新生代没有异常，排除法判断是堆外内存导致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap $pid</span><br></pre></td></tr></table></figure><p><img src="/一次堆外内存泄露的排查/img2.png" alt="avator"></p><p>持续观察一段时间后,通过top发现RES没有继续升高整体稳定在4g左右，猜测不是内存泄露而是某些程序通过堆外内存生成了一些buffer。所以想看下内存都在干嘛。</p><h3 id="排查问题步骤：观察内存"><a href="#排查问题步骤：观察内存" class="headerlink" title="排查问题步骤：观察内存"></a>排查问题步骤：观察内存</h3><p>  先用pmap查看内存情况，发现有很多奇怪的64MB的空间。结果和命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmap -x <span class="variable">$pid</span></span><br></pre></td></tr></table></figure><p><img src="/一次堆外内存泄露的排查/img2-1.png" alt="avator"></p><p>  问题预估：进过查看资料以及和同事沟通，怀疑是glibc组件的ptmalloc的arena机制导致的：</p><ul><li>当一个线程调用malloc申请内存时候,会先查看自己是否有一个分配去，如果有加锁，加锁失败，去环形链表找一个未加锁的分配区，如果没找到，malloc会开辟一个新的分配区加入环形链表并加锁，用它来分配内存。</li><li>这种机制在多线程竞争锁激烈的场景下会带来一个问题：非主分配区开辟越来越多，因为它一旦开辟了就不会释放，一个分配区就是64MB。这样也会导致进程占用的内存越来越多（可能实际使用的并不多）。如果系统配置的ulimit进程最大虚拟内存值不是unlimited，那么当进程占用的内存达到ulimit值，就会core掉。这个情况也可以在pmap -p pid中看到里面有大量的64MB大小的anon内存块。这个问题可以通过设置MALLOC_ARENA_MAX环境变量来限制Arena的最大数量规避。</li><li><p>经过后面的gperf排查发现我们的代码中有GZipInputStream在创建对象时候底层的Java_java_util_zip_Inflater_init方法确实是调用了mallloc。</p><p>所以，这其实不是内存泄露而是内存空洞的现象，在我们的系统资源捉襟见肘时候就比较致命。</p></li></ul><h3 id="排查问题步骤：dump内存"><a href="#排查问题步骤：dump内存" class="headerlink" title="排查问题步骤：dump内存"></a>排查问题步骤：dump内存</h3><p>  查看/proc/$pid/smaps 查看进程内存的使用情况发现进程大量申请了64MB的空间。【怀疑是glibc在2.10引入的arena引起的，需要后续深入研究】</p><p>  通过gdb dump出内存来查看；【具体命令见下方】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb attach &lt;pid&gt;</span><br><span class="line">dump memory outfile.txt startAddreess endAddress</span><br><span class="line"><span class="meta">#</span><span class="bash">  其中startAddreess endAddress在上面的smaps中都有</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看内存</span></span><br><span class="line">strings outfile.txt</span><br></pre></td></tr></table></figure><p>  注意：生产环境慎用，gdb会阻塞进程。</p><p>  这些64MB的很多内存是空的，总共加起来差不多有2.5g，算上我们分配的堆内存空间差不多正好4个G，大概原因找到了：由于频繁的调用系统malloc:os申请内存没有回收。查阅文章，可以试着用tcmalloc来解决遂开始安装tcmalloc，并且用gperf分析具体的调用</p><h3 id="排查问题步骤：安装tcmalloct和gperf"><a href="#排查问题步骤：安装tcmalloct和gperf" class="headerlink" title="排查问题步骤：安装tcmalloct和gperf"></a>排查问题步骤：安装tcmalloct和gperf</h3><h4 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1.安装环境"></a>1.安装环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc gcc-c++</span><br></pre></td></tr></table></figure><h4 id="2-安装libunwind"><a href="#2-安装libunwind" class="headerlink" title="2.安装libunwind"></a>2.安装libunwind</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget  http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99.tar.gz</span><br><span class="line">tar -xzvf libunwind-0.99.tar.gz</span><br><span class="line">cd libunwind-0.99</span><br><span class="line">./configure  --prefix=/usr/local/google-perftools/libunwind</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="3-安装gperftools"><a href="#3-安装gperftools" class="headerlink" title="3.安装gperftools"></a>3.安装gperftools</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.5/gperftools-2.5.tar.gz</span><br><span class="line">tar -xzvf gperftools-2.5.tar.gz</span><br><span class="line">cd gperftools-2.5</span><br><span class="line">./configure --prefix=/usr/local/google-perftools/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h4 id="4-使配置生效"><a href="#4-使配置生效" class="headerlink" title="4.使配置生效"></a>4.使配置生效</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ld.so.conf.d/usr_local_lib.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新增以下内容</span></span><br><span class="line">/usr/local/google-perftools/libunwind/lib</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按esc再:wq! <span class="comment">#保存退出</span></span></span><br><span class="line"></span><br><span class="line">/sbin/ldconfig  #执行此命令，使libunwind生效。 需要sudo权限</span><br></pre></td></tr></table></figure><h4 id="5-加入环境变量"><a href="#5-加入环境变量" class="headerlink" title="5.加入环境变量"></a>5.加入环境变量</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LD_PRELOAD=/usr/local/google-perftools/lib/libtcmalloc.so</span><br><span class="line">export HEAPPROFILE=/usr/local/gperftools/tmp/gzip</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#注意 mkdir -p /usr/local/gperftools/tmp</span></span></span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>通过top查看进程</p><p>之前的进程 top结果 RES 3.3g<br><img src="/一次堆外内存泄露的排查/img3.png" alt="avator"></p><p>之后的进程 top结果 RES 1.8g<br><img src="/一次堆外内存泄露的排查/img3-1.png" alt="avator"></p><p>我们这时候再用pmap去看进程，64MB的内存那块消失</p><p><img src="/一次堆外内存泄露的排查/img3-2.png" alt="avator"></p><h3 id="用pperf查看内存"><a href="#用pperf查看内存" class="headerlink" title="用pperf查看内存"></a>用pperf查看内存</h3><p>上面的环境变量生效后运行java就会生成heap的快照地址在见上面<strong>HEAPPROFILE</strong>的设置</p><p>用下面的命令处理heap的快照</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/gperftools/tmp/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看heap信息</span></span><br><span class="line">/usr/local/gperftools-2.5/bin/pprof --text $JAVA_HOME/bin/java /usr/local/gperftools/tmp/gzip_618.0057.heap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">导出pdf</span></span><br><span class="line">/usr/local/gperftools-2.5/bin/pprof --pdf $JAVA_HOME/bin/java /usr/local/gperftools/tmp/gzip_618.0057.heap &gt;gzip_618.0057.pdf</span><br></pre></td></tr></table></figure><p>pdf的文件如下</p><p><img src="/一次堆外内存泄露的排查/img4.png" alt="avator"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>原因：glibc的ptmalloc的arana机制会在并发情况下额外申请很多64MB内存空间，这部分空间不会回收的会重复利用。因为服务的线程数一定所以一般来讲不会出现泄漏，而是内存空洞问题。系统资源不足进程就会被kill</li><li>解决方案：<ul><li>ptmalloc取代tcmalloc。</li><li>减少堆大小。</li></ul></li></ul><h2 id="附录：压测记录"><a href="#附录：压测记录" class="headerlink" title="附录：压测记录"></a>附录：压测记录</h2><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>  对服务进行压测，压倒系统出现瓶颈无法在继续给出压力为止，这时候观测系统的参数。*本次压测主要模拟在系统不通负载的运行中内存的使用情况，cpu的占用以及系统瓶颈仅作为参考</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>  下图是在aapi测试时候的监控图：</p><p>  <img src="/一次堆外内存泄露的排查/yc-1.png" alt="avator"></p><ul><li>在100QPS下aapi系统出现瓶颈，已经无法继续增加压力，这时候，可以看出100QPS的场景下cpu的波动很大，但是内存增长在合理范围内。</li><li>系统空转后java进程内存逐渐落回1.6G</li></ul><h4 id="docker内部"><a href="#docker内部" class="headerlink" title="docker内部"></a>docker内部</h4><p>top图</p><p>  <img src="/一次堆外内存泄露的排查/yc-2.png" alt="avator"></p><p>pidstat -w -p &lt;$pid&gt; 1，上下文切换始终正常</p><p>  <img src="/一次堆外内存泄露的排查/yc-3.png" alt="avator"></p><p>pidstat -u -p &lt;$pid&gt; 1 cpu的使用率</p><p>  <img src="/一次堆外内存泄露的排查/yc-4.png" alt="avator"></p><p>压力主要在user%和system%，代表程序和内核态的调度。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 内存泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-如何排查CPU使用率到100%</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%88%B0100/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E5%88%B0100/</url>
      
        <content type="html"><![CDATA[<p>我们如何去查看CPU的使用率呢？CPU使用率中的几个重要指标分别代表什么？</p><h2 id="CPU使用率相关的概念介绍"><a href="#CPU使用率相关的概念介绍" class="headerlink" title="CPU使用率相关的概念介绍"></a>CPU使用率相关的概念介绍</h2><p>  我们多核的CPU为了能“并行”运行我们的程序，我们需要为每个进程分配执行时间，执行时间到了我们会进行一次中断，中断的频率我们定义为hz，其中内核态的中断我们可以设置，一般是100，250，1000hz，表示秒中断多少次，我们的用户态是没法直接控制hz的。用户态则规定为100HZ，也就是10ms。我们查看CPU的指标的单位就是10ms。</p><p>  我们可以通过查看/proc/cpu/stat来看cpu的指标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/cpu/stat|grep ^cpu</span><br><span class="line"></span><br><span class="line">cpu 280580 7407 286084 172900810 83602 0 583 0 0 0</span><br><span class="line">cpu0 144745 4181 176701 86423902 52076 0 301 0 0 0</span><br><span class="line">cpu1 135834 3226 109383 86476907 31525 0 282 0 0 0</span><br><span class="line"></span><br><span class="line">man /proc/stat</span><br><span class="line"><span class="meta">#</span><span class="bash">kernel/system statistics.  Varies with architecture.  Common entries include:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                    The amount of time, measured <span class="keyword">in</span> units of USER_HZ (1/100ths of a second on most architectures, use sysconf(_SC_CLK_TCK) to obtain the right value), that the system spent <span class="keyword">in</span> various states:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">                     Number of processes <span class="keyword">in</span> runnable state.  (Linux 2.5.45 onward.)</span></span><br></pre></td></tr></table></figure><p>  其中几个重要指标</p><ul><li>user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。</li><li>nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越</li><li>system（通常缩写为 sys），代表内核态 CPU 时间。</li><li>idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。</li><li>iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。</li><li>irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。</li><li>softirq（通常缩写为 si），代表处理软中断的 CPU 时间。</li><li>steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。</li><li>guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。</li><li><p>guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。</p><p>我们还可以通过/proc/$pid/stat看某个进程的cpu使用情况，但是这些都是开机到现在的历史时间。其实是没有参考价值的，我们应该看一段时间内的cpu使用情况，我们一般采用以下2个方法看</p></li></ul><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>按1查看每个cpu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cpu(s): 10.2%us,  5.8%sy,  0.0%ni, 83.2%id,  0.0%wa,  0.0%hi,  0.8%si,  0.0%st</span><br></pre></td></tr></table></figure><h2 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pid -u 5 1</span><br><span class="line"></span><br><span class="line">Linux 3.10.0-514.16.1.es01.x86_64 (xxxxx.xxx)   04/22/2020      _x86_64_        (40 CPU)</span><br><span class="line"></span><br><span class="line">01:58:07 PM       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">01:58:12 PM       354    0.00    1.20    0.00    1.20    10  xxxxx</span><br><span class="line">01:58:12 PM       946    0.20    0.40    0.00    0.60    14  java</span><br></pre></td></tr></table></figure><h2 id="CPU使用过高怎么办"><a href="#CPU使用过高怎么办" class="headerlink" title="CPU使用过高怎么办"></a>CPU使用过高怎么办</h2><p>我们前期可以采用perf,不用gdb的原因是gdb会阻塞进程影响线上应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf top</span></span><br><span class="line">Samples: 833  of event 'cpu-clock', Event count (approx.): 97742399</span><br><span class="line">Overhead  Shared Object       Symbol</span><br><span class="line">   7.28%  perf                [.] 0x00000000001f78a4</span><br><span class="line">   4.72%  [kernel]            [k] vsnprintf</span><br><span class="line">   4.32%  [kernel]            [k] module_get_kallsym</span><br><span class="line">   3.65%  [kernel]            [k] _raw_spin_unlock_irqrestore</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>也可以采用perf record &amp;&amp; perf report来进行采样</p><p>其中 perf 添加-g可以查看具体的调用链</p><h2 id="案例的总结"><a href="#案例的总结" class="headerlink" title="案例的总结"></a>案例的总结</h2><p>user+nice过高说明程序的进程可优化<br>sys过高可能是内核调度服务出问题<br>iowait过高可能是磁盘io出问题<br>si+hi过高可能是内核中断出问题</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-理解CPU的上下文切换</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E7%90%86%E8%A7%A3CPU%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E7%90%86%E8%A7%A3CPU%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>什么是CPU的上下文切换，程序又是如何运行的？</p><blockquote><p>程序在运行的时候，CPU会将一部分数据加载到CPU的寄存器，它是属于CPU专属的高速缓存，并且将程序运行的地址加载到程序计数器中，而CPU寄存器+程序计数器统称为CPU的上下文？<br>我们的系统一般可以并行运行多个程序，儿多个进程并不是真正的并行运行的，CPU会同时在多个程序中进行切换，造成这种并行运行的“错觉”，而切换之前就要现将CPU的上下文保存起来从而下次执行是偶继续执行，这个叫做CPU的上下文切换。</p></blockquote><h2 id="CPU上下文切换的几个场景"><a href="#CPU上下文切换的几个场景" class="headerlink" title="CPU上下文切换的几个场景"></a>CPU上下文切换的几个场景</h2><ol><li>进程之间的上下文切换</li><li>线程之间的上下文切换</li><li><p>响应系统中断的上下文切换</p><p>注： 还有一种场景就是系统调用的CPU上下文切换，我们的程序是运行在用户态的，而系统的资源是系统的内核态。一次操作往往需要多次系统调用，会发生多次CPU上下文切换比如：读取一个文件是以下3步。先open()打开一个文件，再read()读取磁盘数据，再write()写到标准数据流中。每一次系统调用会先保存用户态的数据，然后加载内核态数据，然后切换到内核态，操作完成后，在加载用户态数据，切换回用户态继续之前的操作。（俩次切换过程）不过我们一般称呼他们是特权切换，他们是不会发生进程切换的。</p><p>如图：<br><img src="/系统优化-CPU-理解CPU的上下文切换/img1.png" alt="avator"></p><p>进程间切换：需要刷新系统的虚拟内存、栈等用户态信息，再保存CPU上下文。<br>进程切换的主要原因有：分配的运行时间片已到；系统资源不够【比如内存不够】等待资源时候会被挂起；调用Sleep函数；有更高优先级的进程进来等</p><p>线程间切换：线程是CPU调度的最小单位，进程是CPU的最小的资源单位，所谓的CPU上下文切换实际是线程的CPU上下文切换分一下俩种情况：</p><blockquote><ol><li>如果俩个线程属于同一个进程：不需要切换用户态信息，再切换CPU上下文</li><li>如果俩个线程不属于同一个进程：需要切换用户态信息，再切换CPU上下文。<br>所以，现在程序大都用多线程取代多进程。</li></ol></blockquote><p>响应系统中断：为了响应硬件事件，往往回中断当前正在运行的进程。响应中断往往比进程优先级高。</p></li></ol><h2 id="如何定位CPU切换的场景"><a href="#如何定位CPU切换的场景" class="headerlink" title="如何定位CPU切换的场景"></a>如何定位CPU切换的场景</h2><h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><p>  vmstat使我们常用的分析io的工具他也能分析cpu的上下文切换，使用方法如下：其中</p><ul><li>r 是runable或者runnaing的进程数</li><li>b 是block的进程数</li><li>system的in是中断数</li><li>cs是切换数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vmstat</span><br><span class="line"></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 0  0      0 78018360 299560 30894864    0    0     0     7    0    0  1  0 99  0  0</span><br></pre></td></tr></table></figure><p>  pidstat，和上期不一样的是如果我们想看cpu上下文切换数需要加上-w，-t是查看线程</p><ul><li>cswch/s是每秒自愿切换上下文的次数，比如：无法获取资源被挂起。</li><li>nvcswch/s是每秒非自愿切换上下文的次数，运行时间片到了被挂起。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pidstat -w -t  -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line">08:30:23 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">08:30:28 PM   669     27440      0.00      0.00  java</span><br></pre></td></tr></table></figure><p>  查看中断原因watch -d cat /proc/interrupts</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> watch -d cat /proc/interrupts</span></span><br><span class="line">           CPU0       CPU1</span><br><span class="line">...</span><br><span class="line">RES:    2450431    5279697   Rescheduling interrupts</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">res是指cpu调度中断，中断原因是cpu在频繁的切换线程</span><br></pre></td></tr></table></figure><h3 id="分析问题路径"><a href="#分析问题路径" class="headerlink" title="分析问题路径"></a>分析问题路径</h3><ol><li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li></ol><p>具体排查路径如下：</p><ol><li>我们先运行vmstat，一般cs在1w左右都是正常的如果超过1w，我们就要去调用pidstat查看；</li><li>pidstat -w -u查看cpu的占用和cswch,如果是Java或者golang等多线程的程序要加-t看线程之间的cswch/s值</li><li>之后通过watch -d cat /proc/interrupts查看cpu的中断原因【watch -d ‘cat /proc/interrupts | sort -nr -k 2 ‘】</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot中的MongoConfig</title>
      <link href="SpringBoot%E4%B8%AD%E7%9A%84MongoConfig/"/>
      <url>SpringBoot%E4%B8%AD%E7%9A%84MongoConfig/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我负责的一个项目采用了MongoDB作为数据源，同时使用了springboot生态顺利成章的使用了<strong>org.springframework.boot:spring-boot-starter-data-mongodb</strong>。开始配置采用下面的链接方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb:<span class="comment">//127.0.0.1:27017/faceguard?retryWrites=true</span></span><br></pre></td></tr></table></figure><p>这种方案我们遇到了俩个问题：</p><ol><li>很难对连接池进行定制化的设计，连连接数都设置不了。</li><li>更为重要的我们对mongodb的server加了4层的负载，而这种链接方式不自持心跳导致我们的链接空闲一段时间内会自己断掉；</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>自己注入MongoDbFactory，可以按需要注入进自己的参数了。我们需要实现下面几步</p><ol><li>实现MongoClientOptionProperties，将配置文件中<em>mongo.client.option</em>签注的属性注入到MongoClientOptionProperties中</li><li>利用MongoClientOptionProperties生成MongoClientOptions对象，MongoClientOptions是典型的builder模式，通过build()生成对象在传递给MongoClient</li><li>注入MongoDbFactory方法时候将MongoClient传递给MongoDbFactory</li></ol><p>talk is cheap上代码,MongoClientOptionProperties只提供了几个常用设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2020/04/18</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"mongo.client.option"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoClientOptionProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectionsPerHost = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minConnectionsPerHost = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectTimeout = <span class="number">6000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxWaitTime = <span class="number">6000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> socketTimeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatFrequency = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ericliu.mongodb.plus.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClient;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoClientOptions;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.MongoCredential;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.ServerAddress;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.MongoDatabase;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.gridfs.GridFSBucket;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.client.gridfs.GridFSBuckets;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.util.Strings;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.NoSuchBeanDefinitionException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.convert.CustomConversions;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.SimpleMongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.convert.DbRefResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.convert.DefaultDbRefResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.convert.DefaultMongoTypeMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.convert.MappingMongoConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.MongoMappingContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pengkai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MongoClientOptionProperties.class)<span class="comment">//建议这样引入MongoClientOptionProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(MongoConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mongo.database&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String database;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mongo.host&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mongo.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mongo.username:&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;mongo.password:&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GridFSBucket <span class="title">getGridFSBuckets</span><span class="params">(MongoDbFactory mongoDbFactory)</span> </span>&#123;</span><br><span class="line">        MongoDatabase db = mongoDbFactory.getDb();</span><br><span class="line">        <span class="keyword">return</span> GridFSBuckets.create(db);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MappingMongoConverter <span class="title">mappingMongoConverter</span><span class="params">(MongoDbFactory factory, MongoMappingContext context, BeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">        DbRefResolver dbRefResolver = <span class="keyword">new</span> DefaultDbRefResolver(factory);</span><br><span class="line"></span><br><span class="line">        MappingMongoConverter mappingConverter = <span class="keyword">new</span> MappingMongoConverter(dbRefResolver, context);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mappingConverter.setCustomConversions(beanFactory.getBean(CustomConversions.class));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchBeanDefinitionException ignore) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't save _class to mongo</span></span><br><span class="line">        mappingConverter.setTypeMapper(<span class="keyword">new</span> DefaultMongoTypeMapper(<span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> mappingConverter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖默认的MongoDbFactory</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MongoDbFactory <span class="title">mongoDbFactory</span><span class="params">(MongoClientOptionProperties mongoClientOptionProperties)</span> </span>&#123;</span><br><span class="line">        MongoClientOptions.Builder builder = <span class="keyword">new</span> MongoClientOptions.Builder();</span><br><span class="line">        builder.connectionsPerHost(mongoClientOptionProperties.getConnectionsPerHost());</span><br><span class="line">        builder.minConnectionsPerHost(mongoClientOptionProperties.getMinConnectionsPerHost());</span><br><span class="line">        builder.connectTimeout(mongoClientOptionProperties.getConnectTimeout());</span><br><span class="line">        builder.maxWaitTime(mongoClientOptionProperties.getMaxWaitTime());</span><br><span class="line">        builder.socketTimeout(mongoClientOptionProperties.getSocketTimeout());</span><br><span class="line">        <span class="keyword">if</span> (mongoClientOptionProperties.getHeartbeatFrequency() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            builder.heartbeatFrequency(mongoClientOptionProperties.getHeartbeatFrequency());</span><br><span class="line">        &#125;</span><br><span class="line">        MongoClientOptions mongoClientOptions = builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MongoDB地址列表</span></span><br><span class="line">        List&lt;ServerAddress&gt; serverAddresses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ServerAddress serverAddress = <span class="keyword">new</span> ServerAddress(host, port);</span><br><span class="line">        serverAddresses.add(serverAddress);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接认证</span></span><br><span class="line">        MongoClient mongoClient = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isEmpty(userName)) &#123;</span><br><span class="line">            mongoClient = <span class="keyword">new</span> MongoClient(serverAddresses, MongoCredential.createCredential(</span><br><span class="line">                    userName,</span><br><span class="line">                    database,</span><br><span class="line">                    password.toCharArray()), mongoClientOptions);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mongoClient = <span class="keyword">new</span> MongoClient(serverAddresses, mongoClientOptions);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建客户端和Factory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleMongoDbFactory(mongoClient, database);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">MongoTemplate <span class="title">mongoTemplate</span><span class="params">(MongoDbFactory mongoDbFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MongoTemplate(mongoDbFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>github地址：<a href="https://github.com/liuhao163/mongodb-plus" target="_blank" rel="noopener">https://github.com/liuhao163/mongodb-plus</a></p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc源码-DispatcherServlet(二)</title>
      <link href="SpringMvc%E6%BA%90%E7%A0%81-DispatcherServlet-%E4%BA%8C/"/>
      <url>SpringMvc%E6%BA%90%E7%A0%81-DispatcherServlet-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上一篇<a href="./SpringMvc源码-DispatcherServlet">SpringMvc源码-DispatcherServlet</a>讲了DispatcherServlet的初始化过程，本篇着重讲DispatchServlet处理一个请求的流程，即面试SpringMvc的经典面试题，SpringMvc是如何处理reqeuest的。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>  我们的DispatchServlet继承于HttpServlet，HttpServlet处理请求的方法主要是httpServlet.service，该方法会根据request.method调用doXxx。FrameworkServlet自己去实现了doXxx。</p><p>  整个的调用链是：接到reqeust请求后-&gt;FrameworkServlet.service()-&gt;FrameworkServlet.processRequest()-&gt;DispatchServlet.doService()（FrameworkServlet提供了抽象方法)<br>  -&gt;DispatchServlet.doDispatch()处理请求</p><p>  下面，我们根据这个调用链进行分析</p><h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>FrameworkServlet还重写了service方法，主要是支持HttpMethod.PATCH，它们和HttpMethod.PATCH一样都调用了processRequest(request, response)</p><p>所有的doXXX都是调用processRequest我们来看下processRequest方法做了什么</p><h3 id="processRequest"><a href="#processRequest" class="headerlink" title="processRequest"></a>processRequest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">Throwable failureCause = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从ThreadLocal中获取上一个请求的LocaleContext</span></span><br><span class="line">LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();<span class="comment">//</span></span><br><span class="line"><span class="comment">//new当前请求的LocaleContext</span></span><br><span class="line">LocaleContext localeContext = buildLocaleContext(request);<span class="comment">//SimpleLocaleContext</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从ThreadLocal中获取上一个请求的RequestAttributes(ServletRequestAttributes)</span></span><br><span class="line">RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line"><span class="comment">//new当前请求的ServletRequestAttributes</span></span><br><span class="line">ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存进ThreadLocal中</span></span><br><span class="line">initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//抽象方法具体实现在DeipatchServlet,重点方法</span></span><br><span class="line">doService(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">failureCause = ex;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//恢复previousLocaleContext，previousAttributes</span></span><br><span class="line"><span class="comment">//这里是我没太看明白的地方，说下我的猜测：</span></span><br><span class="line"><span class="comment">// 1、previousLocaleContext,previousAttributes大概率为空这里就重置了ThreadLocal</span></span><br><span class="line"><span class="comment">// 2、previousLocaleContext,previousAttributes不为空，说明当前线程处理别的请求，所以</span></span><br><span class="line"><span class="comment">// 在doservice时候context用的是current的值，请求处理完了将值还原称之前的值。</span></span><br><span class="line">resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line"><span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">requestAttributes.requestCompleted();</span><br><span class="line">&#125;</span><br><span class="line">logResult(request, response, failureCause, asyncManager);</span><br><span class="line">publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  doService–&gt;doDispatch方法负责处理具体的请求逻辑</p><p>  doDispatch见下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//判断reqeust的ContentType包含multipart/ 如果是multipart则返回StandardMultipartHttpServletRequest</span></span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line"><span class="comment">//根据请求获取HandlerExecutionChain，包含对应的handlerMethod和interceptor【MappedInterceptor 和 HandlerIntercpetor等等】</span></span><br><span class="line"><span class="comment">//具体介绍见下方</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line"><span class="comment">// 根据handler找到HandlerAdapter</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键代码，执行拦截器的preHandle</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line"><span class="comment">//关键代码，执行handlerMethod，ha的类型是RequestMappingHandlerAdapter，</span></span><br><span class="line"><span class="comment">// 调用路径是AbstractHandlerMethodAdapter.handle()--&gt;AbstractHandlerMethodAdapter.handleInternal()--&gt;ha的类型是RequestMappingHandlerAdapter.handleInternal</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * todo 待看的组件</span></span><br><span class="line"><span class="comment"> * WebDataBinderFactory</span></span><br><span class="line"><span class="comment"> * ModelFactory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ServletInvocableHandlerMethod</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HandlerMethodArgumentResolverComposite</span></span><br><span class="line"><span class="comment"> * HandlerMethodReturnValueHandlerComposite</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ModelAndViewContainer</span></span><br><span class="line"><span class="comment"> * modelAndView</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//todo asyncManager 待看</span></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//todo</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"><span class="comment">//关键代码，执行拦截器的postHandle</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//todo 书签 渲染modelAndView，同时触发mappedHandler.triggerAfterCompletion</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="comment">//触发mappedHandler.triggerAfterCompletion</span></span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">//触发mappedHandler.triggerAfterCompletion</span></span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="comment">//这里要注意，Multipar在这里被清理掉所以如果Multipart有异步场景，需要将copy到别的对象中。</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键文章索引：</p><ul><li><a href="/SpringMvc源码-RequestMappingHandlerMapping">SpringMvc源码-RequestMappingHandlerMapping</a></li><li><a href="/SpringMvc源码-RequestMappingHandlerAdapter">SpringMvc源码-RequestMappingHandlerAdapter</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc源码-DispatcherServlet(一)</title>
      <link href="SpringMvc%E6%BA%90%E7%A0%81-DispatcherServlet/"/>
      <url>SpringMvc%E6%BA%90%E7%A0%81-DispatcherServlet/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DispatcherServlet是springmvc最重要的组成部分，听名字就知道它负责一个请求到响应的流转，本篇主要讲DispatcherServlet的启动过程。<br>思考一个把问题？为什么DispatcherServlet初始化后，Spring的Ioc容器就会启动，容器中的Bean是什么时候注册到容器中的？</p></blockquote><p>  实际上整个SpringMvc的启动过程分为俩个阶段：</p><ol><li>ContextLoaderListener初始化，实例化IOC容器，并将此容器注册到ServletContext中。</li><li><p>DispatcherServlet初始化，建立自己的上下文，也注册到ServletContext中。</p><p>见下面这段web.xml的配置（springboot不在我们这篇文章讨论之列。）</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>ota<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>ota web application<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 系统组件加载顺序：context-param -&gt; listener -&gt; filter -&gt; servlet --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- GZip --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>gzipFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.travelsky.ibeplus.compress.Compress2WayFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>gzipFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  Servlet that dispatches request to registered handlers (Controller implementations).  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ota<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/mvc-core-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 需要定义在对应的servlet之后 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ota<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ContextLoaderListener初始化"><a href="#ContextLoaderListener初始化" class="headerlink" title="ContextLoaderListener初始化"></a>ContextLoaderListener初始化</h2><p>见web.xml这一段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:/applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/context-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span>&lt;/<span class="title">listener</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  关键逻辑：<br>  ContextLoaderListener采用了很典型的适配器模式，继承了ContextLoader,实现了ServletContextListener接口。<br>  在contextInitialized()-&gt;initWebApplicationContext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Store context in local instance variable, to guarantee that</span></span><br><span class="line"><span class="comment">// it is available on ServletContext shutdown. 初始化webApplication</span></span><br><span class="line">     ......</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.context = createWebApplicationContext(servletContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.context <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) <span class="keyword">this</span>.context;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt;</span></span><br><span class="line"><span class="comment">// determine parent for root web application context, if any.</span></span><br><span class="line">ApplicationContext parent = loadParentContext(servletContext);</span><br><span class="line">cwac.setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法会调用setConfigLocation，将xml中的contextConfigLocation传递给WebApplicationContext,还会调用refresh方法执行容器的bean初始化等操作</span></span><br><span class="line">configureAndRefreshWebApplicationContext(cwac, servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将ConfigurableWebApplicationContext设置会servletContext</span></span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="keyword">this</span>.context);</span><br><span class="line"></span><br><span class="line">ClassLoader ccl = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="keyword">if</span> (ccl == ContextLoader.class.getClassLoader()) &#123;</span><br><span class="line">currentContext = <span class="keyword">this</span>.context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ccl != <span class="keyword">null</span>) &#123;</span><br><span class="line">currentContextPerThread.put(ccl, <span class="keyword">this</span>.context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.context;</span><br><span class="line">&#125;<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>configureAndRefreshWebApplicationContext方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac, ServletContext sc)</span> </span>&#123;</span><br><span class="line"><span class="comment">//关键1</span></span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">String idParam = sc.getInitParameter(CONTEXT_ID_PARAM);</span><br><span class="line"><span class="keyword">if</span> (idParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac.setId(idParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(sc.getContextPath()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键2 设置servletContext 和web.xml的configLocationParam 传给 ConfigurableWebApplicationContext</span></span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">String configLocationParam = sc.getInitParameter(CONFIG_LOCATION_PARAM);</span><br><span class="line"><span class="keyword">if</span> (configLocationParam != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac.setConfigLocation(configLocationParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(sc, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customizeContext(sc, wac);</span><br><span class="line"><span class="comment">//关键3 见ApplicationContext.refresh方法 初始化容器的bean</span></span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet初始化"><a href="#DispatcherServlet初始化" class="headerlink" title="DispatcherServlet初始化"></a>DispatcherServlet初始化</h2><p>相关的xml配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  Servlet that dispatches request to registered handlers (Controller implementations).  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ota<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/mvc-core-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 需要定义在对应的servlet之后 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ota<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  类的继承关系：DispatcherServlet–&gt;FrameworkServlet–&gt;HttpServletBean–&gt;HttpServlet</p><p>  HttpServletBean重写了Serlvet的init方法，封装了spring的web容器启动的过程。</p><h3 id="HttpServletBean"><a href="#HttpServletBean" class="headerlink" title="HttpServletBean"></a>HttpServletBean</h3><p>init()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map config parameters onto bean properties of this servlet, and</span></span><br><span class="line"><span class="comment"> * invoke subclass initialization.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if bean properties are invalid (or required</span></span><br><span class="line"><span class="comment"> * properties are missing), or if subclass initialization fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line"><span class="comment">//1. 获取web.xml中的getInitParameterNames,将servletConfig的initParam参数的key和value都保存到pvs中</span></span><br><span class="line">PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"><span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//BeanWrapper实际是BeanWrapperImpl【DispatcherServlet】</span></span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="comment">//通过BeanWrapper为bean【DispatcherServlet】赋值</span></span><br><span class="line"><span class="comment">//BeanWrapper的target的属性的key要和web.xml中的&lt;init-param&gt;的param-name相等，这里就给DispatchServlet的contextConfigLocation赋值了</span></span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line"><span class="comment">// FrameworkServlet实现了initServletBean方法</span></span><br><span class="line">initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h3><p>  FrameworkServlet的Override了HttpServletBean的initServletBean方法，在该方法通过initWebApplicationContext初始化了webApplicationContext</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overridden method of &#123;<span class="doctag">@link</span> HttpServletBean&#125;, invoked after any bean properties</span></span><br><span class="line"><span class="comment"> * have been set. Creates this servlet's WebApplicationContext.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">getServletContext().log(<span class="string">"Initializing Spring "</span> + getClass().getSimpleName() + <span class="string">" '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Initializing Servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//关键方法 在这里初始化了 webApplicationContext</span></span><br><span class="line"><span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">initFrameworkServlet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line"><span class="string">"shown which may lead to unsafe logging of potentially sensitive data"</span> :</span><br><span class="line"><span class="string">"masked to prevent unsafe logging of potentially sensitive data"</span>;</span><br><span class="line">logger.debug(<span class="string">"enableLoggingRequestDetails='"</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line"><span class="string">"': request parameters and headers will be "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(<span class="string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameworkServlet.initWebApplicationContext()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//ContextLoaderListerner中已经将context放在了ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span></span><br><span class="line">WebApplicationContext rootContext =</span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//以下是初始化webApplicationContext的过程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"><span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"><span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line"><span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"><span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line"><span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"><span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">cwac.setParent(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键方法</span></span><br><span class="line">configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">wac = findWebApplicationContext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//关键方法 上面如果为空，createWebApplicationContext里会在执行configureAndRefreshWebApplicationContext</span></span><br><span class="line">wac = createWebApplicationContext(rootContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">       <span class="comment">// DispatcherServlet实现了onRefresh--&gt;即：initStrategies(context);</span></span><br><span class="line">onRefresh(wac);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">String attrName = getServletContextAttributeName();</span><br><span class="line">getServletContext().setAttribute(attrName, wac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点方法，FrameworkServlet.configureAndRefreshWebApplicationContext()，初始化ConfigurableWebApplicationContext并且执行refresh。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line"><span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line"><span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Generate default id...</span></span><br><span class="line">wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wac.setServletContext(getServletContext());</span><br><span class="line">wac.setServletConfig(getServletConfig());</span><br><span class="line">wac.setNamespace(getNamespace());</span><br><span class="line"><span class="comment">//将ContextRefreshListener注册到ApplicationContext中</span></span><br><span class="line"><span class="comment">//将ContextRefreshListener注册到ApplicationContext中</span></span><br><span class="line"><span class="comment">//在调用wac.refresh时候会回触发spring框架中的的onApplicationEventContext</span></span><br><span class="line"><span class="comment">// SourceFilteringListener.onApplicationEventContext--&gt;RefreshListener.onApplicationEvent--&gt;FrameworkServlet.this.onApplicationEvent--&gt;DipatcherServlet.onRefresh</span></span><br><span class="line">wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"><span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line"><span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line"><span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line"><span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postProcessWebApplicationContext(wac);</span><br><span class="line">applyInitializers(wac);</span><br><span class="line"></span><br><span class="line"><span class="comment">//applicationContext.refresh()--&gt;registerListener会触发ContextRefreshListener.onApplicationEvent</span></span><br><span class="line">wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DispatcheServlet"><a href="#DispatcheServlet" class="headerlink" title="DispatcheServlet"></a>DispatcheServlet</h3><p>  重点方法onRefresh：逻辑见下图，重点方法initStrategies。组件的优先级：自己注入的Bean&gt;DespatchServlet.properties中的Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment"> * 初始化组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line"><span class="comment">//MultipartResolver,不注册不支持上传文件，默认是StandardServletMultipartResolver,需要自己注册</span></span><br><span class="line">initMultipartResolver(context);</span><br><span class="line"><span class="comment">//i18n 默认调用getDefaultStrategy(),见：DispatchServlet.properties，org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span></span><br><span class="line">initLocaleResolver(context);</span><br><span class="line"><span class="comment">//主题 默认调用getDefaultStrategy(),见：DispatchServlet.properties，org.springframework.web.servlet.theme.FixedThemeResolver</span></span><br><span class="line">initThemeResolver(context);</span><br><span class="line"><span class="comment">//重要组件，detectAllHandlerMappings？从context包含父类取所有的HandlerMapping or 取一个，为空从DispatchServlet.properties</span></span><br><span class="line">initHandlerMappings(context);</span><br><span class="line"><span class="comment">//重要组件，detectAllHandlerMappings？从context包含父类取所有的HandlerAdapter or 取一个，为空从DispatchServlet.properties</span></span><br><span class="line">initHandlerAdapters(context);</span><br><span class="line"><span class="comment">//异常处理，同上类似的逻辑</span></span><br><span class="line">initHandlerExceptionResolvers(context);</span><br><span class="line"><span class="comment">//Request-&gt;ViewName</span></span><br><span class="line">initRequestToViewNameTranslator(context);</span><br><span class="line"><span class="comment">//ViewResolver</span></span><br><span class="line">initViewResolvers(context);</span><br><span class="line"><span class="comment">//flashMapManager</span></span><br><span class="line">initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  这里的context默认是XmlWebApplicationContext，见contextLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件内容：org.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_STRATEGIES_PATH = <span class="string">"ContextLoader.properties"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态方法代码块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line"><span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line"><span class="comment">// by application developers.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, ContextLoader.class);</span><br><span class="line">defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load 'ContextLoader.properties': "</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  见DispatcherServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt; DEFAULT_CONTEXT_CLASS = XmlWebApplicationContext.class;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(@Nullable ApplicationContext parent)</span> </span>&#123;</span><br><span class="line"><span class="comment">//getContextClass返回值是DEFAULT_CONTEXT_CLASS</span></span><br><span class="line">Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">......</span><br><span class="line">configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  启动时候如何加载的init-param，见HttpServletBean的代码，推荐下去试试BeanWrapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BeanWrapper实际是BeanWrapperImpl【DispatcherServlet】</span></span><br><span class="line">BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="comment">//为BeanWrapper赋值，init-Param的name对应的是bw的属性。。。这段不仔细看真看不出来 initParam怎么赋值的</span></span><br><span class="line">bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> mvc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稳定性的看法</title>
      <link href="%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%AE%A8%E8%AE%BA/"/>
      <url>%E7%A8%B3%E5%AE%9A%E6%80%A7%E8%AE%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="稳定性的定义"><a href="#稳定性的定义" class="headerlink" title="稳定性的定义"></a>稳定性的定义</h2><p>外界发生变化时（如：功能的发布、服务的故障），系统能稳定的对外提供服务</p><h2 id="稳定性的手段"><a href="#稳定性的手段" class="headerlink" title="稳定性的手段"></a>稳定性的手段</h2><h3 id="管理措施"><a href="#管理措施" class="headerlink" title="管理措施"></a>管理措施</h3><p>研发规范：</p><ul><li>制定代码规范，上线前codereview</li><li>制定版本管理规范，对于代码的merge规则，版本号的管理。</li></ul><p>上线规范：</p><ul><li>避开高峰期</li><li>上线前告知上下游风险</li><li>制定回滚方案</li><li>线上验收机制</li></ul><h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><p>  将核心服务和非核心服务分离，将经常变更的服务和稳定的服务隔离，将消耗资源的服务和非消耗资源的服务隔离。</p><p>  手段：业务拆分，异步化</p><p>  方式：通过以下3个维度拆分服务</p><ul><li>运行时隔离：适用场景共用资源池的情况。如：服务共用一个httpclient，一个慢请求会很占用ConnectionPool的线程不释放,针对此方案我们需要提前释放资源，保证其他请求正常进行。</li><li>进程隔离：适用场景服务拆分，梳理整个业务，然后根据该功能是否稳定，是否是核心服务，请求量大小来综合考虑，划分成不同的服务。</li><li>机器隔离：使用与流量凸涨的情况，我们可以将部分流量有针对性的切到新的机器上。比如：秒杀系统，甚至是有的VIP客户</li></ul><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p>  如果遇到机器故障，机房故障这种自身无法避免的情况。以上的隔离手段就会失效，这种情况我们要采用冗余的方式来处理。</p><p>  当和核心服务出现问题后我们可以通过切流等方式将故障转移到没有问题的服务上。</p><p>  冗余级别：</p><ul><li>集群内：采取的方式是N+2，即1个提供服务，2个是冗余</li><li><p>集群间、或者机房间：我们应该采取的服务是N+1，但是要保证1能接住此时的流量。</p><p>服务冗余的要点做到：独立部署、无状态、冗余的副本之间没有依赖。</p></li></ul><h3 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h3><p>服务隔离和冗余已经大部分影响系统稳定性的因素，但是无法解决突发情况，如：流量暴涨、被共计等，针对此我们要制定容灾容错机制。</p><p>手段：</p><ul><li>限流：自我保护的机制，对于上游调用采用多种降级措施（随机降级-简单易用）。</li><li>降级：功能禁用（功能降级）；采用缓存，不调用下游依赖服务（上游服务降级），个别服务消耗大量资源的停用服务（服务降级），非核心服务消耗大量数据库资源停用服务（服务降级）</li></ul><h3 id="演练"><a href="#演练" class="headerlink" title="演练"></a>演练</h3><p>  放火演练：检测系统稳定性，发现隐患，验证稳定性手段。<br>  演练根据级别分为：服务演练→服务演练→机器演练→集群级别→机房级别 。（建议做机器的放火演练）</p><p>  压测：明确系统瓶颈。</p><h3 id="描述稳定性的指标"><a href="#描述稳定性的指标" class="headerlink" title="描述稳定性的指标"></a>描述稳定性的指标</h3><p>  可用性指标：SLA（2个9到5个9）</p><p>  故障度量：PX（P3→P0）</p><p>  响应时间：time&lt;1s→time&lt;2s→time&lt;3s→time&gt;3s</p><p>  服务内部调用：time&lt;100ms→time&lt;200ms→time&lt;1s→time&gt;1s</p><p>总结，稳定性一般做到99.99%已经是很成熟的系统了。</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 项目积累 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 方法论 </tag>
            
            <tag> 稳定性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-ApplicationContext</title>
      <link href="Spring%E6%BA%90%E7%A0%81-ApplicationContext/"/>
      <url>Spring%E6%BA%90%E7%A0%81-ApplicationContext/</url>
      
        <content type="html"><![CDATA[<p>  spring框架中的BeanFactory和ApplicationContext是非常重要的俩个接口。<br>  ApplicationContext是BeanFactory的子接口，BeanFactory是IOC容器，ApplicationContext是应用的上下文除了实现了BeanFactory还实现了配置文件的读取等操作。<br>  所有的bean初始化都在ApplicationContext的refresh方法中完成。本文以AnnotationConfigApplicationContext为例。</p><p>继承关系图如下<br><img src="/Spring源码-ApplicationContext/spring-context-uml.png" alt="avator"></p><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>  名字的直译是Bean工厂，我们定义的Bean在这里就行初始化。图中真正可以作为一个独立使用的IOC容器的是DefaultListableBeanFactory</p><p>  BeanFactory主要的方法是getBean，用来获取Bean</p><p>  3个子接口：</p><ul><li>HierarchicalBeanFactory:提供父容器的访问功能</li><li>ListableBeanFactory:提供了批量获取Bean的方法</li><li>AutowireCapableBeanFactory:在BeanFactory基础上实现对已存在实例的管理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HierarchicalBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回父类的BeanFactory</span></span><br><span class="line">    <span class="function">BeanFactory <span class="title">getParentBeanFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前beanfacatory是否包含bean，不会去父类的BeanFactory找</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsLocalBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提供通过beanName、类型查找Bean的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(ResolvableType type);</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit);</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type);</span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForType(<span class="meta">@Nullable</span> Class&lt;?&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Map&lt;String, T&gt; <span class="title">getBeansOfType</span><span class="params">(@Nullable Class&lt;T&gt; type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit)</span><span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    String[] getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt; annotationType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">Map&lt;String, Object&gt; <span class="title">getBeansWithAnnotation</span><span class="params">(Class&lt;? extends Annotation&gt; annotationType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;A extends Annotation&gt; <span class="function">A <span class="title">findAnnotationOnBean</span><span class="params">(String beanName, Class&lt;A&gt; annotationType)</span><span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_NO = <span class="number">0</span>;<span class="comment">//按照构造方法自动装配</span></span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_NAME = <span class="number">1</span>;<span class="comment">//按照名称autowire</span></span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_BY_TYPE = <span class="number">2</span>;<span class="comment">//按照类型autowire</span></span><br><span class="line">    <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = <span class="number">3</span>;<span class="comment">//按照构造方法自动装配</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用autowireBeanProperties装配属性</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">autowireBean</span><span class="params">(Object existingBean)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动装配属性,填充属性值,使用诸如setBeanName,setBeanFactory这样的工厂回调填充属性,最好还要调用post processor</span></span><br><span class="line">    <span class="function">Object <span class="title">configureBean</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会执行bean完整的初始化,包括BeanPostProcessors和initializeBean</span></span><br><span class="line">    <span class="function">Object <span class="title">createBean</span><span class="params">(Class&lt;?&gt; beanClass, <span class="keyword">int</span> autowireMode, <span class="keyword">boolean</span> dependencyCheck)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AnnotationConfigApplicationContext"><a href="#AnnotationConfigApplicationContext" class="headerlink" title="AnnotationConfigApplicationContext"></a>AnnotationConfigApplicationContext</h2><p>构造方法：我们以下面的构造方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//无参构造函数，--&gt;GenericApplicationContext--&gt;初始化（beanFactory = new DefaultListableBeanFactory()）</span></span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  <span class="comment">//扫描包下面的注解，默认支持Commponent（以及他的子类），javax.annotation.ManagedBean，javax.inject.Named</span></span><br><span class="line">  scan(basePackages);</span><br><span class="line">  <span class="comment">//刷新上下文</span></span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-做了什么"><a href="#this-做了什么" class="headerlink" title="this()做了什么"></a>this()做了什么</h3><ol><li>调用父类GenericApplicationContext的无参构造方法,在GenericApplicationContext中初始化DefaultListableBeanFactory</li><li>自己的构造方法初始化BeanDefinition的读取器和类扫描器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//IOC容器初始化注解BeanDefinition的读取器，如果需要注册指定的类就采用reader.register</span></span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//IOC容器初始化类扫描器，如果是需要扫描某个包下的注解就用scanner.scan</span></span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scan-or-register"><a href="#scan-or-register" class="headerlink" title="scan or register"></a>scan or register</h3><p>  AnnotationConfigApplicationContext的构造方法一般支持俩种，注册某些Component注解、扫描某一个包，他们具体的区别就在构造方法中的register或者scan，俩者逻辑都差不多，这里我们</p><ul><li>scan(basePackages)，它会调用scanner.scan(basePackages)。scan扫描的bean的注解默认只支持Commponent（以及他的子类），javax.annotation.ManagedBean，javax.inject.Named，如果有特殊的注解需要需要自己实现</li><li><p>register(componentClasses),他会调用reader.register(componentClasses)。register注册的bean可以不用加注解。</p><p>这一步实际上是对入参的basePackage或者class，进行扫描或者注册，生成BeanDefinition保存到容器中。BeanDefinition封装了Class的MetaInfo，包含了类名，属性，方法，父类信息等。便于后续根据的BeanDefinition对其包含的对象进行初始化。</p><p>我们来看下 //todo</p></li></ul><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><p>  真正bean的初始化过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">  <span class="comment">//防止并发情况下多次初始化</span></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">      postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">      invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">      registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">      initMessageSource();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">      initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">      onRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">      registerListeners();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">      finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">      finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">            <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">      destroyBeans();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">      cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">      <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">      resetCommonCaches();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们一步步的看</p><h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h4><p>为refresh做准备，设置Application的startUpdate,将状态改为active，同时初始化properties。</p><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h4><p>重新刷新BeanFactrory,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  refreshBeanFactory();</span><br><span class="line">  <span class="keyword">return</span> getBeanFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的refreshBeanFactory()俩个实现，GenericApplicationContext和AbstractRefreshableApplicationContext</p><p>  GenericApplicationContext对应的是本文的Annotation在ApplicationContext的构造方法中已经register/scan过，BeanDefinition了这里就不用创建beanfactroy在加载一遍bean了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException </span>&#123;</span><br><span class="line">  <span class="comment">//因为在ApplicationContext的构造方法中已经register/scan过BeanDefinition了这里就不用在重新创建beanfactroy，在加载一边bean了</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshed.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"GenericApplicationContext does not support multiple refresh attempts: just call 'refresh' once"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.beanFactory.setSerializationId(getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AbstractRefreshableApplicationContext对应的是xml，file等方式，在构造方法中只是加载文件没有创建BeanDefinition,所在这里要创建BeanDefinition对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">    destroyBeans();</span><br><span class="line">    closeBeanFactory();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">    beanFactory.setSerializationId(getId());</span><br><span class="line">    customizeBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">//根据构造函数传入到file地址创建，加载BeanDefinition，</span></span><br><span class="line">    loadBeanDefinitions(beanFactory);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">      <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h4><p>设置beanFactory的classloader，spel表达式，bean的属性处理器，自动装配的例外/特殊规则，BeanProcessor，env等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Tell the internal bean factory to use the context's class loader etc.'</span></span><br><span class="line">  <span class="comment">//设置classloader为当前contextLocader</span></span><br><span class="line">  beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">  <span class="comment">//设置spel表达式</span></span><br><span class="line">  beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">  <span class="comment">//设置ResourceEditor,用于初始化bean时候填充bean的属性</span></span><br><span class="line">  beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure the bean factory with context callbacks.</span></span><br><span class="line">  <span class="comment">//设置ApplicationContextAwareProcessor实现了BeanPostProcessor，作用：程序可以获取ApplicationContext</span></span><br><span class="line">  <span class="comment">// 例：我们程序中自定义MyApplicationContextAware实现ApplicationContextAware接口</span></span><br><span class="line">  <span class="comment">// ApplicationContextAwareProcessor在bean初始化前会调用，postProcessBeforeInitialization然后调用MyApplicationContextAware.setApplictionContext</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  <span class="comment">//添加忽略规则，因为在Bean实例化过程中，这些依赖未必会实例化，所以选择忽略，如果bean需要这些依赖，可以采用set等方式。</span></span><br><span class="line">  beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">  beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">  <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">  <span class="comment">//设置自动装配的规则</span></span><br><span class="line">  beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">  beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="keyword">this</span>);</span><br><span class="line">  beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span></span><br><span class="line">  <span class="comment">//设置容器的后置BeanPostProcessor处理器，将ApplicationListener注册到容器中，见postProcessAfterInitialization</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span></span><br><span class="line">  <span class="comment">//判断是否有loadTimeWeaver</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    <span class="comment">//LoadTimeWeaverAwareProcessor--&gt;从容器中获取loadTimeWeaver，然后添加到LoadTimeWeaverAware中</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register default environment beans.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>  没有具体实现的空方法，在beanFactory都设置好以后，留给容器根据自己的使用场景自己定制如：web容器注入一些重要资源（类似Application的属性和ServletContext的属性），我们可以实现该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在GenericWebApplicationContext中</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.servletContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ServletContextAwareProcessor(<span class="keyword">this</span>.servletContext));</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ServletContextAware.class);</span><br><span class="line">  &#125;</span><br><span class="line">  WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">  WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <span class="keyword">this</span>.servletContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invokeBeanFactoryPostProcessors-beanFactory"><a href="#invokeBeanFactoryPostProcessors-beanFactory" class="headerlink" title="invokeBeanFactoryPostProcessors(beanFactory)"></a>invokeBeanFactoryPostProcessors(beanFactory)</h4><p>容器执行内置的以及用户自定义的BeanDefinitionRegistryPostProcessor以及BeanFactoryPostProcessor的postProcessBeanFactory方法。</p><p>BeanDefinitionRegistryPostProcessor作用见链接<a href="/Spring源码-BeanDefinitionRegistryPostProcessor">Spring源码-BeanDefinitionRegistryPostProcessor</a></p><p>流程如下：</p><ol><li>invokeBeanFactoryPostProcessors调用PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法</li><li>执行容器注册好的BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry以及BeanFactoryPostProcessor.postBeanFactory，优先级是实现PriorityOrder接口，Order注解，其他<ol><li>BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry，见ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry，将Component,Import ImportResource Component注解的类解析Configuratuon</li><li>执行BeanFactoryPostProcessor.postBeanFactory。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//关键代码,执行容器注册的BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry以及BeanFactoryPostProcessor.postBeanFactory</span></span><br><span class="line">  PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">  <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="keyword">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行容器注册号的BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry以及BeanFactoryPostProcessor.postBeanFactory，</span></span><br><span class="line"><span class="comment"> * 优先级是实现PriorityOrder接口，Order注解，其他</span></span><br><span class="line"><span class="comment"> * 1.BeanDefinitionRegistryPostProcessor.postProcessBeanDefinitionRegistry，</span></span><br><span class="line"><span class="comment">     见ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry，将Component,Import ImportResource Component注解的类解析Configuratuon</span></span><br><span class="line"><span class="comment"> * 2. 执行BeanFactoryPostProcessor.postBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory obtainFreshBeanFactory()返回的factory即DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactoryPostProcessors 第一次调用时候为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">  Set&lt;String&gt; processedBeans = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="comment">//DefaultListableBeanFactory这里是true</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">    BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line"></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">        BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line">            (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">        registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">        <span class="comment">//添加到registryProcessors中</span></span><br><span class="line">        registryProcessors.add(registryProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        regularPostProcessors.add(postProcessor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先执行容器中BeanDefinitionRegistryPostProcessor的，BeanDefinitionRegistryPostProcessor的作用可以动态注册bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">    <span class="comment">// Separate between BeanDefinitionRegistryPostProcessors that implement</span></span><br><span class="line">    <span class="comment">// PriorityOrdered, Ordered, and the rest.</span></span><br><span class="line">    List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优先执行实现PriorityOrdered接口的currentRegistryProcessors</span></span><br><span class="line">    <span class="comment">// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关键代码：调用ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry，执行postProcessBeanDefinitionRegistry</span></span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span></span><br><span class="line">    <span class="comment">//其次执行实现了Ordered的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">        currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">        processedBeans.add(ppName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">    registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">    currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span></span><br><span class="line">    <span class="comment">//执行普通的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">    <span class="keyword">boolean</span> reiterate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">      reiterate = <span class="keyword">false</span>;</span><br><span class="line">      postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">          currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">          processedBeans.add(ppName);</span><br><span class="line">          reiterate = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">      registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">      invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">      currentRegistryProcessors.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span></span><br><span class="line">    <span class="comment">//执行postProcessBeanFactory</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let the bean factory post-processors apply to them!</span></span><br><span class="line">  String[] postProcessorNames =</span><br><span class="line">      beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//处理BeanFactoryPostProcessor，BeanFactoryPostProcessor分为priorityOrdered、Odered和Non三类分别处理</span></span><br><span class="line">  <span class="comment">// Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">  <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">      <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//todo  这里很不理解为啥priorityOrderedPostProcessors和orderedPostProcessorNames逻辑不一样</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">  <span class="comment">//priorityOrderedPostProcessors排序，并且执行自定义的postProcessBeanFactory</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span></span><br><span class="line">  <span class="comment">//加载orderedPostProcessors排序，并且执行自定义的postProcessBeanFactory</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">    orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, invoke all other BeanFactoryPostProcessors.</span></span><br><span class="line">  <span class="comment">//加载nonOrderedPostProcessors、并且执行自定义的postProcessBeanFactory</span></span><br><span class="line">  List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">  &#125;</span><br><span class="line">  invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clear cached merged bean definitions since the post-processors might have</span></span><br><span class="line">  <span class="comment">// modified the original metadata, e.g. replacing placeholders in values...</span></span><br><span class="line">  beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h4><p>  注册执行BeanPostProcessors，这指是注册BeanPostProcessors，并没有执行</p><p>  流程如下：</p><ol><li>registerBeanPostProcessors-&gt;PostProcessorRegistrationDelegate.registerBeanPostProcessors</li><li>在registerBeanPostProcessors取得所有的BeanPostProcessor</li><li>对BeanPostProcessors分组，分成:PriorityOrdered，Ordered，nonOrdered，internal(属于MergedBeanDefinitionPostProcessor)</li><li>对他们进行排序，注册顺序是PriorityOrdered-&gt;Ordered-&gt;nonOrdered-&gt;internal–&gt;ApplicationListenerDetector</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanPostProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取所有的BeanPostProcessor</span></span><br><span class="line">  String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">////bean不是基础BeanPostProcessor &amp;&amp; bean的Role不是ROLE_INFRASTRUCTURE &amp;&amp; beanFactory.getBeanPostProcessorCount()&lt;beanPostProcessorTargetCount</span></span><br><span class="line">  <span class="keyword">int</span> beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Separate between BeanPostProcessors that implement PriorityOrdered,</span></span><br><span class="line">  <span class="comment">// Ordered, and the rest.</span></span><br><span class="line">  <span class="comment">//将BeanPostProcessor分类</span></span><br><span class="line">  <span class="comment">//对BeanPostProcessors分组，分成:PriorityOrdered，Ordered，nonOrdered，internal(属于MergedBeanDefinitionPostProcessor)</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//todo 同理，这里为什么是orderedPostProcessorNames，为什么不和priorityOrderedPostProcessors逻辑</span></span><br><span class="line">  List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">      BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">      priorityOrderedPostProcessors.add(pp);</span><br><span class="line">      <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">        internalPostProcessors.add(pp);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">      orderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行顺序是PriorityOrdered-&gt;Ordered-&gt;nonOrdered-&gt;internal--&gt;ApplicationListenerDetector</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">  sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    orderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">  List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">  <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">    BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">    nonOrderedPostProcessors.add(pp);</span><br><span class="line">    <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">      internalPostProcessors.add(pp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">  sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">  registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-register post-processor for detecting inner beans as ApplicationListeners,</span></span><br><span class="line">  <span class="comment">// moving it to the end of the processor chain (for picking up proxies etc).</span></span><br><span class="line">  <span class="comment">//注册一个特殊的BeanPostProcessor，ApplicationListenerDetector是一个修饰器类，他会见ApplicationListener重新注册给application。</span></span><br><span class="line">  <span class="comment">//这就是多一个参数applicationContext的一一，在最后一位</span></span><br><span class="line">  beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h4><p>【todo】暂时忽略</p><h4 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h4><p> 【注册时间监听器】后续单独拿出一章讲。<br>  这里，注册ApplicationEventMulticaster 默认 SimpleApplicationEventMulticaster</p><h4 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h4><p>注册定义的ApplicationListener，注册容器的event和自定义的eventListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">  <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">  <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">  <span class="comment">//所有ApplicationListener的实现者</span></span><br><span class="line">  String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish early application events now that we finally have a multicaster...</span></span><br><span class="line">  Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="keyword">this</span>.earlyApplicationEvents;</span><br><span class="line">  <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (earlyEventsToProcess != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">      getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>对之前在AplicationContext构造方法中，scan或者register时候生成的BeanDefinition进行实例化，注意，这里只针对，单例、非延迟加载的BeanDefinition的实体化，具体方法在DefaultListableBeanFactory.preInstantiateSingletons中。见：<a href="/Spring源码-BeanDefinition7">Spring源码-BeanDefinition</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">  <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">  List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    <span class="comment">//在之前的步骤中的getBeanNamesForType方法会调用getMergedLocalBeanDefinition中</span></span><br><span class="line">    <span class="comment">//todo  将BeanDefinition写入到mergedBeanDefinitions中，后续单独讲BeanDefinition时候单独说</span></span><br><span class="line">    RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">    <span class="comment">//bd非抽象 &amp;&amp; 单利 &amp;&amp; 不延迟加载</span></span><br><span class="line">    <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">      <span class="comment">//如果是factoryBean通过"&amp;beanName"得到factoryBean</span></span><br><span class="line">      <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">        <span class="comment">//这一步很关键，如果是factory先初始化factroyBean</span></span><br><span class="line">        Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">          <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">          <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">          <span class="comment">//如果isEagerInit为true，则通过factoryBean.getObject()获取actoryBean中的对象</span></span><br><span class="line">          <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">            isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                    ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                getAccessControlContext());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">            getBean(beanName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//普通的bean初始化bean</span></span><br><span class="line">        getBean(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">  <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">      <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h4><p>完成applicationContext的refresh，发送系统事件等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">  clearResourceCaches();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">  <span class="comment">//初始化LifecycleProcessor，todo mark 作用还需要单独了解</span></span><br><span class="line">  initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">  <span class="comment">//调用上面的LifecycleProcessor.onRefresh()</span></span><br><span class="line">  getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish the final event.发送ContextRefreshedEvent事件</span></span><br><span class="line">  publishEvent(<span class="keyword">new</span> ContextRefreshedEvent(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">  <span class="comment">//todo mark 作用还需要单独了解</span></span><br><span class="line">  LiveBeansView.registerApplicationContext(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> sprig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-ApplicationListener基于事件的订阅者发布者模式</title>
      <link href="Spring%E6%BA%90%E7%A0%81-ApplicationListener%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AE%A2%E9%98%85%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>Spring%E6%BA%90%E7%A0%81-ApplicationListener%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AE%A2%E9%98%85%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>  spring容器自身提供了基于事件的订阅者发布者模式，即ApplicationListener，它能支持一些系统事件具体见ApplicationEvent的子类，同时也支持我们自定义事件使用方法如下</p><p>  容器自身的事件，如：ApplicationContextEvent,我们想获取一个全局变量ApplicationContext（代码仅供参考）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextRefreshAppliationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationContextEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContextEvent applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发 application.pulish(new ContextRefreshedEvent())</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//容器启动后在某些节点会发送事件，我们只需要实现onApplicationEvent即可。</span></span><br><span class="line">        applicationContext=event.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义事件：</p><ol><li>定义事件，事件继承自ApplicationEvent</li><li>实现该事件的AppliationListener</li><li>在程序某个时间点触发applicationContext.publishEvent方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoustomEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String eventType;</span><br><span class="line">    <span class="keyword">private</span> String summary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoustomEvent</span><span class="params">(Object source, String name, String eventType, String summary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">        <span class="keyword">this</span>.summary = summary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoustomEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoustomAppliationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">CoustomEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发 application.pulish(new ContextRefreshedEvent())</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(CoustomEvent event)</span> </span>&#123;</span><br><span class="line">        System.out.println(event.getName() + <span class="string">" eventType:"</span> + event.getEventType() + <span class="string">" summary:"</span> + event.getSummary() + <span class="string">" in time:"</span> + event.getTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发</span></span><br><span class="line">applicationContext.publishEvent(<span class="keyword">new</span> CoustomEvent(<span class="string">"source"</span>,<span class="string">"liuhao"</span>,<span class="string">"sendEmail"</span>,<span class="string">" dest liu67224657@qq.com"</span>));</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>tbd</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-类扫描器-ClassPathBeanDefinitionScanner</title>
      <link href="Spring%E6%BA%90%E7%A0%81-%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%99%A8-ClassPathBeanDefinitionScanner/"/>
      <url>Spring%E6%BA%90%E7%A0%81-%E7%B1%BB%E6%89%AB%E6%8F%8F%E5%99%A8-ClassPathBeanDefinitionScanner/</url>
      
        <content type="html"><![CDATA[<p>  我们在<a href="/Spring源码-ApplicationContext">Spring源码-ApplicationContext</a>中介绍了ApplicationContext都做了什么，其中会对容器中的BeanDefinition对应的class进行初始化，那么BeanDefinition是怎么产生的呢？其中ClassPathBeanDefinitionScanner是做什么用的呢？</p><p>  ClassPathBeanDefinitionScanner类扫描器，作用通过对制定的basepackage进行扫描，创建、注册BeanDefinition。见类图:<br>  <img src="/Spring源码-类扫描器-ClassPathBeanDefinitionScanner/ClassPathBeanDefinitionScanner.png" alt="ClassPathBeanDefinitionScanner类图"></p><p>  见下面代码，在无参构造方法中初始化ClassPathBeanDefinitionScanner，之后调用scan(basePackages)将basePackages下的class文件生成BeanDefiniton同时注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//无参构造函数，初始化reader和scanner，在父类GenericApplicationContext的无参构造方法初始化（beanFactory = new DefaultListableBeanFactory()），</span></span><br><span class="line">  <span class="keyword">this</span>();</span><br><span class="line">  <span class="comment">//扫描basePackages并且加载BeanDefinition</span></span><br><span class="line">  scan(basePackages);</span><br><span class="line">  <span class="comment">//刷新上下文</span></span><br><span class="line">  refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this()方法的内部</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//IOC容器初始化注解BeanDefinition的读取器</span></span><br><span class="line">  <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//IOC容器初始化类扫描器</span></span><br><span class="line">  <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scan的解析"><a href="#scan的解析" class="headerlink" title="scan的解析"></a>scan的解析</h2><p>   ClassPathBeanDefinitionScanner.scan()–&gt;ClassPathBeanDefinitionScanner.doScan(),doScan方法的逻辑如下</p><ol><li>文件生成BeanDefinition<ol><li>针对指定的Basepackage找对应的文件，即Resource</li><li>将Resource转换成BeanDefinition注册到容器中<ol><li>用spring-asm将Resource生成MetatDataReader</li><li>判断class是否符合容器注入条件(利用typefilter.match)</li><li>生成BeanDefinition,加入到返回值中返回</li></ol></li></ol></li><li>处理BeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    <span class="comment">//通过文件找到符合规则的BeanDefinition</span></span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">    <span class="comment">//处理BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">      ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">      candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">      String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">        BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">        definitionHolder =</span><br><span class="line">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        beanDefinitions.add(definitionHolder);</span><br><span class="line">        registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找并且生成BeanDefinition"><a href="#查找并且生成BeanDefinition" class="headerlink" title="查找并且生成BeanDefinition"></a>查找并且生成BeanDefinition</h3><p>  主要的方法是findCandidateComponents，通过指定的basePackage生成BeanDefinition，其中关键之一是PathMatchingResourcePatternResolver，里面会有目录的匹配引擎来找打牌basePackage下所有符合规则的类。</p><p>  下面的代码是整个findCandidateComponents的逻辑，其中getResourcePatternResolver()就是获取PathMatchingResourcePatternResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.componentsIndex != <span class="keyword">null</span> &amp;&amp; indexSupportsIncludeFilters()) &#123;</span><br><span class="line">    <span class="keyword">return</span> addCandidateComponentsFromIndex(<span class="keyword">this</span>.componentsIndex, basePackage);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//扫描制定的basePackage</span></span><br><span class="line">    <span class="keyword">return</span> scanCandidateComponents(basePackage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">  Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//解析basePackage，生成绝对地址ClassPath*:/xx/xx/*/**.class</span></span><br><span class="line">    String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">        resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">    <span class="comment">//通过PathMatchingResourcePatternResolver找到该目录下的Reousrce即文件</span></span><br><span class="line">    Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">//resource生成BeanDefinition 暂且忽略，后面会详细解析</span></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> candidates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件生成Resouces"><a href="#文件生成Resouces" class="headerlink" title="文件生成Resouces"></a>文件生成Resouces</h4><p>getResourcePatternResolver()对应的是PathMatchingResourcePatternResolver类，getResources流程如下</p><ol><li>findCandidateComponents()方法中，先给basePackage先加上classPath*:，调用getResources方法</li><li>走到findPathMatchingResources所在的分支处理locationPattern，分离出rootDirPath和subPattern</li><li>再次调用getResources(rootDirPath)方法回到上面的方法走到else分支调用findAllClassPathResources方法</li><li>在findAllClassPathResources中调用doFindAllClassPathResources,加载RootDir对应的rootDirResources</li><li>继续回到<2>中的findPathMatchingResources，遍历rootDirResources,这里主要执行else分支doFindPathMatchingFileResources</2></li><li>通过rootDirPath和subPattern(即 */**等)找到所有符合规则的Class对应的Resource，过程是：<ul><li>doFindPathMatchingFileResources–&gt;doFindMatchingFileSystemResources</li><li>doFindMatchingFileSystemResources–&gt;retrieveMatchingFiles</li><li>retrieveMatchingFiles–&gt;doRetrieveMatchingFiles递归执行直到找到所有符合规则的File，并且在doFindMatchingFileSystemResources生成FileSystemResource</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//basePackage先加上 classPath*:</span></span><br><span class="line">String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">          resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">      <span class="comment">//通过PathMatchingResourcePatternResolver找到该目录下的Reousrce即文件</span></span><br><span class="line">      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  Assert.notNull(locationPattern, <span class="string">"Location pattern must not be null"</span>);</span><br><span class="line">  <span class="comment">//包含ClassPath*:</span></span><br><span class="line">  <span class="keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">    <span class="comment">// a class path resource (multiple resources for same name possible)</span></span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">      <span class="comment">// a class path resource pattern</span></span><br><span class="line">      <span class="comment">//包含特殊字符 * ? &#123;&#125;在findPathMatchingResources中会去掉这些特殊字符，在调用getResources，走到else的分支</span></span><br><span class="line">      <span class="keyword">return</span> findPathMatchingResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//调用doFindAllClassPathResources加载所有的类</span></span><br><span class="line">      <span class="comment">// all class path resources with the given name</span></span><br><span class="line">      <span class="keyword">return</span> findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Resource[] findPathMatchingResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  String rootDirPath = determineRootDir(locationPattern);<span class="comment">//eg: classpath*:com/ericliu/spring/**/**/*.class--&gt;classpath*:com/ericliu/spring/</span></span><br><span class="line">  String subPattern = locationPattern.substring(rootDirPath.length());<span class="comment">//eg: classpath*:com/ericliu/spring/**/**/*.class--&gt; **/**/*.class</span></span><br><span class="line">  <span class="comment">//继续调用getResources--&gt;这时候因为classpath*:已经被替换掉会走到findAllClassPathResources分支,</span></span><br><span class="line">  <span class="comment">// 在findAllClassPathResources里加载rootDirPath对应的Reousrce，因为是目录所以数组有几个basePackage就有几个location</span></span><br><span class="line">  <span class="comment">// 如：URL [file:&lt;绝对路径&gt;/&lt;rootDirPath&gt;/]</span></span><br><span class="line">  Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">  Set&lt;Resource&gt; result = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">for</span> (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">    rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">    URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">    <span class="comment">//根据rootDirUrl的类型调用不同的逻辑，bundle:// ，vfs , *.jar</span></span><br><span class="line">    <span class="keyword">if</span> (equinoxResolveMethod != <span class="keyword">null</span> &amp;&amp; rootDirUrl.getProtocol().startsWith(<span class="string">"bundle"</span>)) &#123;</span><br><span class="line">      URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, <span class="keyword">null</span>, rootDirUrl);</span><br><span class="line">      <span class="keyword">if</span> (resolvedUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rootDirUrl = resolvedUrl;</span><br><span class="line">      &#125;</span><br><span class="line">      rootDirResource = <span class="keyword">new</span> UrlResource(rootDirUrl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">      result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">      result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//主要是执行这里的逻辑，去rootDirResource查找符合subPattern的resource（文件）</span></span><br><span class="line">      result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Resolved location pattern ["</span> + locationPattern + <span class="string">"] to resources "</span> + result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> Resource[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doRetrieveMatchingFiles查找符合规则的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRetrieveMatchingFiles</span><span class="params">(String fullPattern, File dir, Set&lt;File&gt; result)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">"Searching directory ["</span> + dir.getAbsolutePath() +</span><br><span class="line">        <span class="string">"] for files matching pattern ["</span> + fullPattern + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (File content : listDirectory(dir)) &#123;</span><br><span class="line">    String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, <span class="string">"/"</span>);</span><br><span class="line">    <span class="comment">//如果是目录，且和fullPattern匹配递归去子目录开始查找</span></span><br><span class="line">    <span class="keyword">if</span> (content.isDirectory() &amp;&amp; getPathMatcher().matchStart(fullPattern, currPath + <span class="string">"/"</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!content.canRead()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">"Skipping subdirectory ["</span> + dir.getAbsolutePath() +</span><br><span class="line">              <span class="string">"] because the application is not allowed to read the directory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        doRetrieveMatchingFiles(fullPattern, content, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getPathMatcher().match(fullPattern, currPath)) &#123;</span><br><span class="line">      result.add(content);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Reosurce生成BenDefinition"><a href="#Reosurce生成BenDefinition" class="headerlink" title="Reosurce生成BenDefinition"></a>Reosurce生成BenDefinition</h4><p>scanCandidateComponents方法中循环上面生成的Resource数组，生成BeanDefinition,其中需要</p><ol><li>获取metadataReader</li><li>判断resource是否符合我们的注入条件</li><li>生成ScannedGenericBeanDefinition</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Set&lt;BeanDefinition&gt; <span class="title">scanCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析basePackage，生成绝对地址ClassPath*:/xx/xx/*/**.class</span></span><br><span class="line">      String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +</span><br><span class="line">          resolveBasePackage(basePackage) + <span class="string">'/'</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">      <span class="comment">//通过PathMatchingResourcePatternResolver找到该目录下的Reousrce即文件</span></span><br><span class="line">      Resource[] resources = getResourcePatternResolver().getResources(packageSearchPath);</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (resource.isReadable()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.获取MetadataReader，这里是CachingMetadataReaderFactory，通过SimpleMetadataReaderFactory生成SimpleMetadataReader(resource,defaultResourceLoader.getClassLoader)</span></span><br><span class="line">            MetadataReader metadataReader = getMetadataReaderFactory().getMetadataReader(resource);</span><br><span class="line">            <span class="comment">//判断是否符合条件的Component</span></span><br><span class="line">            <span class="keyword">if</span> (isCandidateComponent(metadataReader)) &#123;</span><br><span class="line">              ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(metadataReader);</span><br><span class="line">              sbd.setResource(resource);</span><br><span class="line">              sbd.setSource(resource);</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               *  isCandidateComponent(sbd)为true</span></span><br><span class="line"><span class="comment">               *    isIndependent不是内部类（内部类对应的外部类为空，且没有static内部类）</span></span><br><span class="line"><span class="comment">               *    isConcrete：不是借口和抽象类 || 是抽象类，但是metadata有Lookup注解</span></span><br><span class="line"><span class="comment">               *  加入到结果集</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="keyword">if</span> (isCandidateComponent(sbd)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">                  logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                candidates.add(sbd);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              ......</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Failed to read candidate component class: "</span> + resource, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidates;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  获取Resource对应的MetadataReader</p><ol><li>这里是CachingMetadataReaderFactory类，它继承了SimpleMetadataReaderFactory调用super.getMetadataReader得到SimpleMetadataReader</li><li>SimpleMetadataReader构造方法SimpleMetadataReader(resource,defaultResourceLoader.getClassLoader)</li><li>SimpleMetadataReader通过spring-asm来操作class文件字节码解析resource（resource通过io读成byte具体如何解析见jvm对class类的解析）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SimpleMetadataReaderFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MetadataReader <span class="title">getMetadataReader</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SimpleMetadataReader(resource, <span class="keyword">this</span>.resourceLoader.getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SimpleMetadataReader</span></span><br><span class="line">SimpleMetadataReader(Resource resource, <span class="meta">@Nullable</span> ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="comment">//观察者</span></span><br><span class="line">  SimpleAnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> SimpleAnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">  getClassReader(resource).accept(visitor, PARSING_OPTIONS);</span><br><span class="line">  <span class="keyword">this</span>.resource = resource;</span><br><span class="line">  <span class="keyword">this</span>.annotationMetadata = visitor.getMetadata();<span class="comment">//获取MetaData</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  调用isCandidateComponent方法，通过MetaDataReader来判断其是否符合注入条件，我们通过ClassPathBeanDefinitionScanner的构造方法层层跟进到registerDefaultFilters方法时候就能知道spring的includeFilters支持那些默认的注解见下面,（如果要实现自定义注解要实现TypeFilter和matcher方法具体见<a href="/Spring源码-实现自定义注解">Spring源码-实现自定义注解</a>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDefaultFilters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Component</span></span><br><span class="line">  <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(Component.class));</span><br><span class="line">  ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//javax.annotation.ManagedBean</span></span><br><span class="line">    <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">        ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.annotation.ManagedBean"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//javax.inject.Named</span></span><br><span class="line">    <span class="keyword">this</span>.includeFilters.add(<span class="keyword">new</span> AnnotationTypeFilter(</span><br><span class="line">        ((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="string">"javax.inject.Named"</span>, cl)), <span class="keyword">false</span>));</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    <span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  isCandidateComponent的方法注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">    <span class="comment">//typteFilter.match返回true</span></span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="comment">//判断condintional是否符合条件，注意里面实现的方法名是shouldSkip这里没有注解或者符合条件返回false</span></span><br><span class="line">      <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  生成BeanDefinition，这里是ScannedGenericBeanDefinition,设置Resource和Source属性，再次isCandidateComponent判断是否符合条件如果符合直接加入到结果candidates中（不是内部类同时 不是接口和抽象类，或者是接口但是方法有Lookup注解）</p><h3 id="处理BeanDefinition"><a href="#处理BeanDefinition" class="headerlink" title="处理BeanDefinition"></a>处理BeanDefinition</h3><p>回到doScan方法，在执行完findCandidateComponents方法回去了需要注册的BeanDefiniton之后，我们要继续填充beanDefiniton的属性，并且注册到registry，见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">  Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">    <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">      <span class="comment">//从definition的Annotated获取Scope注解，根据scope注解获取ScopeMetadata</span></span><br><span class="line">      ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">      candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">      <span class="comment">//生成beanName,从Commponent，或者javax.annotation.ManagedBean、javax.inject.Named的value取，或者系统默认生成</span></span><br><span class="line">      String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">      <span class="comment">//设置beanDefinition的默认属性，设置是否参与自动注入</span></span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//通过注解的MetaData设置属性，用来覆盖默认属性如 lazyInit,Primary,DependsOn,Role,Description属性</span></span><br><span class="line">      <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//注册BeanDefinition</span></span><br><span class="line">      <span class="comment">// 1.!this.registry.containsBeanDefinition(beanName)</span></span><br><span class="line">      <span class="comment">// 2.如果beanName存在，beanDefinition和existingDef兼容，说明不用再次注册</span></span><br><span class="line">      <span class="comment">// （不是ScannedGenericBeanDefinition or source相同 or beanDefinition==existingDefinition）</span></span><br><span class="line">      <span class="comment">// 3.如果beanName存在，还不兼容抛异常ConflictingBeanDefinitionException</span></span><br><span class="line">      <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">        <span class="comment">//创建BeanDefinitionHolder</span></span><br><span class="line">        BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">        definitionHolder =</span><br><span class="line">            AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        <span class="comment">//放到beanDefinitions结果集</span></span><br><span class="line">        beanDefinitions.add(definitionHolder);</span><br><span class="line">        <span class="comment">//注册到registry中</span></span><br><span class="line">        registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-BeanDefinition</title>
      <link href="Spring%E6%BA%90%E7%A0%81-BeanDefinition/"/>
      <url>Spring%E6%BA%90%E7%A0%81-BeanDefinition/</url>
      
        <content type="html"><![CDATA[<p>  我们在xml中配置的bean标签、我们平时用的Component等注解标注的类，在容器中都会转化成BeanDefinition缓存在BeanDefinitionRegistry中。</p><p>  在上一章<a href="/Spring源码-类扫描器-ClassPathBeanDefinitionScanner">Spring源码-类扫描器-ClassPathBeanDefinitionScanner</a>中介绍了通过scan(basePackages)来从指定basePakcages下的class文件到ScannedGenericBeanDefinition的过程，我们本章就以ScannedGenericBeanDefinition来描述BeanDefinition。</p><p>  类图：</p><p>  <img src="/Spring源码-BeanDefinition/ScannedGenericBeanDefinition.png" alt="avator"></p><p>  ScannedGenericBeanDefinition继承自GenericBeanDefinition，GenericBeanDefinition继承自AbstractBeanDefinition，AbstractBeanDefinition实现了BeanDefinition接口。</p><p>  同时实现了AnnotatedBeanDefinition接口用于访问注解的信息。</p><h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String: getBeanClassName: 返回当前bean definition定义的类名</span><br><span class="line">ConstructorArgumentValues: getConstructorArgumentValues:返回bean的构造函数参数</span><br><span class="line">String[]: getDependsOn:返回当前bean所依赖的其他bean的名称</span><br><span class="line">String: getFactoryBeanName: 返回factory bean的名称</span><br><span class="line">String: getFactoryMethodName: 返回工厂方法的名称</span><br><span class="line">BeanDefinition: getOriginatingBeanDefinition: 返回原始的BeanDefinition,如果不存在返回<span class="keyword">null</span></span><br><span class="line">String: getParentName: 返回当前bean definition的父definition的名字</span><br><span class="line">MutablePropertyValues: getPropertyValues: 返回一个用于新的bean实例上的属性值</span><br><span class="line">String: getScope: 返回当前bean的目标范围</span><br><span class="line"><span class="keyword">boolean</span>: isAbstract: 当前bean是否是<span class="keyword">abstract</span>,意味着不能被实例化</span><br><span class="line"><span class="keyword">boolean</span>: isLazyInit: bean是否是延迟初始化</span><br><span class="line"><span class="keyword">boolean</span>: isPrimary: bean是否为自动装配的主要候选bean</span><br><span class="line"><span class="keyword">boolean</span>: isPrototype: bean是否是多实例</span><br><span class="line"><span class="keyword">boolean</span>: isSingleton: bean是否是单例</span><br><span class="line"><span class="keyword">void</span>: setAutowiredCandidate(<span class="keyword">boolean</span>): 设置bean是否对其他bean是自动装配的候选bean</span><br><span class="line"><span class="keyword">void</span>: setBeanClassName(String): 指定bean definition的类名</span><br><span class="line"><span class="keyword">void</span>: setDependsOn(String ...): 设置当前bean初始化所依赖的beans的名称</span><br><span class="line"><span class="keyword">void</span>: setFactoryBeanName(String): 如果factory bean的名称</span><br><span class="line"><span class="keyword">void</span>: setFactoryMethodName(String): 设置工厂的方法名</span><br><span class="line"><span class="keyword">void</span>: setLazyInit(<span class="keyword">boolean</span> lazyInit): 设置是否延迟初始化</span><br><span class="line"><span class="keyword">void</span>: setParentName(String): 设置父definition的名称</span><br><span class="line"><span class="keyword">void</span>: setPrimary(<span class="keyword">boolean</span>): 设置是否主要的候选bean</span><br><span class="line"><span class="keyword">void</span>: setScope(String): 设置bean的范围,如:单例,多实例</span><br></pre></td></tr></table></figure><h2 id="AnnotatedBeanDefinition"><a href="#AnnotatedBeanDefinition" class="headerlink" title="AnnotatedBeanDefinition"></a>AnnotatedBeanDefinition</h2><p>  功能<br>  继承了BeanDefinition接口,并添加了对注解元数据访问的方法</p><p>  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span>: 获得当前bean definition 的bean 类<span class="params">(class)</span>的注解元数据</span></span><br><span class="line"><span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span>: 获得当前bean definition 的工厂方法上的元数据</span></span><br></pre></td></tr></table></figure><h2 id="AbstractBeanDefinition、GenericBeanDefinition"><a href="#AbstractBeanDefinition、GenericBeanDefinition" class="headerlink" title="AbstractBeanDefinition、GenericBeanDefinition"></a>AbstractBeanDefinition、GenericBeanDefinition</h2><p>  功能<br>  BeanDefinition的实现抽象类，GenericBeanDefinition继承自AbstractBeanDefinition</p><h2 id="RootBeanDefinition"><a href="#RootBeanDefinition" class="headerlink" title="RootBeanDefinition"></a>RootBeanDefinition</h2><p>  功能<br>  spring的BeanDefinition有可能会包含parentName属性对应parentBeanDefinition，RootBeanDefinition会和parent的BeanDefinition进行Merge，容器根据RootBeanDefinition实例化对象。</p><p>  应用</p><ul><li>在refresh方法的preInstantiateSingletons()中，将所有的non-lazy-init的单例的BeanDefinition实例化，</li><li><p>getType、getBean</p><p>关键代码：getMergedBeanDefinition 将parentBeanDefinition和childBeanDefinition合并。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RootBeanDefinition <span class="title">getMergedBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String beanName, BeanDefinition bd, @Nullable BeanDefinition containingBd)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>.mergedBeanDefinitions) &#123;</span><br><span class="line">    RootBeanDefinition mbd = <span class="keyword">null</span>;</span><br><span class="line">    RootBeanDefinition previous = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check with full lock now in order to enforce the same merged instance.</span></span><br><span class="line">    <span class="keyword">if</span> (containingBd == <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbd = <span class="keyword">this</span>.mergedBeanDefinitions.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || mbd.stale) &#123;</span><br><span class="line">      previous = mbd;</span><br><span class="line">      <span class="comment">//没有parentBean,直接clone或者create</span></span><br><span class="line">      <span class="keyword">if</span> (bd.getParentName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use copy of given root bean definition.</span></span><br><span class="line">        <span class="keyword">if</span> (bd <span class="keyword">instanceof</span> RootBeanDefinition) &#123;</span><br><span class="line">          mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          mbd = <span class="keyword">new</span> RootBeanDefinition(bd);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Child bean definition: needs to be merged with parent.</span></span><br><span class="line">        <span class="comment">//获取parentBean</span></span><br><span class="line">        BeanDefinition pbd;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          String parentBeanName = transformedBeanName(bd.getParentName());</span><br><span class="line">          <span class="keyword">if</span> (!beanName.equals(parentBeanName)) &#123;</span><br><span class="line">            <span class="comment">//beanName和parentBeanName不相等，后去parentBean</span></span><br><span class="line">            pbd = getMergedBeanDefinition(parentBeanName);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果相等，parentFactory是ConfigurableBeanFactory，merge(这里本质上是递归的方式，知道所有的parent都merge)</span></span><br><span class="line">            BeanFactory parent = getParentBeanFactory();</span><br><span class="line">            <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> ConfigurableBeanFactory) &#123;</span><br><span class="line">              pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,</span><br><span class="line">                  <span class="string">"Parent name '"</span> + parentBeanName + <span class="string">"' is equal to bean name '"</span> + beanName +</span><br><span class="line">                  <span class="string">"': cannot be resolved without an AbstractBeanFactory parent"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,</span><br><span class="line">              <span class="string">"Could not resolve parent bean definition '"</span> + bd.getParentName() + <span class="string">"'"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deep copy with overridden values.</span></span><br><span class="line">        mbd = <span class="keyword">new</span> RootBeanDefinition(pbd);<span class="comment">//创建parent的Root</span></span><br><span class="line">        mbd.overrideFrom(bd);<span class="comment">//merage</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set default singleton scope, if not configured before.</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;</span><br><span class="line">        mbd.setScope(SCOPE_SINGLETON);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A bean contained in a non-singleton bean cannot be a singleton itself.</span></span><br><span class="line">      <span class="comment">// Let's correct this on the fly here, since this might be the result of</span></span><br><span class="line">      <span class="comment">// parent-child merging for the outer bean, in which case the original inner bean</span></span><br><span class="line">      <span class="comment">// definition will not have inherited the merged outer bean's singleton status.</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd != <span class="keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;</span><br><span class="line">        mbd.setScope(containingBd.getScope());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Cache the merged bean definition for the time being</span></span><br><span class="line">      <span class="comment">// (it might still get re-merged later on in order to pick up metadata changes)</span></span><br><span class="line">      <span class="keyword">if</span> (containingBd == <span class="keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">      copyRelevantMergedBeanDefinitionCaches(previous, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mbd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-Bean的生命周期</title>
      <link href="Spring%E6%BA%90%E7%A0%81-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>Spring%E6%BA%90%E7%A0%81-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>Spring容器中一个bean的生命周期如下：</p><h2 id="Bean初始化前"><a href="#Bean初始化前" class="headerlink" title="Bean初始化前"></a>Bean初始化前</h2><p>  BeanFactoryPostProcessor–&gt;postProcessBeanFactory方法：针对的是BeanFactroy，在BeanFactroy的refresh方法中的invokeBeanFactoryPostProcessors中这一步。</p><p>  作用：可以获取BeanDefiniton并且赋予一些属性初始值。</p><h2 id="Bean初始化过程"><a href="#Bean初始化过程" class="headerlink" title="Bean初始化过程"></a>Bean初始化过程</h2><p>  构造方法</p><p>  BeanNameAware–&gt;setBeanName方法:实现BeanNameAware接口，将BeanName传给Bean，在initializeBean过程中调用<br>  作用：Bean可以获取BeanName</p><p>  ApplicationContextAware–&gt;setApplicationContext方法:实现ApplicationContextAware接口，将ApplicationContext传给Bean，在prepareBeanFactory过程中将ApplicationContextAwareProcessor加到beanFactory，在initializeBean方法中调用postProcessBeforeInitialization<br>  作用：Bean可以获取ApplicationContext</p><p>  BeanPostProcessor–&gt;postProcessBeforeInitialization方法：不同于BeanFactoryPostProcessor的是，这里针对的是Bean对象本身，在initializeBean方法中的applyBeanPostProcessorsBeforeInitialization方法调用<br>  作用：针对特定的bean可以修改bean的属性等</p><p>  @PostConstruct方法：通过注解@PostConstruct执行的方法，在构造函数后面执行。</p><p>  InitializingBean–&gt;afterPropertiesSet方法：实现InitializingBean接口，在initializeBean方法中调用</p><p> BeanPostProcessor–&gt;postProcessAfterInitialization方法：初始化Bean之后执行</p><p> DisposableBean–&gt;destroy方法：bean的销毁方法，在容器被销毁时候回被调用<br> 作用：执行bean的清理工作等。</p><p> 演示代码如下，请分别创建如下的文件。自行修改basePackages</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjImpl</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>, <span class="title">BeanNameAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String beanName=<span class="string">""</span>;</span><br><span class="line">  <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> TestObjImplWithOutAnnoation testObjImplWithOutAnnoation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TestObjImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"@PostConstruct方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BeanNameAware--&gt;setBeanName 方法"</span>);</span><br><span class="line">    <span class="keyword">this</span>.beanName = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"InitializingBean--&gt;afterPropertiesSet 方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"ApplicationContextAware--&gt;setApplicationContext  方法"</span>);</span><br><span class="line">    <span class="keyword">this</span>.applicationContext=applicationContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"DisposableBean--&gt;destroy 方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(beanName+<span class="string">" say hello"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanPostProcessor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestObjImpl) &#123;</span><br><span class="line">      System.out.println(<span class="string">"BeanPostProcessor--&gt;postProcessBeforeInitialization==="</span>+beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestObjImpl) &#123;</span><br><span class="line">      System.out.println(<span class="string">"BeanPostProcessor--&gt;postProcessAfterInitialization ==="</span>+beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BeanFactoryPostProcessor</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"BeanFactoryPostProcessor--&gt;postProcessBeanFactory 方法"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Starter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext= <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"basePackages 需要自行修改"</span>);</span><br><span class="line">    TestObj obj=applicationContext.getBean(TestObj.class);</span><br><span class="line">    obj.hello();</span><br><span class="line">    applicationContext.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-BeanDefinitionRegistryPostProcessor</title>
      <link href="Spring%E6%BA%90%E7%A0%81-BeanDefinitionRegistryPostProcessor/"/>
      <url>Spring%E6%BA%90%E7%A0%81-BeanDefinitionRegistryPostProcessor/</url>
      
        <content type="html"><![CDATA[<p> 作用：用于动态的生成BeanDefinition，因为无论是xml还是注解都是通过配置静态的生成BeanDefinition并且注册到容器中。我们可以通过实现BeanDefinitionRegistryPostProcessor接口来动态的生成、注册Bean。<br> 原理：</p><ul><li>实现BeanDefinitionRegistryPostProcessor接口，并且注入到容器中；</li><li><p>执行过程：在ApplicationContext的Refresh()方法中，会调用invokeBeanFactoryPostProcessors方法会调用容器中所有实现了BeanDefinitionRegistryPostProcessor接口的类的postProcessBeanDefinitionRegistry方法，在该方法中我们可以动态的创建、注册bean见下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryDemo</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        definition.setBeanClass(Demo.class);    <span class="comment">//设置类</span></span><br><span class="line">        definition.setScope(<span class="string">"singleton"</span>);       <span class="comment">//设置scope</span></span><br><span class="line">        definition.setLazyInit(<span class="keyword">false</span>);          <span class="comment">//设置是否懒加载</span></span><br><span class="line">        definition.setAutowireCandidate(<span class="keyword">true</span>);  <span class="comment">//设置是否可以被其他对象自动注入</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">"demo"</span>, definition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-LifecycleProcessor</title>
      <link href="Spring%E6%BA%90%E7%A0%81-LifecycleProcessor/"/>
      <url>Spring%E6%BA%90%E7%A0%81-LifecycleProcessor/</url>
      
        <content type="html"><![CDATA[<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>  Lifecycle:容器的生命周期回调，容器启动之后运行到某些节点（容器start/stop时候）可以回调Lifecycle子类的方法。比如在容器启动后初始化资源池，在容器停止时候调用资源池销毁的动作</p><p>  我们实现Lifecycle中接口。注：建议实现SmartLifecycle接口，因为它Lifecycle接口的加强接口，默认实现了stop(Runnable callback)，在调用中通过一个CountdownLatch来异步处理stop,SmartLifecycle非常不建议实现stop(Runnable callback)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">    stop();</span><br><span class="line">    callback.run();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DEFAULT_PHASE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在Lifecycle的基础上实现了onRefresh和onClose接口。参见前面：<a href="/Spring源码-ApplicationContext">Spring源码-ApplicationContext</a>文章中finishRefresh中的代码片段。onRefresh会调用Lifecycle实现类的start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line"><span class="comment">//初始化LifecycleProcessor</span></span><br><span class="line">initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line"><span class="comment">//调用上面的LifecycleProcessor.onRefresh()</span></span><br><span class="line">getLifecycleProcessor().onRefresh();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>tbd</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-实现自定义注解</title>
      <link href="Spring%E6%BA%90%E7%A0%81-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>Spring%E6%BA%90%E7%A0%81-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>  实现自定义的TypeFilter如下,实现match方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title">TypeFilter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    AnnotationMetadata annotationMetadate = metadataReader.getAnnotationMetadata();</span><br><span class="line">    <span class="comment">//获取当前正在扫描的类的信息</span></span><br><span class="line">    ClassMetadata classMethod = metadataReader.getClassMetadata();</span><br><span class="line">    <span class="comment">//获取当前类资源</span></span><br><span class="line">    Resource resource = metadataReader.getResource();</span><br><span class="line">    String className = classMethod.getClassName();</span><br><span class="line">    <span class="keyword">if</span>(annotationMetadate.getClassName().equals(<span class="string">"com.ericliu.spring.scaner.LiuHaoMyAnnotionTest"</span>))&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在容器启动的类上或者configur类上添加如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(value = <span class="string">"com.ericliu.spring.**"</span>, includeFilters = &#123;</span><br><span class="line">    <span class="meta">@ComponentScan</span>.Filter(type = FilterType.CUSTOM, classes = &#123;MyTypeFilter.class&#125;)</span><br><span class="line">&#125;, useDefaultFilters = <span class="keyword">true</span>)<span class="comment">//这里要写true否则，component等注解都无法使用</span></span><br></pre></td></tr></table></figure><p>  容器启动后如果设置了basePackage，在doscan时候回调用isCandidateComponent方法，会调用上面的match的方法如果true会将对应的class生成BeanDefiniton，在注入到容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(MetadataReader metadataReader)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.excludeFilters) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (TypeFilter tf : <span class="keyword">this</span>.includeFilters) &#123;</span><br><span class="line">    <span class="comment">//typteFilter.match返回true</span></span><br><span class="line">    <span class="keyword">if</span> (tf.match(metadataReader, getMetadataReaderFactory())) &#123;</span><br><span class="line">      <span class="comment">//判断condintional是否符合条件，注意里面实现的方法名是shouldSkip这里没有注解或者符合条件返回false</span></span><br><span class="line">      <span class="keyword">return</span> isConditionMatch(metadataReader);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码-带着问题学习</title>
      <link href="Spring%E6%BA%90%E7%A0%81-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/"/>
      <url>Spring%E6%BA%90%E7%A0%81-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>spring可以说是java有史以来最为庞大，应用最为广泛的框架，在看源码之前应该先立足于某一点在逐步发散到面。本文主要是整理观看spring源码前/中遇到的问题，以便于读代码更有针对性</p><h2 id="spring的IOC和AOP"><a href="#spring的IOC和AOP" class="headerlink" title="spring的IOC和AOP"></a>spring的IOC和AOP</h2><p>问题：</p><ol><li>Spring容器中的Bean的生命周期是什么？</li><li>对应的PostProcessor什么时候执行？有什么作用</li><li>BeanDefinition的架构以及spring的设计思想</li><li>BeanFactory和ApplicationContext的关系是什么？他们的作用是什么？</li><li>ApplicationContext的构造函数都做了什么？<ol><li>scan/register做了什么事？</li><li>refresh做了什么事？</li><li>refresh的详细的流程，对照着bean的生命周期看</li></ol></li><li>AnnotationConfigUtils.registerAnnotationConfigProcssors做什么用的？</li><li>Spring的自动装配策略是什么（byType–&gt;Primary–&gt;Propity–&gt;ByName）具体见<a href="https://www.jb51.net/article/157767.htm" target="_blank" rel="noopener">临时链接</a></li><li>ClassPathBeanDefinitionScanner、AnnotatedBeanDefinitionReader的作用 <a href="/Spring源码-类扫描器-ClassPathBeanDefinitionScanner">Spring源码-类扫描器-ClassPathBeanDefinitionScanner</a></li><li>为什么@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解这些注解能注册到容器中<a href="/Spring源码-实现自定义注解">Spring源码-实现自定义注解</a></li><li>Spring如何实现自定义注解，它是怎么实现的(CommponentScan，inculudFilter)</li><li>Resource到BeanDefiniton的过程相关的问题，从resource–&gt;SimpleMetadataReader–&gt;BeanDefinition（since 2020-01-28）<ol><li>SimpleMetadataReader的作用是什么？</li><li>需要用到的spring-io中的ResourceLoader需要明确是做什么用的</li><li>SimpleMetadataReader构造方法中用到了spring-asm是做什么用的</li><li>Lookup注解干什么用的</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> RoketMq源码学习-八-延迟队列</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%85%AB-%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>在业务中我们发送定时消息等会用到，延迟队列，rocketmq内置了该功能，帮我实现这种延迟队列。实现很简单</p><h2 id="实现方式、原理"><a href="#实现方式、原理" class="headerlink" title="实现方式、原理"></a>实现方式、原理</h2><ol><li>生成者发送消息时候为消息设置setDelayTimeLevel，mq不能自己指定延时时间而只能采用系统设置好的level</li><li>broker在putmessage时候会将message的real-topic备份，然后将message放到SCHEDULE_TOPIC_XXXX这个topic中，根据delayLevel制定不同的queueId。</li><li>ScheduleMessageService会启动timer定期扫描各个delayLevel的Queue，已经到执行时间的message在将SCHEDULE_TOPIC_XXXX的message移到real-topic中。</li></ol><p>缺点：由于是一个timer在扫描SCHEDULE_TOPIC_XXXX下所有queue的消息，如果消息积压过多于可能造成消息的发送延迟。可以考虑每个level用一个线程取扫描（不过也要考虑线程切换的成本导致频繁切换反而降低性能）</p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h3><p>producer发送消息，设置level</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDelayTimeLevel</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.putProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL, String.valueOf(level));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><h4 id="broker处理putMessage"><a href="#broker处理putMessage" class="headerlink" title="broker处理putMessage"></a>broker处理putMessage</h4><ol><li>CommitLog.putMessage保存信息会将真实的topic的备份放到指定队列</li><li>DefaultMessageStore的ReputMessage在写CounmeQueue的时候会计算DeliverTime并且写入到tagCode中</li></ol><p>见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//消息不是事物类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery Message</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//延时消息--将消息投递到</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId 将消息设置成topic</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在ConsumeQueue存储消息信息时候会将tagCode设置为发送的日期</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 生成重放消息重放调度请求，-1-失败，0-到文件尾，1-正常</span></span><br><span class="line">    DispatchRequest dispatchRequest =</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatchRequest <span class="title">checkMessageAndReturnSize</span><span class="params">(java.nio.ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">boolean</span> checkCRC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">final</span> <span class="keyword">boolean</span> readBody)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// Timing message processing 延时消息将tagsCode设置为时间戳，</span></span><br><span class="line">            &#123;</span><br><span class="line">                String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">                <span class="keyword">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> delayLevel = Integer.parseInt(t);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                        delayLevel = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//计算DeliverTimestamp</span></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        tagsCode = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,</span><br><span class="line">                                storeTimestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="ScheduleMessageService"><a href="#ScheduleMessageService" class="headerlink" title="ScheduleMessageService"></a>ScheduleMessageService</h4><p>  level的个数的设置由MessageStoreConfig的messageDelayLevel决定。rocketmq只能按照这个设置来决定消息的延迟时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageDelayLevel = <span class="string">"1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h"</span>;</span><br></pre></td></tr></table></figure><ol><li>初始化：BrokerController在initialize()时候初始化DefaultMessageStore，DefaultMessageStore会初始化ScheduleMessageService，ScheduleMessageService负责定时任务的check和调度。</li><li>load加载配置：BrokerController在initialize()会调用DefaultMessageStore的load，在该方法中会调用ScheduleMessageService的load,关键代码如下</li><li><p>启动：在BrokerController.start后，随着DefaultMessageStore的start而启动。</p><p>加载配置的过程</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DefaultMessageStore的关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != scheduleMessageService) &#123;</span><br><span class="line">        result = result &amp;&amp; <span class="keyword">this</span>.scheduleMessageService.load();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduleMessageService的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    <span class="comment">//初始化配置的DelayLevel</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.parseDelayLevel();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">parseDelayLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Long&gt; timeUnitTable = <span class="keyword">new</span> HashMap&lt;String, Long&gt;();</span><br><span class="line">    timeUnitTable.put(<span class="string">"s"</span>, <span class="number">1000L</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"m"</span>, <span class="number">1000L</span> * <span class="number">60</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"h"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span>);</span><br><span class="line">    timeUnitTable.put(<span class="string">"d"</span>, <span class="number">1000L</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    String levelString = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMessageDelayLevel();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String[] levelArray = levelString.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; levelArray.length; i++) &#123;</span><br><span class="line">            String value = levelArray[i];</span><br><span class="line">            <span class="comment">//1h--&gt;ch=h,tu=1000L * 60 * 60</span></span><br><span class="line">            String ch = value.substring(value.length() - <span class="number">1</span>);</span><br><span class="line">            Long tu = timeUnitTable.get(ch);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化maxDelayLevel</span></span><br><span class="line">            <span class="keyword">int</span> level = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (level &gt; <span class="keyword">this</span>.maxDelayLevel) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maxDelayLevel = level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//1h--&gt;1</span></span><br><span class="line">            <span class="keyword">long</span> num = Long.parseLong(value.substring(<span class="number">0</span>, value.length() - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">long</span> delayTimeMillis = tu * num;</span><br><span class="line">            <span class="comment">//put levelIndex,1*1000L * 60 * 60</span></span><br><span class="line">            <span class="keyword">this</span>.delayLevelTable.put(level, delayTimeMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"parseDelayLevel exception"</span>, e);</span><br><span class="line">        log.info(<span class="string">"levelString String = &#123;&#125;"</span>, levelString);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历delayLevelTable，找到每个level的offset,然后异步的启动DeliverDelayedMessageTimerTask去检查</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Long&gt; entry : <span class="keyword">this</span>.delayLevelTable.entrySet()) &#123;</span><br><span class="line">        Integer level = entry.getKey();</span><br><span class="line">        Long timeDelay = entry.getValue();</span><br><span class="line">        Long offset = <span class="keyword">this</span>.offsetTable.get(level);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == offset) &#123;</span><br><span class="line">            offset = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeDelay != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//关键代码，每个level和offset会创建一个DeliverDelayedMessageTimerTask，第一次FIRST_DELAY_TIME（1s后执行）</span></span><br><span class="line">            <span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.persist();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"scheduleAtFixedRate flush exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">10000</span>, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DeliverDelayedMessageTimerTask没有采用for/while循环这种来保证扫描delayQueue的实时性，而是每次根据处理Messagge的结果在启动一</li><li>DeliverDelayedMessageTimerTask来控制频次、和保证实时性。在DeliverDelayedMessageTimerTask的run方法中调用executeOnTimeup这个是主要逻辑</li><li>由于延期消息是队列，所以相同粒度的延期信息一定是按照顺序写入到队列中的。所以如果当前消息没到发布时间，后面所有消息就都没到发布时间。具体见下面代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeOnTimeup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据delayLevel找到制定的consumerQueue</span></span><br><span class="line">    ConsumeQueue cq =</span><br><span class="line">        ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.findConsumeQueue(SCHEDULE_TOPIC,</span><br><span class="line">            delayLevel2QueueId(delayLevel));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> failScheduleOffset = offset;</span><br><span class="line">    <span class="keyword">if</span> (cq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//步骤1，在consumerQueue中根据偏移量找到这条消息的索引信息</span></span><br><span class="line">        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(<span class="keyword">this</span>.offset);</span><br><span class="line">        <span class="keyword">if</span> (bufferCQ != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> nextOffset = offset;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//获取cqExtUnit</span></span><br><span class="line">                ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                <span class="keyword">for</span> (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                    <span class="keyword">long</span> offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                    <span class="keyword">int</span> sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">                    <span class="comment">//tagsCode-在conumeQueue持久化时候已经变味了DeliverTimestamp</span></span><br><span class="line">                    <span class="keyword">long</span> tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">                            tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//can't find ext content.So re compute tags code.</span></span><br><span class="line">                            log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;"</span>,</span><br><span class="line">                                tagsCode, offsetPy, sizePy);</span><br><span class="line">                            <span class="keyword">long</span> msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);</span><br><span class="line">                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//步骤2，计算过期时间</span></span><br><span class="line">                    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">                    <span class="comment">//修正deliverTimestamp,如果deliverTimestamp&gt;now+delayMills说明过期了</span></span><br><span class="line">                    <span class="keyword">long</span> deliverTimestamp = <span class="keyword">this</span>.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line"></span><br><span class="line">                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> countdown = deliverTimestamp - now;</span><br><span class="line">                    <span class="keyword">if</span> (countdown &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//到期了开始投递消息</span></span><br><span class="line">                        MessageExt msgExt =</span><br><span class="line">                            ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore.lookMessageByOffset(</span><br><span class="line">                                offsetPy, sizePy);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (msgExt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//修改realTopic，发送消息</span></span><br><span class="line">                                MessageExtBrokerInner msgInner = <span class="keyword">this</span>.messageTimeup(msgExt);</span><br><span class="line">                                PutMessageResult putMessageResult =</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.defaultMessageStore</span><br><span class="line">                                        .putMessage(msgInner);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//发送成功后，继续处理下一条消息</span></span><br><span class="line">                                <span class="keyword">if</span> (putMessageResult != <span class="keyword">null</span></span><br><span class="line">                                    &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">//发送失败，10sec后在开始下一轮扫描</span></span><br><span class="line">                                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                                    log.error(</span><br><span class="line">                                        <span class="string">"ScheduleMessageService, a message time up, but reput it failed, topic: &#123;&#125; msgId &#123;&#125;"</span>,</span><br><span class="line">                                        msgExt.getTopic(), msgExt.getMsgId());</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                                        <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                            nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                                    ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">                                        nextOffset);</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                 * <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line"><span class="comment">                                 */</span></span><br><span class="line">                                log.error(</span><br><span class="line">                                    <span class="string">"ScheduleMessageService, messageTimeup execute error, drop it. msgExt="</span></span><br><span class="line">                                        + msgExt + <span class="string">", nextOffset="</span> + nextOffset + <span class="string">",offsetPy="</span></span><br><span class="line">                                        + offsetPy + <span class="string">",sizePy="</span> + sizePy, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//消息没到期，创建Task扫描一次该消息，延期countdown防止无谓的计算</span></span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(</span><br><span class="line">                            <span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel, nextOffset),</span><br><span class="line">                            countdown);</span><br><span class="line">                        ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="comment">// end of for</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//队列所有消息都扫描结束后，100L后开启下一轮扫描</span></span><br><span class="line">                <span class="comment">//由于延期消息是队列，所以相同粒度的延期信息一定是按照顺序写入到队列中的。所以如果当前消息没到发布时间，后面所有消息就都没到发布时间。具体见下面代码</span></span><br><span class="line">                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(</span><br><span class="line">                    <span class="keyword">this</span>.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">                ScheduleMessageService.<span class="keyword">this</span>.updateOffset(<span class="keyword">this</span>.delayLevel, nextOffset);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                bufferCQ.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end of if (bufferCQ != null)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">            <span class="keyword">if</span> (offset &lt; cqMinOffset) &#123;</span><br><span class="line">                failScheduleOffset = cqMinOffset;</span><br><span class="line">                log.error(<span class="string">"schedule CQ offset invalid. offset="</span> + offset + <span class="string">", cqMinOffset="</span></span><br><span class="line">                    + cqMinOffset + <span class="string">", queueId="</span> + cq.getQueueId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// end of if (cq != null)</span></span><br><span class="line"></span><br><span class="line">    ScheduleMessageService.<span class="keyword">this</span>.timer.schedule(<span class="keyword">new</span> DeliverDelayedMessageTimerTask(<span class="keyword">this</span>.delayLevel,</span><br><span class="line">        failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存模型与线程</title>
      <link href="JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>  是对之前java并发的一个补充。：P</p><p>  java的操作都是将数据从主内存加载到工作内存去做操作，为了保证线程的安全归定了几个原子性操作。</p><h2 id="java的几个原子性操作"><a href="#java的几个原子性操作" class="headerlink" title="java的几个原子性操作"></a>java的几个原子性操作</h2><ul><li>read：主内存，将数据从主内存传输到工作内存，以便load使用</li><li>load：工作内存，将read的变量副本放入到工作内存中</li><li>assign：工作内存，赋值操作。将执行引擎（jvm）中的值赋值给变量。</li><li>use：工作内存，把工作内存中的值传递给执行引擎。</li><li>store：工作内存，将数据传输到主内存中，以便write操作使用</li><li>write：主内存，将数据写入到主内存中。</li><li>lock：主内存，将变量标识为线程独占</li><li>unlock：主内存，释放锁标记，标识变量变为共享状态。</li></ul><p>几个规定</p><ul><li>read和load，store和write成对出现，并且先后顺序不能改变</li><li>assign必须在load之后，且assign之后必须写会主内存，且加载到内存的变量必须assign</li><li>use、store之前必须assign，load</li><li>lock操作后工作内存会被清空</li><li>unlock必须在lock之后，且unlock必须等待变量别写会主内存。</li></ul><h2 id="保证线程安全的3个要点"><a href="#保证线程安全的3个要点" class="headerlink" title="保证线程安全的3个要点"></a>保证线程安全的3个要点</h2><ul><li>原子性：8个原子操作</li><li>可见性：voltile、final、synchrozied可以保证</li><li>顺序性：voltile、synchrozied</li></ul><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><p>1:1模型：使用内核线程，实现简单，但是无法支持高并发因为内核态和用户态消耗大，并且由于是1：1无法支持高并发。<br>1:N：使用用户线程，可支持高并发，但是调度等实现难度大。<br>N:M：用户线程用于并发，内核线程用于调度。综合上面俩种优缺点。</p><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>new:new一个线程<br>run:执行start<br>block:synchronized<br>wait:没有参数的wait<br>time_waiting:有参数的wait和sleep</p><h2 id="jvm的锁优化"><a href="#jvm的锁优化" class="headerlink" title="jvm的锁优化"></a>jvm的锁优化</h2><p>由于锁需要从用户态转到内核态作为控制，所以采用如下几种优化方案。</p><ul><li>锁消除：通过逃逸分析发现没有变量逃逸的情况，会去掉锁。</li><li>锁粗化：如果多一个对象反复加锁、解锁会考虑合并</li><li>偏向锁：如果当前线程获取锁，复制markword,markword修改锁标记位，以及获取锁线程的线程ID；</li><li>轻量级锁：如果遇到竞争，复制markword，markword修改锁标记位，以及锁的lockrecord地址。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的编译优化-后期</title>
      <link href="JVM%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%90%8E%E6%9C%9F/"/>
      <url>JVM%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%90%8E%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>  JIT(java in time complier)，即为了提高热点代码效率将代码编译成本地代码。</p><h2 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h2><p>  HotSpot采用的是解释器与编译器共存。</p><p>  解释器可以发挥编译优势，省去编译成本地代码的时间，直接运行；编译器把反复执行的代码编译成本地代码提高执行效率。同时如果编译器的优化比较激进发现编译后的结果不成立可以通过解释器退回到之前状态。</p><p>  解释器和编译器这种搭配方式称为混合模式。可以通过-Xint来控制</p><h2 id="俩个编译器ClientComplier和ServerComplier"><a href="#俩个编译器ClientComplier和ServerComplier" class="headerlink" title="俩个编译器ClientComplier和ServerComplier"></a>俩个编译器ClientComplier和ServerComplier</h2><p>ClientComplier注重编译速度，ServerComplier注重编译的质量。HotSpot在JDK1.7时代默认采用分层编译</p><ul><li>C0：解释执行</li><li>C1：将字节码编译成本地代码，简单的优化。</li><li>C2：会启用一些耗时优化。</li></ul><h2 id="出发条件"><a href="#出发条件" class="headerlink" title="出发条件"></a>出发条件</h2><p>HotSpot采用基于计数器的方式。</p><ul><li>方法的重复调用<ul><li>条件：重复一定次数（方法调用计数器控制）</li><li>方式：调用次数+1.触发阈值后发送编译请求。编译完成后替换方法地址</li><li>半衰周期：当一段时间没到阈值会，方法调用计数器会衰减一半</li><li>默认值：client:1500,server:10000</li></ul></li><li>循环体的调用：OSR(on stack replacement)栈上替换，发生在运行时的方法栈<ul><li>条件：重复一定次数（回边计数器）</li><li>方式：以方法为单位如果，每一次循环回边计数器都+1，如果回边计数器和方法调用计数器超过一定数值后发送编译请求。（这时候重新调整计数器以便继续循环）编译完成后替换方法地址</li></ul></li></ul><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>后台编译</p><p><img src="/JVM的编译优化-后期/clientcomiler.png" alt="client-compile"></p><p>具体的HIR LIR我也没太看明白以后看编译原理在不上:P</p><h2 id="编译优化的技术"><a href="#编译优化的技术" class="headerlink" title="编译优化的技术"></a>编译优化的技术</h2><p>编译代码比解释代码优化，一方面是没有虚拟接解释代码的消耗，一方面是所有的代码优化措施都集中在JIT上。</p><h3 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h3><p><img src="/JVM的编译优化-后期/jit优化技术.png" alt="jit优化技术"><br><img src="/JVM的编译优化-后期/jit优化技术2.png" alt="jit优化技术"></p><h3 id="公共子表达式优化"><a href="#公共子表达式优化" class="headerlink" title="公共子表达式优化"></a>公共子表达式优化</h3><p>比如程序有俩个b<em>c和c</em>b，javac不会进行优化，java则会优化成E=b*c,然后代码使用E</p><h3 id="异常消除"><a href="#异常消除" class="headerlink" title="异常消除"></a>异常消除</h3><p>NullPointer，ArrayIndexOutOfBounds等异常信息，在运行时如果不优化每次判断都会带来开销，所以jit会对齐进行优化，消除这些隐式的判断。而且会根据Profile收集到的信息进行“智能”优化。比如一个对象经常为空的情况就不回采用try catch的优化。</p><h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><p>由于JAVA是面向对象的，很对方法是虚方法，为了优化就采用CHA，如果是虚方法会去查询有几个版本如果只有一个版本会进行内联，如果继承关系发生改变，比如动态代码，这时候要退回解释执行。如果发现多个版本还会采用Inline Cache来尝试内联</p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>栈上分配、同步消除、标量替换</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的编译优化-前期</title>
      <link href="JVM%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%89%8D%E6%9C%9F/"/>
      <url>JVM%E7%9A%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96-%E5%89%8D%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>JAVA是将类文件编译后生成操作码交给解释器执行，所以是解释性语言。</p><h2 id="面向栈的指令集和面向寄存器的指令集"><a href="#面向栈的指令集和面向寄存器的指令集" class="headerlink" title="面向栈的指令集和面向寄存器的指令集"></a>面向栈的指令集和面向寄存器的指令集</h2><p>  java是通过操作码将数据压入/弹出到操作栈中进行操作，所以是面向栈的，而还有一种流派是直接生成本地代码调用寄存器的指令，<br>  俩者的区别。</p><ul><li>面向栈：便于移植，代码简单，由于不依赖寄存器，支持寄存器不支持的功能。由于执行指令多所以性能差</li><li>面向寄存器：不便于移植，功能依赖于CPU等硬件。性能好</li></ul><h2 id="javac编译的过程"><a href="#javac编译的过程" class="headerlink" title="javac编译的过程"></a>javac编译的过程</h2><p><img src="/JVM的编译优化/javac编译过程.png" alt="编译过程"></p><p>源码如下</p><p><img src="/JVM的编译优化/javac编译过程的主题代码.png" alt="编译过程"></p><h3 id="解析文件和添加符号表"><a href="#解析文件和添加符号表" class="headerlink" title="解析文件和添加符号表"></a>解析文件和添加符号表</h3><ul><li>词法、语法分析：通过词法分析器和语法分析器生成抽象语法树</li><li>输入到符号表：将语法树种的在javac源码就是enterTree过程，符号表是一个kv的数据结构，用于收集符号以及变量，在语义校验阶段用于校验语法和产生中间代码，目标代码生成阶段是分配符号内存的依据</li></ul><h3 id="注解处理器处理注解"><a href="#注解处理器处理注解" class="headerlink" title="注解处理器处理注解"></a>注解处理器处理注解</h3><p>JDK1.5之后支持了注解，实际上是一个个的语法插件，会对语法树进行读取、修改，如果对语法树进行修改，需要重新解析文件和添加符号表，称为Round。也就是图上的回环</p><h3 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h3><ul><li>标注检查：检查变量是否已经声明，类型与赋值类型是否匹配。</li><li>数据及控制流分析：进一步对语法和语义做检查。注意局部变量设置为final的语义检查是在编译器的，因为局部变量没有该final的常量标志位，所以在编译后是否声明称final没有区别。</li><li>解语法糖：泛型、自动装箱、拆箱等都需要在编译阶段还原。</li><li>字节码生成：<ul><li>实例构造器init方法和类构造器clinit方法添加到语法树，将调用父类的实例构造器等方法收敛到这俩个方法中</li><li>优化操作：将String的添加等操作改为StringBuffer.append</li></ul></li></ul><h2 id="JAVA语法糖详解"><a href="#JAVA语法糖详解" class="headerlink" title="JAVA语法糖详解"></a>JAVA语法糖详解</h2><h3 id="泛型和类型擦除"><a href="#泛型和类型擦除" class="headerlink" title="泛型和类型擦除"></a>泛型和类型擦除</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM虚拟机执行引擎</title>
      <link href="JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>java的执行引擎是虚拟机自己提供的，所以更加灵活可以支持应将不支持的指令集。（对硬件指令集的封装 :P）</p><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>  jvm执行方法调用的数据结构，一个方法从开始执行到结束执行是一次入栈出栈的过程。<br>  在便宜Class文件时候局部变量表占用内存的大小和栈帧深度都已经决定好了。<br>  一个方法执行调用链会很长，只有当前的线程中调用栈栈顶的栈帧才能被执行，该栈帧被称为当前栈帧（Current Frame）对应的方法是当前方法(Current Method),栈帧结构如图：</p><p><img src="/JVM虚拟机执行引擎/framestack.png" alt="栈帧结构]">  </p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>  总共有byte、short、int、short、boolean、float、refrence、returnAddress  8种。</p><p>  在编译期就在方法的Code属性max_locals就决定了大小。局部变量表的大小单位是Slot,虚拟机规定者byte、short、int、boolean、refrence、returnAddress 数据类型可以用32位或者更小的空间存储，即4byte。如果是64位系统采用8byte但是需要用数据补齐等方式让其看起来是32位的。<br>  long、double则采用64位空间存储即8byte，注意这里虽然是用俩个32位空间存储但是因为是局部变量，但是是建立在线程的栈上没有共享问题是线程安全的。<br>  refrence要遵循俩个协议</p><ol><li>能找到堆中对象的数据起始位置</li><li><p>能找到方法去中Class类的位置</p><p>参数值到参数变量列表的转换，如果不是static方法，局部变量表第0位给隐藏变量“this”，参数分别占第1~n位。剩下的会分配给方法内生命的局部变量。局部变量的slot可以重用。</p><p>导致的一个“坑”是假如当前的变量后面不需要了，如果后面没有对变量的声明，修改局部变量，在方法执行期间gc是不会回收该局部变量，所以有一些比较耗内存的变量在用完了后，会“a=null”，加速gc的回收</p><p>局部变量不赋值是不能使的，因为没有向static变量有个准备阶段赋0值</p></li></ol><h3 id="操作栈"><a href="#操作栈" class="headerlink" title="操作栈"></a>操作栈</h3><p>  后入先出，保存栈帧运行时候的数据，比如运算操作，方法调用等，实际上方法的执行就是操作栈不同的入栈/出栈。最大值在方法的属性Code规定的max_stack中在编译时候操作栈的深度就规定好了。栈元素的数据类型必须与自己吗指令序列严格匹配。</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>  栈帧都包含一个指向运行时常量池中，该栈帧所对应的方法的引用，用于在运行时将一些符号应用初始化成直接引用的操作。</p><h3 id="接口返回地址"><a href="#接口返回地址" class="headerlink" title="接口返回地址"></a>接口返回地址</h3><ol><li>Nomal Method Invocation Completion。即正常的方法</li><li>Abrupt Method Invocation Completion。即出现异常的返回</li></ol><p>无论何种返回都会退回到上层调用者的位置，正常返回有可能将返回值给调用者，调用者会将返回值压入自己的操作栈中。异常返回无返回值。</p><p>方法的推出等同于当前的栈帧出栈，同时把返回值压入调用者的操纵栈，修改PC指向方法调用的后面一条指令</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用有5个指令</p><p>invokestatic:静态方法<br>invokespecial：构造方法，私有方法，父类方法<br>invokevirtual：调用所有的虚方法<br>invokeinterface：调用接口方法，会在运行时制定一个接口的实现类<br>invokedynmatic：运行时动态解析所应用的方法–这是用户设计的应到方法决定的</p><h3 id="解析调用"><a href="#解析调用" class="headerlink" title="解析调用"></a>解析调用</h3><p>只在编译期就能决定，且不会在运行时修改的方法，这里指invokestatic、invokespecial指令调用的方法，还有final的方法。</p><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>由于java面向对象特性中的多态，导致编译器无法决定使用哪个版本需在运行期指定方法版本的方法。</p><p>类A a=new B()。B是A的子类或者接口实现类，那么A是静态类型，B是真实类型。即父类、接口是静态类型，实现类、子类是真实类型。</p><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>如果方法的版本取决于类的静态类型，我们称为静态分派。主要场景用于重载见下面的方法。发生在编译阶段，因为在编译时候只能确认静态版本，但是在实际调用中我们只能通过真是的类型去推断选择一个合理版本</p><h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>如果确认方法的版本去介于类的动态类型，我们称为动态分派。主要场景用于重写。原理是当我们在方法中声明一个对象时候，会把对象的实际数据（引用）压入操作栈，当需要调用方法时候，取出来的是实际数据调用的就是实际数据的方法版本。发生在运行期。</p><h4 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h4><p>当一个方法有俩个宗树的静态、动态分派时候就是多分派。</p><p>jvm实现动态分派的方法</p><p>由于动态分派需要在class元数据中分析查找方法，为了提高性能，jvm在方法区简历了vtable(虚方法表)，当调用指令invokeinterface时候会直接通过vtable的索引查找需要的方法版本</p><h3 id="vtable–virtual-interface"><a href="#vtable–virtual-interface" class="headerlink" title="vtable–virtual interface"></a>vtable–virtual interface</h3><p>虚方法表，由于动态分派非常频繁，jvm为了提高性能，在方法区为类创建了虚方法表，虚方法表保存的是类方法的真实地址，如果遇到没重写父类的方法地址就是父类的地址。一般在类加载的链接阶段，当类初始化0值完成方法表也初始化完成</p><h3 id="动态类型语言支持"><a href="#动态类型语言支持" class="headerlink" title="动态类型语言支持"></a>动态类型语言支持</h3><p>动态类型语言主要是通过java.lang.invoke包支持。他和反射的区别是，发射时模拟类的创建和调用过程，而invoke模拟的是操作码</p><h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>java的执行引擎是基于操作栈的，解释执行。与其相对的还有编译执行如图：</p><p><img src="/public/JVM虚拟机执行引擎/编译原理.png" alt="编译原理.png"></p><p>java的解释器和解释执行在jvm中，抽象语法树之前的步骤都独立于jvm虚拟机，所以java是半独立解释性语言。</p><h3 id="基于栈或者基于寄存器"><a href="#基于栈或者基于寄存器" class="headerlink" title="基于栈或者基于寄存器"></a>基于栈或者基于寄存器</h3><ul><li>基于寄存器的优缺点：优点：直接操作寄存器，不直接操作内存，CPU执行性能高性能高。缺点：由于直接在寄存器操作依赖硬件移植性差</li><li>基于栈的优缺点：优点：移植性好，通过操作栈不直接操作寄存器，代码更为紧凑，简单。缺点：效率比基于寄存器低</li></ul><h3 id="解释执行过程"><a href="#解释执行过程" class="headerlink" title="解释执行过程"></a>解释执行过程</h3><p>将数据先push到操作栈中在pop到局部变量表，在从局部变量表load数据计算然后push到操作栈中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载机制</title>
      <link href="java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>  JAVA类是在运行时进行转载的，这种动态机制虽然降低了些许性能，但是使用起来更加灵活。相比编译时候需要连接的语言C++等来说。<br>  类加载过程分为：加载-验证-准备-解析-初始化-使用-卸载。其中加载、验证、初始化的开始顺序是固定，但是解析有可能放在初始化后面。并且他们也有可能是交叉进行的。</p><h2 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h2><p>  jvm对加载没有强制的规定，但是对类的初始化有了强制的规定。即对一个类的主动引用，主动因为指的是一下5中情况。</p><ol><li>new对象、调用对象的static属性(final除外因为final直接进入了运行时常量池)、调用对象的static方法。</li><li>初始化一个类时候发现父类没有初始化要对父类进行初始化</li><li>main方法所以在的类</li><li>反射时候如果发现类没有初始化</li><li><p>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。（实际上是因为第一条的规定）</p><p>注意：接口初始化和类很类似也需要初始化父类接口的class对象，不过不需要初始化所有父类接口，只有使用父类时候才会初始化（使用父类接口的常量）。</p></li></ol><h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>  这里只的是类加载的“加载过程”。记载分为3个过程</p><ol><li>根据类全限定名找到对应外部二进制文件</li><li>将二进制文件加载到内存中</li><li><p>在方法区创建对应的class类做外部访问数据的接口</p><p>几种外部的二级制文件加载方式zip包、网络、运行时、数据库等等<br>注意：数组的加载方式，由虚拟机直接产生。去掉数组的一维，如果是引用类型的话即组件类，该组件类的Classloader加载该类，并且数组类会在组件类的Classloader的的类空间进行标示。如果是int等非引用类型，我们会调用引导类的类加载器。访问方式取决于组件类的访问方式。</p></li></ol><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>  java虚拟机校验类文件的合法性，防止恶意篡改、类错误导致虚拟机或者程序崩溃。主要有以下四个阶段</p><ol><li>文件格式校验：判断class的魔数、版本等，通过校验后会将二进制流读入到方法区，后续的校验会针对方法区的二进制流进行校验（检查文件）</li><li>元数据校验：对字节码元数据进行分析，查看是否有父类，父类是否合法。（检查类）</li><li>字节码校验：保证方法体字节码的合法性，比如是否有非法的类型转换、赋值能。jdk1.7后增加了StackMapTable用来保存方法体中初始的状态，校验时候直接通过读取StackMapTable即可（检查方法）</li><li>符合引用校验：字段的引用是否合法，是否访问了不存在的字段、方法、以及超过了访问权限等</li></ol><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>   java虚拟机为类的变量分配内存的过程，这里指的是static修饰的变量因为实例变量会在实例创建时候赋值。对于一般情况变量分配完内存后要赋0值，真实的值保存在&lt;clinit&gt;()方法中，在初始化时候才会赋值。final修饰的变量会在该阶段赋值真实值</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  java将class文件中的符号引用改为直接引用的过程</p><p>  字段的解析</p><ul><li>普通引用比如对于字段N类型C来说，将N交给类的ClassLoader加载C的类型</li><li>数组加载数组的ComponentType的类，然后由虚拟机生成数组的直接应用</li><li><p>校验范围权限</p><p>类方法的解析</p></li><li><p>检查类的class_index如果是类方法，class_index是接口方法直接抛出java.lang.IncompatibleClassChangeError异常。</p></li><li>类中有方法的简单名称和描述符返回，否则去父类查找如果有返回，否则去接口查找如果接口有抛异常java.lang.AccessMethodError,如果没有抛出java.lang.NoSuchMethodError</li><li><p>检查访问权限</p><p>接口方法解析：步骤同上只是不用检查权限</p></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>  在该阶段开始执行java代码（字节码），生成方法&lt;clinit&gt;()。</p><ul><li>clinit方法是由静态字段和静态代码块共同合并生成，且顺序自上到下</li><li>如果有父类，且父类有有静态类和静态字段，父类的clinit方法会先调用</li><li>接口因为也可能有静态阶段，接口也可能生成clinit，如果有父类接口，只有用到父类接口的变量才会生成父类接口的clinit方法</li></ul><p>注意clinit出于线程安全考虑会加锁这就是为什么static代码块只执行一次。如果static里阻塞会阻塞类的创建</p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>唯一性：ClassLoader+类=唯一，每个ClassLoader都有自己的类命名空间，这个会影响到instanceOf等结果。</p><p>java的classloader分为3种</p><ol><li>启动类加载器：Bootstrap ClassLoader，由C++编写，java无法直接调用，如果将类委托给该加载器调用改classloader回报异常。用于加载JAVA_HOME/lib以及 -Xbootclasspath对应地址的类并且要符合命名规则，比如rt.jar</li><li>扩展类加载器：Extension ClassLoader，由java编写，java可直接调用。JAVA_HOME/ext/lib或者java.ext.dirs指定的类</li><li>应用类加载器：Application ClassLoader，由java编写，java可直接调用。classpath中的类，如果不指定自己的classloader他是默认的classloader</li></ol><p>类加载的双亲委派模型：即类加载器会优先调用父类的加载器，父类加载器会调用直到启动类加载器，之后在调用自己的类加载器。好处在于对于一些系统的类全局只有一个唯一的Class类（受唯一性约束）。顺序是：启动类加载器–&gt;扩展类加载器–&gt;应用类加载器–&gt;自定义类加载器。</p><p>这是java建议的使用方法</p><p>双亲委派模型的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class＜?＞loadClass(String name,<span class="keyword">boolean</span> resolve)<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">  <span class="comment">//首先，检查请求的类是否已经被加载过了</span></span><br><span class="line">  Class c=findLoadedClass(name)</span><br><span class="line">  <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>（parent！=<span class="keyword">null</span>）&#123;</span><br><span class="line">          c=parent.loadClass(name,<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          c=findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>（ClassNotFoundException e）&#123;</span><br><span class="line">       <span class="comment">//如果父类加载器抛出ClassNotFoundException</span></span><br><span class="line">       <span class="comment">//说明父类加载器无法完成加载请求</span></span><br><span class="line">    &#125; <span class="keyword">if</span>（c==<span class="keyword">null</span>）&#123;</span><br><span class="line">      <span class="comment">//在父类加载器无法加载的时候</span></span><br><span class="line">      <span class="comment">//再调用本身的findClass方法来进行类加载</span></span><br><span class="line">      c=findClass(name);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA类文件结构</title>
      <link href="JAVA%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>JAVA%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="class类的结构"><a href="#class类的结构" class="headerlink" title="class类的结构"></a>class类的结构</h2><p>如图，单位是字节u1代表1个字节。</p><p><img src="/JAVA类文件结构/class类文件格式.png" alt="avator"></p><h2 id="魔术和版本号"><a href="#魔术和版本号" class="headerlink" title="魔术和版本号"></a>魔术和版本号</h2><p>  文件前4个字节代表这是个java文件固定CAFEBABE<br>  第5、6字节代表此版本号，7、8字节代表主版本号，版本号有向下兼容性</p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p> 紧接着这就是常量池了，常量池的前俩个字节偏移量是0x00000008,代表常量的个数，和java其他的数据表示方法不一样，常量池下标是从1开始，（比如数字是22，常量21个索引范围是1~21个）常量池有14种数据类型，每一个常量的第一位tag（长度u1）就是它类型，见下图：<br><img src="/JAVA类文件结构/class类结构2.png" alt="avator"></p><p> 具体数据个数如下：<br><img src="/JAVA类文件结构/class类结构3.png" alt="avator"></p><p>  可以通过javap命令查看类的常量池 javap-verbose TestClass</p><h2 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h2><p>  是一个标志位，标志类是否是public的是interface还是class是否声明为final等，具体如下：</p><p><img src="/JAVA类文件结构/class类结构4.png" alt="avator"></p><p>  计算方式采用“|”</p><h2 id="类索引、父类索引和接口索引集合"><a href="#类索引、父类索引和接口索引集合" class="headerlink" title="类索引、父类索引和接口索引集合"></a>类索引、父类索引和接口索引集合</h2><p>  类索引、父类索引长度都是8,指向常量表的索引，接口索引是一组指向常量表的索引。<br>  除了Object类，父类索引都不是0。</p><h2 id="字段表、方法表集合"><a href="#字段表、方法表集合" class="headerlink" title="字段表、方法表集合"></a>字段表、方法表集合</h2><p>包括了</p><ul><li>访问标志(access_flags)：public、private等，长度8个字节</li><li>名称索引(name_index)：指向常量表</li><li>修饰符所以(descripor_index)：用简短方法表述字符比如java.lang.String[]，描述为[Ljava/lang/String</li><li>属性集合表count(attribute_count):长度8个字节，代表属性长度</li><li><p>属性信息(attribute_info):长度8个字节，数量attribute_count，代表属性信息。方法有固定的属性Code</p><p>附：<br>字段表结构<br><img src="/JAVA类文件结构/字段表结构.png" alt="avator"><br>字段access_flags<br><img src="/JAVA类文件结构/字段访问标志位.png" alt="avator"><br>方法表访问标志位<br><img src="/JAVA类文件结构/methodtableacc.png" alt="avator"><br>demo<br><img src="/JAVA类文件结构/zdjgbdemo.png" alt="avator"></p></li></ul><h2 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h2><p>  <img src="/JAVA类文件结构/attrtable1.png" alt="avator"><br>  <img src="/JAVA类文件结构/attrtable2.png" alt="avator"></p><h2 id="java的自己码指令"><a href="#java的自己码指令" class="headerlink" title="java的自己码指令"></a>java的自己码指令</h2><p>  jvm的指令码是面试操作栈的，它的指令由1个字节的代码特殊含义的操作码以及后面0到多个操作参数组成。由于操作码是1个字节所以java最多有255个操作码。</p><p>  感觉jvm是讲数据读到操作栈中操作，在写回栈帧的局部变量中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的性能分析</title>
      <link href="JVM%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>JVM%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="jvm的常用工具"><a href="#jvm的常用工具" class="headerlink" title="jvm的常用工具"></a>jvm的常用工具</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>  作用：监视java进程状态的工具</p><p>  命令格式：jps [option][hostid]</p><p>  参数：<br>-m：输出启动时传给main函数的方法<br>-l：输出主类全名如果是jar包，输出路径<br>-v：输出虚拟机启动时Jvm的参数</p><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>  作用：监视java进程各种运行状态的信息</p><p>  命令格式：jstat[option] vmid [interval][s|ms][count]]</p><p>  参数：主要分三类、类装在、垃圾收集、运行期编译状况</p><p>-class<br>-gc<br>-gccapacity<br>-gcutil<br>-gccaise<br>-gcnew<br>-gcnewcapacity<br>-gcold<br>-gcoldcapacity<br>-gcpermcapacity<br>-complier<br>-printcompilation</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">S0 S1 E O P YGC YGCT FGC FGCT GCT</span><br><span class="line"><span class="number">0.00</span> <span class="number">0.00</span> <span class="number">6.20</span> <span class="number">41.42</span> <span class="number">47.20</span> <span class="number">16</span> <span class="number">0.105</span> <span class="number">3</span> <span class="number">0.472</span> <span class="number">0.577</span></span><br><span class="line"></span><br><span class="line">  s0、s1:survivor</span><br><span class="line">  E:eden区</span><br><span class="line">  O:old区</span><br><span class="line">  M:metaspace</span><br><span class="line">  YGC:minorGc的次数</span><br><span class="line">  YGCT:minorGc的时间</span><br><span class="line">  FGC:FullGC的次数</span><br><span class="line">  FGCT:FullGc的时间</span><br><span class="line">  GCT:的时间</span><br></pre></td></tr></table></figure><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>  作用：查看、修改虚拟机的配置。</p><p>  命令格式：jinfo [option] pid</p><p>  参数：<br>  -flag &lt;name&gt;         to print the value of the named VM flag<br>  -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag<br>  -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value<br>  -flags               to print VM flags<br>  -sysprops            to print Java system properties</p><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>  作用：java内存映射工具,可以查询finalize执行队列、java堆和永久代的详细信息、如空间使用率、当前采用的收集器等</p><p>  命令格式： jmap [option] &lt;pid&gt;</p><p>  参数：<br>    -heap                打印java堆详细的信息<br>    -histo[:live]        打印堆中对象统计信息，Live只统计存活的信息<br>    -clstats             打印Classloder的信息<br>    -finalizerinfo       显示F-Queue中等待Finalizer线程执行finalizer方法的对象<br>    -dump:&lt;dump-options&gt; 生成java堆快照：live只打印存活的对象，如果不指定打印所有对象，format=b二进制格式的文件，file=&lt;file&gt;打印到某个&lt;file&gt;中。eg: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;<br>    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo<br>                         to force a heap dump or histogram when &lt;pid&gt; does not<br>                         respond. The “live” suboption is not supported<br>                         in this mode.<br>    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</p><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>  作用：配合jmap分析dump出来的jmap文件，不建议在应用服务器上使用，因为dump文件很大，并且很耗性能，建议在单独的服务器上执行<br>  命令格式：jhat /dumpfile<br>  使用方法：打开浏览器，访问jhat所在服务器的7000端口。查看内存泄漏用OQL工具和Heap Historygram功能</p><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>  作用：java堆栈跟踪工具，定位java每一个线程当前时刻的执行快照，可以定位到线程运行的状况是否死锁等。</p><p>  命令格式： jmap [option] &lt;pid&gt;</p><p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p><h3 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h3><p>  作用：jit生成码反汇编插件，通过jvm设置的参数-XX PrintAssmbly把动态生成的代码还原成汇编代码</p><p>  命令格式： jmap [option] &lt;pid&gt;</p><p>  参数：<br>    -F 当正常输出不被响应时候，强制输出程序堆栈<br>    -l 显示关于锁的相关信息<br>    -m 如果调用的是本地方法显示C/C++堆栈</p><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><ul><li><p>JConsole</p></li><li><p>VisualVM</p><p>综上，我们可以用jps jstat jinfo查看jvm的信息。jmap、jhat查看堆信息。jstack查看栈信息。我们可以用可视化工具来方便查看上面的信息推荐VisualVM</p><p>下载地址： <a href="http://visualvm.java.net/download.html" target="_blank" rel="noopener">http://visualvm.java.net/download.html</a><br>idea可以通过pulgins安装通过简单配置即可实现动态的VisualVM功能</p></li></ul><h2 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h2><h3 id="高性能硬件的场景"><a href="#高性能硬件的场景" class="headerlink" title="高性能硬件的场景"></a>高性能硬件的场景</h3><p>  如果硬件性能较高，我们一般采用俩种方式</p><ol><li>采用64位虚拟机，设置很大的堆内存</li><li><p>采用32位虚拟机，虽然堆内存最大设置4（还受限于平台对进程最大使用内存的限制有可能只有2g，windows平台）我们可以给一台服务器设置多个进程+前端反向代理的方法。</p><p>第一种方案我们要注意64位虚拟机往往比32位虚拟机要慢（指针膨胀、内存补齐等需求），另外由于堆内存很大，我们一定要注意大对象导致频繁GC的问题，因为一次fullGC有可能需要停顿10几秒，对于交互多的服务体验会很差</p></li></ol><h3 id="共享缓存导致oom"><a href="#共享缓存导致oom" class="headerlink" title="共享缓存导致oom"></a>共享缓存导致oom</h3><p>  由于共享缓存频繁的写入导致内存oom。需要检查缓存的使用率。</p><h3 id="对外内存导致的oom"><a href="#对外内存导致的oom" class="headerlink" title="对外内存导致的oom"></a>对外内存导致的oom</h3><p>  有以下几种对外内存</p><p>  DirectMemory:主要用于nio场景，比如内存环境是2G。我们给堆内存分配了1.6G。那么堆外内存最多只能有0.4G不到，如果这时候大量请求过来会导致oom</p><p>  线程堆栈：会出现StackOverflowError或者StackOutOfMemoryError</p><p>  JNI的调用：由于是native方法所以也是堆外内存</p><p>  Socket的读写Buffer：receive和send都有一个buffer分别是37kb和25kb。如果超出了会出现open many file的错误。</p><p>  系统线程和gc线程</p><h3 id="外部命令导致系统变缓慢"><a href="#外部命令导致系统变缓慢" class="headerlink" title="外部命令导致系统变缓慢"></a>外部命令导致系统变缓慢</h3><p>  比如调用Runtime.getRuntime.exec()执行shell。java是fork了个进程，这个指令很重如果调用的频繁系统的负载会很重，建议采用api的方式。</p><h3 id="外部接口超时导致系统崩溃"><a href="#外部接口超时导致系统崩溃" class="headerlink" title="外部接口超时导致系统崩溃"></a>外部接口超时导致系统崩溃</h3><p>  调用远程接口响应较慢导致连接大量被占用，同时对连接没做限制导致了虚拟机崩溃。需要设置超时时间，或者采用生产者消费者异步的方式。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的垃圾回收机制</title>
      <link href="JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>jvm的内存分为线程独享的线程栈、程序计数器；线程共享的方法区、堆区，线程栈在编译时候就确定好了大小，方法执行完成后自动就可以回收所以是静态的。而方法区、堆区只有在运行时才知道内存分配的大小所以内存回收是动态的。本章主要讨论的是堆和方法区的垃圾回收</p><h2 id="对象是否可被回收算法"><a href="#对象是否可被回收算法" class="headerlink" title="对象是否可被回收算法"></a>对象是否可被回收算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>  给对象添加一个引用计数器，当被引用时候引用计数+1，在垃圾回收时候只要应用计数为0就可以回收对象了。算法很简单，弊端是无法解决循环应用问题。<br>  即：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.instance=b;</span><br><span class="line">b.instance=a;</span><br></pre></td></tr></table></figure><p>  这时候a和b是无法被回收的。</p><h3 id="可达性分析算法-java采用的方式"><a href="#可达性分析算法-java采用的方式" class="headerlink" title="可达性分析算法-java采用的方式"></a>可达性分析算法-java采用的方式</h3><p>我们通过对象GCRoot做可达性分析，如果对象的引用链没有GCRoot对象，说明对象是可以被回收的。jvm中适合做GCRoot对象的有</p><ul><li>jvm方法栈中的局部变量表中的变量</li><li>jvm本地方法栈中的native对象</li><li>方法区中的静态变量</li><li>方法区中的常量</li></ul><h2 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h2><p>对象按照应用的按照从强到弱分别如下：</p><ul><li>强引用：我们new一个对象默认就是强引用。必须等到GcRoot不可达</li><li>软引用：SoftReference对象，不管内存是否足够，下一次gc都会回收该对象</li><li>弱引用：WeakReference对象，当内存不足时候时候gc会回收弱引用对象</li><li>虚引用：PhantomReference，又称幽灵引用，不对对象的生命周期造成影响，get()方法返回的也是null，只在对象被回收时候系统会收到一个通知。使用场景堆外内存回收。系统调用unfase方法申请一块堆外内存，然后在堆中会持有一个虚引用的对象，当该对象被回收时候会清理堆外内存</li></ul><h2 id="finalize方法以及对象的自救"><a href="#finalize方法以及对象的自救" class="headerlink" title="finalize方法以及对象的自救"></a>finalize方法以及对象的自救</h2><p>  对象被回收需要通过标记、回收两部，第一步先标记可会回收的对象，然后检查对象是否实现了finalize()方法，如果对象实现了finalize方法并且在gc时候没有被系统调用过，则认为是可finalize的，会放在一个优先级比较低的F-Queue队列中，之后会有finalize线程执行finalize()方法，如果这时候把this赋值给别的标量则完成了对象的自救。</p><p>  注意:</p><ul><li>只会执行一次；</li><li>finalize的执行由于优先级较低即为不靠谱不推荐使用。比如在finalize方法中执行一些清理操作我们可以放在finnal中执行</li></ul><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>  永久代的回收效率比较低（类信息、常量、静态变量），主要回收类信息、常量</p><p>  回收常量：当该常量没有任何应用</p><p>  回收类信息：</p><ol><li>没有任何该class的实例</li><li>该类的ClassLoader被回收</li><li>Class没有任何访问、即通过反射创建该Class的元素</li></ol><h2 id="gc的算法"><a href="#gc的算法" class="headerlink" title="gc的算法"></a>gc的算法</h2><h3 id="mark-swap-标记清理"><a href="#mark-swap-标记清理" class="headerlink" title="mark-swap 标记清理"></a>mark-swap 标记清理</h3><p>标记对象后将需要回收的对象进行销毁、会造成内存碎片，可能导致大对象没法分配</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>年轻代会采用这种算法，jvm认为大量对象是朝生夕死，所以会将内存分为Eden和俩个Survivor空间，默认比例是8:1:1，平时只会用到一个Eden和1个Survivor。当gc时候会将所有对象赋值到没用的那个Survivor空间，然后清掉Eden和原来的Survivor空间。如果剩下的Survivor不足会进入老年代。</p><h3 id="mark-compact-标记整理"><a href="#mark-compact-标记整理" class="headerlink" title="mark-compact 标记整理"></a>mark-compact 标记整理</h3><p>标记之后让所有对象向一端移动，超过这个范围的对象会被回收。</p><h2 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>  从GcRoot找引用链，该操作对时间很敏感，因为这一步操作对数据一致性要求很高，所以在执行时候虚拟机必须要StopTheWorld，否则枚举根节点的结果就不准确了。方法区和堆内存往往都很大，如果都需要分析一遍性能会严重受影响。</p><p>  HotSpot采用了OopMap对象，需要虚拟机的解释器和JIT编译器支持，由他们来生成OopMap，把对象偏移量内存放的是什么数据保存起来，gc就很快知道了对象的信息。</p><h3 id="安全点-safe-point"><a href="#安全点-safe-point" class="headerlink" title="安全点 safe point"></a>安全点 safe point</h3><p>  虽然OopMap在gc时候能很方便的完成枚举根节点，但是影响OopMap数据的操作很多如果每一步操作都创建OopMap会很耗费内存。为了解决这个问题HotSpot设置了safePoint的概念，只有程序执行到safePoint，才会停止线程开始gc，并且在gc前创建OopMap。即每一个safePoint会生成一个OopMap对象。</p><p>  安全点选定太少，GC等待时间就太长，选的太多，GC就过于频繁。选定原则是”具有让程序长时间执行的特征“，也就是在这个时刻现有的指令是可以复用的。一般选在方法调用、循环跳转、抛出异常的位置。</p><p>  现在的问题是在Safe Point让线程们以怎样的机制中断，方案有两种：抢先式中断、主动式中断。</p><ul><li>抢先式中断：GC发生时，中断所有线程，如果发现有线程不再安全点上，就恢复线程让它运行到安全点上。现在几乎不用这种方案。</li><li>主动式中断：设置一个标志，和安全点重合，再加上创建对象分配内存的地方。各个线程主动轮询这个标志，发现中断标志为真就挂起自己。HotSpot使用主动式中断。</li></ul><h3 id="安全区域-safe-region"><a href="#安全区域-safe-region" class="headerlink" title="安全区域 safe region"></a>安全区域 safe region</h3><p>  如果线程没有分配cpu时间，必须线程处于sleep或blocked状态，就无法响应JVM的中断请求，走到安全点去挂起。Safe Region解决了这一问题。</p><p>  安全区域是指在一段代码片段中，引用关系不会发生变化，在该区域的任何地方发生GC都是安全的。当代码执行到安全区域时，首先标识自己已经进入了安全区域，那样如果在这段时间里JVM发起GC，就不用管标示自己在安全区域的那些线程了，在线程离开安全区域时，会检查系统是否正在执行GC，如果是，就等到GC完成后再离开安全区域。</p><h2 id="java的垃圾回收器"><a href="#java的垃圾回收器" class="headerlink" title="java的垃圾回收器"></a>java的垃圾回收器</h2><p>HotSpot在jdk1.7之后的所有垃圾回收器，如图：</p><p><img src="/JVM的垃圾回收机制/垃圾收集器.png" alt="avator"></p><h3 id="Serial垃圾回收器"><a href="#Serial垃圾回收器" class="headerlink" title="Serial垃圾回收器"></a>Serial垃圾回收器</h3><p>  最早的最基本的垃圾回收器，jdk1.3时期新生代唯一的垃圾收集器。会停止jvm所有的工作线程。</p><p>  是client模式下，新生代默认的垃圾收集器，因为没有线程交互开销所以在gc过程很高效，如果新生代内存不大，收集一次的耗时是可以接受的。</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>  Serial的多线程版本。</p><p>  是server模式下首选的新生代垃圾收集器。原因是jdk1.5之后的CMS收集器除了Serial以外只有它能和ParNew配合使用。</p><p>  开启CMS后，-XX：+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX：+UseParNewGC选项来强制指定它。</p><p>  在单线程或者俩个线程时候由于有线程切换的问题表现不见得比Serial好，他适合线程数或者核数多的场景。默认开启的线程数等于cpu的数量，当然我们也可以通过参数-XX：ParallelGCThreads来控制</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>  更关注系统的吞吐量【运行代码时间/(运行代码时间+垃圾回收时间))】适用于内部计算、和外部没有交互的服务，主要参数：</p><ul><li>-XX：MaxGCPauseMillis：设置停顿时间，保证垃圾回收时间尽量不超过这个阈值，采用所少新生代空间，会导致垃圾回收更频繁</li><li>-XX：GCTimeRatio：垃圾收集时间占总时间的比例。</li><li>-XX：+UseAdaptiveSizePolicy：值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数。</li></ul><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>  Serial的老年版垃圾收集，采用“标记-整理”算法，目前主要用于配合Parallel Scavenge和作为CMS的替代方案。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>  Parallel Scavenge老年版，使用多线程和“标记-整理”算法。适合吞吐量优先的场景。</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>  大名鼎鼎的ConcurrentMarkSweep。以获取最短停顿时间为目标的垃圾回收期，试用场景希望停顿时间较短的场景。</p><p>  分为四个阶段：</p><ol><li>初始标记（CMS Initial Mark）：会stop the world。标记GcRoots能直接关联的对象。只做标记所以很快；</li><li>并发标记（CMS Concurrrent Mark）：不会stop the world和用户线程一起处理。去做GcRoot Tracing；</li><li>重新标记（CMS Remark）：会stop the world。处理初始标记到并发标记过程中新创建的对象，比初始标记长但是这时候创建的对象很少，所以停顿时间可接受；</li><li>并发清除（CMS Concurrrent Sweep）：不会stop the world和用户线程一起处理。去做对象的清理操作；</li></ol><p>如图：</p><p><img src="/JVM的垃圾回收机制/CMS收集器.png" alt="avator"></p><p>  默认启动线程是(CPU数量+3)/4，所以在CPU核数变高时候CMS占用的线程资源会越来越少。</p><p>  缺点：</p><ul><li>对cpu敏感会占用一部分用户线程，从而cpu负载很高时候导致程序变慢。</li><li>CMS无法处理浮动垃圾（即：因为在回收时候会产生的新对象），有可能导致另一次GC。因为在做垃圾回收时候用户线程在工作所以要预留一部分空间给用户线程。默认是92%（since 1.6）</li><li>内存碎片问题：由于标记清除会带来内存碎片问题导致明明很大的空间但是无法申请内存，这时候就要进行一次FullGC。<ul><li>CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li><li>虚拟机设计者还提供了另外一个参数-XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full，然后在来一次压缩的默认是0，每次进行FullGc都压缩。</li></ul></li></ul><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>  面向服务端收集器，特点：</p><ul><li>并行与并发：充分利用多核cpu,缩短stoptheworld时间。其他收集器需要停顿的它依然可以工作。</li><li>分代收集：虽然依然分代，但是g1可以不借助其他收集器独自工作。</li><li>空间整合：不会产生碎片。收集后提供规整内存。</li><li><p>可预测的停顿：用户可指定消耗在gc上的时间不超过n毫秒</p><p>G1不在区分新生代和老年代而是将堆内存分为一些大小相等的Region，Region分为新生代和老年代并且且同一年代的Region不连续的。<br>G1可预测的停顿时间的实现原理是。是内部维护了一个垃圾回收的优先级列表，针对Region内可回收的对象的大小、多少、收益能排序,优先回收收益较大的Region。</p><p>G1是如何解决不同Region之间的相互引用的，即新生代的Region引用了老年代的Region，它是通过每个Region持有的RememberSet。当一个Refrence发生写操作时候会生成一个WriteBarrier，暂时中断写操作，如果发现他们俩个处于不同的Region，则通过CardTable将应用信息记录到被引用对象Region的RememberSet，回收时候只需要RemberSet就可以知道准确的引用关系避免了全堆扫描。</p><p>G1的垃圾回收步骤</p></li></ul><ol><li>初始标记：标记下GcRoots能直接关联的对象，并且修改TAMS(next top at mark start)值，能让下一阶段并发标记时候在正确的region中创建值。需要停顿，但是很短。</li><li>并发标记：同cms，可以和工作线程一起运行，进行可达性分析查找存活对象，耗时较长。不需要停顿，可并行执行。</li><li>最终标记：修正初始标记到并发标记。从初始标记到最终标记这段时间内创建的对象都会记录到Remember Set Log中，合并到Remember Set中这段时间需要停顿线程，但是可并行执行。</li><li>筛选回收：根据用户设置的阈值指定回收计划。这一步理论上是不需要停顿的，但是但是停顿用户线程会增加回收效率。</li></ol><p>如图：<br><img src="/JVM的垃圾回收机制/G1收集器.png" alt="avator"></p><p>  综述：<br>  我们一般ParNew+CMS或者是G1的方案。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>  对象默认分配到eden区，如果开启TLAB会有限直接分配在线程栈中。</p><p>  大对象会直接进入老年代，对象大小超过一个PretenureSizeThreshold会直接进入老年代，</p><p>  长期存活的对象会晋升入老年代，每次垃圾回收对象的age会+1，如果到了MaxTenuringThreshold(默认值是15)会直接进入老年代。对象的动态年龄规划：当survivor区相同年龄的对象超过了survivor大小的一半，那么大于等于这个年龄的对象都可以直接进入到老年代。</p><p>  共同担保机制：当MinorGC发生时候，如果老年代的连续空闲内存空间超过新生代使用的对象的空间即可正常发生MinorGC,否则查看HanleProotionFailure值，如果开启，则会尝试MinorGC，失败后触发FullGC。如果关闭直接进行FullGC</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA虚拟机的内存管理</title>
      <link href="JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>见图：</p><p><img src="/JAVA虚拟机的内存管理/jvm运行时数据区.png" alt="avator"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>  一块较小的内存空间，当前线程执行字节码的行号计数器，字节码解释器通过修改它来让程序知道分支、跳转、异常处理等逻辑下一条指令去哪里执行。<br>  在多线程环境中，由于当前线程在某一时刻，只会执行线程的一条指令，线程切换之后要恢复到之前程序执行的点。所以程序计数器线程独立的。<br>  如果线程执行的是JAVA方法，该值记录的是虚拟机字节码指令地址。如果是native方法该值是undifined，该区域是jvm中唯一没规定oom的区域</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>  也是线程独有的，生命周期和线程绑定在一起。描述的是JVM的内存模型：每个方法在执行时候会生成一个Stack Frame。存储方法的局部变量表、操作数栈、动态链接、方法出口等。<br>  每一个方法从执行开始到执行完毕都是Stack Frame的一个入栈到出栈的操作。<br>  局部变量表存放：java的几本类型，对象引用、returnAddress等。局部变量表的内存空间在编译时候就确定好了，当进入一个方法中，局部变量表在Stack Frame的大小是确定的不会改变。<br>  如果线程请求的虚拟机栈超过最大深度会报StackOverFlowError异常，虚拟机栈可以动态扩展但是没申请到内存会报OutOfMemoryError异常。（这里是只没打到深度但是内存不足了）</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>  基本上和JAVA虚拟机栈类似这里是指调用的是native方法。会抛出的异常如上。</p><h3 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h3><p>  存放对象最大的一块区域，可以是不连续的内存空间。具体针对gc方式可以分为young old metaspace等。后期还有g1回收期，这里暂时不做讨论，所有线程共享。如果内存不足会报OutOfMemoryError异常</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>  我们常说的PermSpace或者MetaSpace。用于存储Java虚拟机的类信息、静态变量、常量、即时编译的代码等。为了和堆区分开也叫（Non heap）。JVM规范对方法去限制很宽松除了内存可以不连续外，还可以不实现gc，方法区的gc主要取决于常量的回收和类的卸载。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>  在jdk1.4之后Java引入了Nio,可以直接通过native函数分配堆外内存 通过DirectByteBuffer进行读取/写入，也会引起OutOfMemoryError</p><h3 id="运行时的常量池"><a href="#运行时的常量池" class="headerlink" title="运行时的常量池"></a>运行时的常量池</h3><p>  方法区的一部分，类在编译时产生的常量在加载Class时候会存储在方法区的常量池中，常量池是动态的的比如String的inter()方法会在运行时动态的加入常量池，所以也有可能出现OutOfMemoryError异常</p><p>  补充一点：<br>  String s=”liuhao” 是一个常量是编译时候就决定好的，所以java汇总<br>  String s1=”liu”+”hao” 俩个常量相加会进入常量池儿常量池只有一个拷贝，所以s==s1<br>  String s=new String(“liuhao”) 不是常量所以不能放在常量池。<br>  String s1=s1.intern() 将s1的值写入到常量池中,扩充了常量池</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="HotSpot的Object的创建"><a href="#HotSpot的Object的创建" class="headerlink" title="HotSpot的Object的创建"></a>HotSpot的Object的创建</h3><p>对象创建的步骤</p><ol><li>类装载：去常量池中查找Class的符号引用，检查类是否已经被加载、解析、初始化过;</li><li>分配内存,依据内存是否完整有俩种分配方式<ol><li>指针碰撞：Bump the Pointer，规整的内存空间，Serial,ParNew这种垃圾回收机制会整理内存。将已分配、未分配用一个指针分隔开，分配时候讲指针挪动一个对象的size个位置。</li><li>空闲列表: Free List，不规整的内存空间,CMS垃圾回收机制不需要整理内存。维护一个空闲列表，分配时候找到一个空闲的内存空间进行分配。</li><li>指针碰撞的线程安全：<ol><li>TLAB：每个内存开辟一个独有的小的内存空间默认是Eden区1%，对象会先在TLAB上创建，这样就保证了原子性。虚拟机内部会维护一个refill_waste值，如果对象需要的空间小于TLAB的剩余空间，同时对象的size大于refill_waste，会在堆中创建，如果小于refill_waste则会新申请一个TLAB进行创建。用参数-XX:+UseTLAB开启，默认是开启的</li><li>CAS+失败重试，保证分配空间的原子性。</li></ol></li></ol></li><li>初始化对象，将对象里的属性初始化成零值</li><li>设置对象头：元数据信息、Hash值、GC分带年龄等</li><li>对象从虚拟机的角度来看已经创建完成，java代码还需要对对象进行init的设置。</li></ol><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>  分为对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul><li>MarkWord：HashCode、GC年代分龄、锁标记位、线程持有的锁、偏向的线程ID、偏向时间戳。长度32bit or 64bit。<ul><li>32bit:HashCode（25bit）、GC年代分龄(4bit)、锁标记位(2bit)、unused(1bit)</li><li>64bit:unused(25bit)、HashCode（31bit）、GC年代分龄(4bit)、锁标记位(2bit)、unused(1bit)、block（1bit）</li></ul></li><li>类型指针：类元素的指针告诉虚拟机它是哪个类的实例。如果是数组还需要保存数组的长度</li></ul><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>保存对象的真实数据，分配策略是相同宽度的对象会分配在一起，满足这个前提条件下，父类的字段会放在子类之前。</p><h4 id="对象填充"><a href="#对象填充" class="headerlink" title="对象填充"></a>对象填充</h4><p>用于对齐对象用，因为要求对象必须是8字节的整数倍，如果不是需要这部分进行填充。</p><h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p>  创建对象之后java通过栈上的refrences数据来操作对象实例，JVM没有规定如何具体访问对象有俩种访问方式，通过句柄方式和直接指针方式</p><p>  句柄方式:jvm在堆上开辟一块空间作为句柄池，refrence保存的是句柄地址，句柄来负责访问对象一部分指向堆中对象的实例地址，一部分指向方法区的类实例地址。<br>  好处：refrence保存的是稳定的句柄地址，当对象被移动时候refrence不需要改变。（例如gc时候移动对象）<br><img src="/JAVA虚拟机的内存管理/通过句柄访问对象.png" alt="avator"></p><p>  直接对象指针：refrence保存的是实例数据的指针。HotSpot采用这种方式<br>  好处：速度快。少一次句柄查找的操作。由于创建对象频繁这一步性能的节省效果很客观。<br><img src="/JAVA虚拟机的内存管理/通过直接指针方式访问对象.png" alt="avator"></p><h2 id="OutOfMemory"><a href="#OutOfMemory" class="headerlink" title="OutOfMemory"></a>OutOfMemory</h2><p>todo</p><h3 id="java堆溢出"><a href="#java堆溢出" class="headerlink" title="java堆溢出"></a>java堆溢出</h3><p>执行如下程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会出现异常信息</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> at java.util.Arrays.copyOf(Arrays.java:<span class="number">3210</span>)</span><br><span class="line"> at java.util.Arrays.copyOf(Arrays.java:<span class="number">3181</span>)</span><br><span class="line"> at java.util.ArrayList.grow(ArrayList.java:<span class="number">265</span>)</span><br><span class="line"> at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:<span class="number">239</span>)</span><br><span class="line"> at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:<span class="number">231</span>)</span><br><span class="line"> at java.util.ArrayList.add(ArrayList.java:<span class="number">462</span>)</span><br><span class="line"> at com.ericliu.practice.toy.jvm.oom.HeapOOM.main(HeapOOM.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure><p>其中Java heap space的表示是堆溢出，可以通过HeapDumpOnOutOfMemoryError导出的文件通过MAT查看（eclipse的插件）</p><h3 id="java方法栈和本地方法栈溢出溢出"><a href="#java方法栈和本地方法栈溢出溢出" class="headerlink" title="java方法栈和本地方法栈溢出溢出"></a>java方法栈和本地方法栈溢出溢出</h3><p>会出现StackOverFlowError或者StackOutOfMemeoryError。执行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xss160k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length："</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">会出现异常信息</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br><span class="line"> at com.ericliu.practice.toy.jvm.oom.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:<span class="number">13</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>单线程的情况会出现StackOverflowError，通过不断创建线程可能会耗尽内存导致Stack的OOM,这种情况可以通过减少线程或者增大堆内存，或者减少每个线程的内存。</p><p>多线程会出现如下异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError：unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</span><br></pre></td></tr></table></figure><h3 id="方法区和常量池溢出"><a href="#方法区和常量池溢出" class="headerlink" title="方法区和常量池溢出"></a>方法区和常量池溢出</h3><p>1.6执行如下代码，因为1.7采用了MetaSpace所以失效了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/10/17</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现PermGen Space</p><h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>可以通过DirectMemory容量可通过-XX：MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">异常：</span><br><span class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError</span><br><span class="line"> at sun.misc.Unsafe.allocateMemory（Native Method）</span><br><span class="line"> at org.fenixsoft.oom.DMOOM.main（DMOOM.java：<span class="number">20</span>）</span><br></pre></td></tr></table></figure><p>特征是dump的文件很小。如果发现dump的文件很小同时用了nio可以考虑是这方面的原因。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-源码理解</title>
      <link href="Redis-%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
      <url>Redis-%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>  所有的Redis对象都有如下的头信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReidsObject</span>&#123;</span></span><br><span class="line">    int4 type; <span class="comment">//类型 4bit</span></span><br><span class="line">    int4 encoding; <span class="comment">//编码方式 4bit</span></span><br><span class="line">    int24 lru; <span class="comment">//lru时间戳 24bit</span></span><br><span class="line">    int32 refcount; <span class="comment">//引用计数如果为0回收 4byte</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指针 8byte</span></span><br><span class="line">&#125;robj</span><br></pre></td></tr></table></figure><p>  每一中RedisObject的数据类型对应一个type,但是根据情况可能对应多个encoding</p><h2 id="字符串的原理"><a href="#字符串的原理" class="headerlink" title="字符串的原理"></a>字符串的原理</h2><p>  Redis的字符串叫SDS格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SDS</span>&lt;T&gt;&#123;</span></span><br><span class="line">    T capacity; <span class="comment">//容量 1byte</span></span><br><span class="line">    T len; <span class="comment">//实际长度 1byte</span></span><br><span class="line">    byte flags; <span class="comment">//特殊标志位 1byte</span></span><br><span class="line">    byte[] content; <span class="comment">//数组长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  redis的字符串支持修改，为了减少修改的成本会预先申请capacity个长度的byte数组，当数组写入字符串的时候根据len定位。好处如下：</p><ul><li>当发生追加等操作时候不需要申请新的数组，copy原数组</li><li>获取字符串长度时候只需要访问len变量即可，不需要遍历数组</li><li><p>len和capacity使用泛型T可以针对长度将变量设置为byte short。对对象用到了极致</p><p>redis的字符串在小于44字节的时候encoding是embstr,大于44字节的encoding是raw。如果字符串是embstr，分配内存往往RedisObject和SDS是紧挨着的；如果是raw内存是不连续的；为什么是44个字节，原理如下：</p></li><li>为什么是44个字节<ul><li>SDS除content最少占用ReidsObject占16byte+SDS的3byte(假设这时候content为空)=19byte</li><li>由于redis的内存管理工具分配方式是8/16/32/64，由于头文件占据了19空间，所以至少分配32字节。当content+redisObj需要分配64字节,那么content最多存储45字节，减去最后的空字符NULL，剩余44字节。</li></ul></li><li>超过这个阈值Redis会认为对象是个大字符串适合用raw去存</li></ul><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>  Redis的hash结构，所有的key-value是一个全局的dict，以及设置了expire的key-value，另外zset的value–score的对应关系也是通过字典结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RedisDb</span>&#123;</span></span><br><span class="line">dict* dict;</span><br><span class="line">dict* expires;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">    dict *dict   <span class="comment">// value=&gt;score</span></span><br><span class="line">    zskiplist *zsl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  dict采用的rehash策略是渐进式的rehash,防止hash过大rehash影响主流程。采用的hash算法是siphash</p><p>  扩容：当元素等于dict数组长度时候会扩容，扩容为原来的2倍，如果遇到bgsave尽量不会去扩容，但是如果当元素打到dict数组的5倍会进行强制扩容<br>  缩容：当元素低于dict数组长度10%会缩容。缩容不会考虑bgsave。</p><h2 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&lt;T&gt;&#123;</span></span><br><span class="line">int32  zlbytes; <span class="comment">//压缩表占用自己数</span></span><br><span class="line">int32  zltail_offset; <span class="comment">//最后一位偏移量用于到这遍历</span></span><br><span class="line">int16 length; <span class="comment">//长度</span></span><br><span class="line">T[] entries; <span class="comment">//元素列表</span></span><br><span class="line">int8 zlend;  <span class="comment">//压缩列表的结束标记，值：0xFF</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">srtuct entry&#123;</span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; prevlen; <span class="comment">//前一个长度</span></span><br><span class="line">    <span class="keyword">int</span>&lt;var&gt; encoding; <span class="comment">//元素类型编码 小于254时候一个字节，大于254时候5个字节第一个自己是254（0xFE）</span></span><br><span class="line">    optional byte[] contennt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h2><p>当集合set是整数且个数较小时候会考虑使用intset</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&lt;T&gt;&#123;</span></span><br><span class="line">    int32 encoding;</span><br><span class="line">    int32 length;</span><br><span class="line">    <span class="keyword">int</span>&lt;T&gt; content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>list采用这种数据结构是ziplist和linkedlist的整合，将linkedlist按照ziplist分段，时内存更紧凑，每一段在用链表链接起来。</p><h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p> zset采用这种方式，优点：快速定位.它的层数是2的64次方。<br> zset的rank的排名是通过zslforward的span对象计算出来的每次插入的时候都会维护这个值，表示当前层到这个节点跳过了多少节点</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-Key的过期策略</title>
      <link href="Redis-Key%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/"/>
      <url>Redis-Key%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="key的过期策略"><a href="#key的过期策略" class="headerlink" title="key的过期策略"></a>key的过期策略</h2><h2 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h2><p>  为key设置expire。由于redis是单线程的如果对于过期的key扫描的过多会影响服务的卡顿，所以redis提供了惰性过期和主动扫描过期俩种方案。</p><p>  扫描机制，redis会把设置过期时间的key放在内存中，key的扫描过期机制如下：</p><ol><li>为了防止频繁扫描，redis每秒扫描10次过期的key，明且每次扫描建个是25ms</li><li>每次扫描随机取20个key</li><li>判断20个key是否过期，并且回收过期key</li><li><p>如果过期的key占1/4会重复回收</p><p>如果这段时间有大量的key过期，势必会增加扫描频次，同时由于redis的内存管理对数据页的回收，会导致CPU飙升，服务卡顿。</p><p>注意：salve没有扫描机制，master过期后会生成一条del的命令给slave执行（如果这时候宕机可能造成数据不一致）。</p></li></ol><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>  redis本质是内存数据库当内存占用满后，根据maxmemory-policy配置，会有如下几种策略</p><ul><li>noeviction：默认策略，直接拒绝写服务（del后会执行），不会丢失数据</li><li>volatile-lru：对设置expire的key进行淘汰。策略是lru</li><li>volatile-ttl：对设置expire的key进行淘汰。策略是ttl</li><li>volatile-random：对设置expire的key进行淘汰。策略是随机</li><li>allkeys-lru：对所有的key进行淘汰。策略是lru</li><li><p>allkeys-random：对所有的key进行淘汰。策略是随机</p><p>redis为了节省内存采用了近似lru算法的淘汰机制，是一种懒惰淘汰机制，即当写入操作发现内存已经超过了maxmemory时候，根据maxmemory-policy去allkeys和设置了过期时间的keys中随机取5个key淘汰掉最旧的key。</p></li></ul><h2 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h2><h3 id="懒惰删除"><a href="#懒惰删除" class="headerlink" title="懒惰删除"></a>懒惰删除</h3><p>redis如果删除一个key正好这个key是大key，会阻碍业务的执行。redis4.0增加了unlink命令可以将key放到异步队列中由异步线程去消费。</p><h3 id="AOF的异步刷盘"><a href="#AOF的异步刷盘" class="headerlink" title="AOF的异步刷盘"></a>AOF的异步刷盘</h3><p>由于AOF需要调用sync，会影响业务。所以AOF的刷盘也会放到一个异步队列和线程中。为了保证效率是独立的一个线程处理</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis-运维</title>
      <link href="Redis-%E8%BF%90%E7%BB%B4/"/>
      <url>Redis-%E8%BF%90%E7%BB%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis的监控命令和几个重点指标"><a href="#Redis的监控命令和几个重点指标" class="headerlink" title="Redis的监控命令和几个重点指标"></a>Redis的监控命令和几个重点指标</h2><p>info &lt; seciton &gt;命令</p><h3 id="查看qps"><a href="#查看qps" class="headerlink" title="查看qps"></a>查看qps</h3><p>  查看redis的qps【info stats】，instantaneous_ops_per_sec 这是qps<br>  查看具体的key redis-cli monitor</p><h3 id="查看客户端"><a href="#查看客户端" class="headerlink" title="查看客户端"></a>查看客户端</h3><p>info clients</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Clients</span><br><span class="line">connected_clients:<span class="number">1</span></span><br><span class="line">client_longest_output_list:<span class="number">0</span></span><br><span class="line">client_biggest_input_buf:<span class="number">0</span></span><br><span class="line">blocked_clients:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>拒绝连接数如果过多应该开打链接<br>info stats</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rejected_connections:<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><p>info memory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">used_memory_human:<span class="number">796.36</span>K <span class="comment">//使用</span></span><br><span class="line">used_memory_rss_human:<span class="number">1.26</span>M <span class="comment">//top的数值</span></span><br><span class="line">used_memory_peak_human:<span class="number">877.38</span>K <span class="comment">//峰值</span></span><br><span class="line">total_system_memory_human:<span class="number">251.67</span>G</span><br></pre></td></tr></table></figure><h3 id="复制挤压缓冲器"><a href="#复制挤压缓冲器" class="headerlink" title="复制挤压缓冲器"></a>复制挤压缓冲器</h3><p>info replication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span> <span class="comment">//挤压缓冲区大小</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure><p>info stats</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sync_full:<span class="number">0</span></span><br><span class="line">sync_partial_ok:<span class="number">0</span></span><br><span class="line">sync_partial_err:<span class="number">0</span> <span class="comment">//半同步失败次数如果过多需要增大挤压缓冲区大小</span></span><br></pre></td></tr></table></figure><h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><p>指令安全：禁止危险命令</p><p>端口安全：不要暴露到公网，同时设置bindIp或者密码，注意设置密码从库也需要密码才能复制</p><p>脚本安全：禁止客户输入lua脚本</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-集群</title>
      <link href="Redis-%E9%9B%86%E7%BE%A4/"/>
      <url>Redis-%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>Redis的集群遵循的是CAP理论中的AP，因为Redis是出现网络分区的时候，主依然提供写服务，从会采用多中方式追赶主</p><h2 id="主从复制和从从复制"><a href="#主从复制和从从复制" class="headerlink" title="主从复制和从从复制"></a>主从复制和从从复制</h2><p>  Redis的主从复制、从从复制是异步复制，从从复制是为了减少主的压力</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>Redis主会将涉及到数据修改的命令写入到Buffer中，然后异步传给从库，从库执行命令并且返回偏移量给主，保证俩边的数据一致，buffer采用环状结构，如果buffer满了会覆盖原来的数据。如果出现还没有执行就被覆盖的情况会触发快照复制</p><h3 id="快照复制"><a href="#快照复制" class="headerlink" title="快照复制"></a>快照复制</h3><p>  快照复制很耗时。过程如下</p><ul><li>主先bgsave将快照写入到磁盘。</li><li>同步快照给从</li><li>从在接收完快照后，先持久化，在Load快照</li><li><p>从库开始执行这段时间的增量操作。</p><p>如果这段时间buffer又被覆盖了，则继续快照复制，如此恶性循环，所以要选择一个合适的复制buffer</p><p>快照复制前会持久化，如果这时候正好需要aof的fsync，则会推迟fsync，影响主的业务。</p><p>新加入的从库都需要先执行一遍快照复制。</p><p>Redis3.0针对这种情况采用了无盘复制的思路，遍历内存不持久化，直接传递给从库，从库如上面的过程先持久化在load，避免了主库的磁盘IO操作</p></li></ul><h3 id="wait命令"><a href="#wait命令" class="headerlink" title="wait命令"></a>wait命令</h3><p>可以将异步复制改为同步复制，由AP变为CP</p><h2 id="redis-sentinel-哨兵机制"><a href="#redis-sentinel-哨兵机制" class="headerlink" title="redis-sentinel 哨兵机制"></a>redis-sentinel 哨兵机制</h2><p>  redis在3.0提供sentinel服务，进行节点的healthCheck。</p><p>  客户端通过连接sentinel获取当前的master信息，客户端连接Master。</p><p>  如果发现master挂了，哨兵会选举新的Master,同时集群中其他的slave会和新的master开始主从同步任务。当原来的master恢复会变为slave。</p><p>  注意：实际上senintel的主从切换是客户端做的。</p><h2 id="数据切片"><a href="#数据切片" class="headerlink" title="数据切片"></a>数据切片</h2><h3 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h3><p>  codis-proxy:做请求代理<br>  codis-server:服务存储</p><p>  将数据分成1024个slot,数据写入时候proxy会对key做crc32求hash，然后根据槽取模。槽的映射关系会交给zookeeper和etcd这种第三方组件来维护。</p><p>  槽的迁移，当发现请求的key正在迁移时候会强制key进行迁移之后在去新的槽去请求。</p><p>  支持自动平衡。</p><p>  缺点：因为不是官方的方案，所以支持新的特性比较困难，且不支持事物等命令。</p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>  redis官方集群方案。</p><p>  将数据分为16384个slot，每个节点都保留一份slot的配置信息，并且客户端链接时候会获取一份Slot信息，这部分信息持久化到redis-cluster中。</p><p>  slot的跳转：当客户端发现请求的数据已经迁移后客户端会收到MOVED &lt; newSlotNum &gt; &lt; ip:port &gt;可以更新客户端的配置，然后去新的server去获取。</p><p>  slot的迁移：迁移是以slot为单位进行迁移，当访问到迁移的key时候流程如下：</p><ul><li>想srcNodeAddr请求，如果key在srcNodeAddr进行操作</li><li>如果不在srcNodeAddr，返回-ASKING tragetNodeAddr</li><li>向tragetNodeAddr发送不带参数的ASKING节点</li><li><p>返回OK，去tragetNodeAddr getKey （目的是ASKING之后告诉tragetNodeAddr下一条指令不能不处理，因为在迁移中理论上tartNode不负责这个key）</p><p>redis的key如果是大Key，因为迁移指令是阻塞，会影响到服务。</p><p>redis的集群管理是通过Gossip协议的。当一个节点发现另一个节点失联（PFail），它会广播给集群，然后当集群中其他节点收到的该节点失联事件过半数（PFail Count）时候，就标记该节点下线。</p><p>另外，redis-cluster的槽位迁移、节点切换都是在客户端做的。</p></li></ul><h2 id="分布式锁的不安全性"><a href="#分布式锁的不安全性" class="headerlink" title="分布式锁的不安全性"></a>分布式锁的不安全性</h2><p>由于主节点宕机客户端无感知，所以当客户端从主节点获取锁后，未同步到从节点这时候发生宕机。锁数据未同步成功发生了主从切换，锁是失效的，如果业务不容忍可以采用redlock机制。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-基本原理</title>
      <link href="Redis-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>Redis-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>  redis是单线程的，IO模型采用多路复用</p><h2 id="redis的线程模型"><a href="#redis的线程模型" class="headerlink" title="redis的线程模型"></a>redis的线程模型</h2><p>  redis的io是单线程多路复用。</p><p>  为客户端关键字关联一个请求队列和响应队列，用于处理请求和响应。</p><p>  定时任务采用最小堆的方案，俩个定时任务的间隔时间就是select(timeout)的timeout</p><h2 id="redis的备份"><a href="#redis的备份" class="headerlink" title="redis的备份"></a>redis的备份</h2><p>快照用于全量备份，AOF是命令重放用于增量备份</p><h3 id="快照的备份原理CoW"><a href="#快照的备份原理CoW" class="headerlink" title="快照的备份原理CoW"></a>快照的备份原理CoW</h3><p>由于redis的快照备份需要用到磁盘IO是没有NIO的，为了不影响业务的正常请求，redis的磁盘备份采用了系统的COW。方法如下</p><ol><li>父进程调用glibc，fork出一个子进程，这时候子进程和父进程会同时返回。父进程pid大于0,子进程pid等于0，如果小于0说明没有资源，由于是fork出的子进程，俩者共享代码段和数据段</li><li>父进程依然处理正常请求，子进程处理快照的持久化</li><li>对于写的请求，会用到系统的cow。父进程在写的时候会将数据页复制一份，在复制的这份里进行修改，子进程对应的数据页不做变更，在fork出来的那一刻就固定下来了</li></ol><p>注意，随着父进程写请求的增多，内存会持续增长，不过也不会超过原数据段的2倍。</p><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>  随着日积月累，AOF的体积会逐渐增大，一旦重放会导致redis长期无法对外提供服务</p><p>  瘦身：bgrewriteaof，</p><ol><li>开辟一个新的进程遍历内存的数据，转换成一些列的指令，写到新的aof文件中</li><li>新增的aof指令追加的这个文件中</li><li><p>替换原文件完成瘦身</p><p>fsync，redis写aof文件是些到一个内核的内存中，通过调用fsync刷到磁盘中，如果这段时间服务器宕机会丢失数据。redis采用glibc的fsync(int fd)方法每隔一段时间刷盘一次。（每次命令都刷盘会降低吞吐）</p></li></ol><h3 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h3><p>  由于aof的fsync和快照的大块写文件都影响性能，建议持久化放在从库中做，为了防止磁盘分区还建议有多个从库。</p><h2 id="pipeline和事物"><a href="#pipeline和事物" class="headerlink" title="pipeline和事物"></a>pipeline和事物</h2><p>  pipeline简称管道，为了减少网络的开销，piplline可以一次提交多条指令给redis一起执行，本质上是client的行为。</p><p>  事物：redis支持事物，但是无法解决事物的原子性，只能保证事物的隔离性。redis事物的隔离性是通过管道来实现的</p><p>  为了节省性能，redis的事物往往配合pipeline一起使用。</p><p>  事物命令<br>  multi、exec、discard</p><h2 id="pubsub"><a href="#pubsub" class="headerlink" title="pubsub"></a>pubsub</h2><p>  redis自身的消息队列，缺点很明显:消息不能持久化，发送的消息只能被当时在线的消费者消费，如果消费者宕机是无法消费消息的。这个特性可以做服务发现。后续5.0提供了stream来取代它</p><p>  支持模式订阅，message订阅</p><h2 id="对象的压缩"><a href="#对象的压缩" class="headerlink" title="对象的压缩"></a>对象的压缩</h2><p>如果小于4G可以采用32位进行编译，内存会少一半</p><h3 id="zipList"><a href="#zipList" class="headerlink" title="zipList"></a>zipList</h3><p>压缩列表，redis在zset、hash、intset这些数据结构存储数据时候在一定阈值下回采用ziplist来存储。</p><p>ziplist实际上是数组的一个变种，有点是：元素长度不固定节省空间，内存地址连续对缓存友好。</p><p>zset：元素个数不超过128，k/v长度不超过64</p><p>hash、list：元素个数不超过512，k/v长度不超过64</p><p>set：不超过512，数据是intset时候，会进行升级，随着元素的增大会从uint16–&gt;uint32–&gt;unint64</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>  redis是以页为单位回收内存的，如果该数据页有一个key,也不会被回收。但是可以被重复使用，这点和mysql很类似</p><p>  redis的内存管理采用第三方库默认是jemallloc</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-基础数据结构</title>
      <link href="Redis-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>Redis-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>  redis所有数据的基础，采用预分配进行数据的分配当数据小于1MB时候，成倍扩容，大于1MB每次扩容1倍。最大512MB。</p><p>  int类型支持计数</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>  quicklist的数据结构（ziplist+双向链表）</p><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>  类似于Java的hashmap，采用数组+链表方式，数据量小采用ziplist。</p><p>  rehash采用渐进式</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>  底层采用一个特殊的字典来维护，字典的值都为NULL</p><h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>  (skiplist or ziplist)+hash</p><h2 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h2><ul><li><p>setbit key offset value【0 or 1】 set某一位的bit值</p></li><li><p>getbit key offset 返回当前位的值</p></li><li><p>bitcount key [start end] 返回start-end值为1的bit的数量。start-end必须是8的倍数</p></li><li><p>bitpos key [true false] 返回第一个true or false的值。</p></li></ul><h2 id="hyperHyperLog"><a href="#hyperHyperLog" class="headerlink" title="hyperHyperLog"></a>hyperHyperLog</h2><ul><li>pfadd key value 不同的才会加入到列表中</li><li>pfcount key 查看key的值</li></ul><p>用于统计网站的uv，大小是12kb,缺点是有误差</p><h2 id="bloomfilter"><a href="#bloomfilter" class="headerlink" title="bloomfilter"></a>bloomfilter</h2><p>redis4.0以后提供插件支持</p><ul><li>bf.add</li><li>bf.exists</li></ul><p>重复并且存在误判。</p><h2 id="Reids的限流–redis-cell"><a href="#Reids的限流–redis-cell" class="headerlink" title="Reids的限流–redis-cell"></a>Reids的限流–redis-cell</h2><p>redis4.0后提供的限流模块</p><p>cl.throttle key capacity opsQuota opssec quota-pre-action</p><p>返回值<br>0 or 1 –结果0允许，1不允许<br>capacity–漏斗容量<br>left_quota–剩余容量<br>next_gen_quota_sec–下一次产生多少令牌的事件<br>maxQuotaSec–令牌桶满，下一次capacity=left_quota的时间 单位：秒</p><h2 id="Redis的位置服务-GeoHash"><a href="#Redis的位置服务-GeoHash" class="headerlink" title="Redis的位置服务-GeoHash"></a>Redis的位置服务-GeoHash</h2><p>  原理是，将地球变为一个平面，划分成一系列方格每个方格有一个唯一编号，方格越近编号越近，将坐标的经纬度映射为一维坐标，放在唯一的方格中，只需要查看俩个方格的距离即可。</p><p>  坐标会变成一串整数编码越长越精确，这些整数编码能还原成坐标。getHash会对这个整数做一次base32。</p><p>  redis的坐标编码是52位，且底层采用zset。value是key，score是哪个52位的编码，我们查询附近的坐标只需要按照score查询即可</p><p>  命令</p><ul><li>geoadd key 精度 纬度 value  添加</li><li>geodist key value1 value2 单位 查询value1和value2的距离</li><li>geoops  key value 获取value的坐标</li><li>geohash key value 获取hash值可以计算出经纬度</li><li>georediusbymember key value 20 km [withcoord withdist withhash] count 3 asc 查找value半径20km的其他坐标【包括自己】 按照距离升序排列</li><li>georedius key value x y 20 km  [withcoord withdist withhash] count 3 asc  查找坐标点【x、y】半径20km的其他坐标【包括自己】 按照距离升序排列</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoketMq源码学习-七-事务的实现</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%83-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>RocketMq分布式事务采用的是XA协议。其中的TransactionManager由Broker担任。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>producer发送half-Message(prepare)给broker。</li><li>发送成功后，producer侧开始执行本地事务，sendResult会包含transactionId和本地事务进行绑定，之后broker反查消息需通过这个ID来处理事物。（用户实现）</li><li>本地事务执行成功后，发送commit或者rollback状态给broker。</li><li>Broker确认是否收到了Producer发送的commit或者rollback的消息<ol><li>Broker收到消息<ol><li>如果收到的是commit，认为事务提交成功，交由consumer处理</li><li>如果收到的是rollback，认为事务回滚，consumer看不到本条消息。broker删除half-Message。(rocketmq会先将消息发送到一个事务专用的topic中QueueId为0，然后如果commit成功会将消息移到real_topic中,消费者订阅的是real_topic这时候就能看到消息了，如果rollback是不会移动的消费者就看不到这条消息)</li></ol></li><li>Broker没收到消息<ol><li>borker定时回查本地事务，如果本地事务已经执行返回commit；如果本地事务未执行rollback；（用户实现）<ol><li>commit:返回commit，说明事务已经提交，consumer进行执行</li><li>rollback:回滚：</li><li>unknown:一直会差到成功为止</li></ol></li></ol></li></ol></li><li>事务的消费，和传统消息消费没什么区别，不过要注意，rocketmq的消费者侧的本地事务如果失败了，需要自行解决数据一致性，毕竟rocketmq整体事务回滚代价太大了</li></ol><h2 id="官方Demo"><a href="#官方Demo" class="headerlink" title="官方Demo"></a>官方Demo</h2><p>发送的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//事务的监听器，本地事务在这里进行</span></span><br><span class="line">        TransactionListener transactionListener = <span class="keyword">new</span> TransactionListenerImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者采用TransactionMQProducer</span></span><br><span class="line">        TransactionMQProducer producer = <span class="keyword">new</span> TransactionMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理broker会查本地事务的线程池</span></span><br><span class="line">        <span class="comment">//producer接到broker发送的RequestCode.CHECK_TRANSACTION_STATE，异步来会差处理本地事务的状态，并且返回给borker</span></span><br><span class="line">        ExecutorService executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                thread.setName(<span class="string">"client-transaction-msg-check-thread"</span>);</span><br><span class="line">                <span class="keyword">return</span> thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = <span class="keyword">new</span> String[] &#123;<span class="string">"TagA"</span>, <span class="string">"TagB"</span>, <span class="string">"TagC"</span>, <span class="string">"TagD"</span>, <span class="string">"TagE"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg =</span><br><span class="line">                    <span class="keyword">new</span> Message(<span class="string">"TopicTest1234"</span>, tags[i % tags.length], <span class="string">"KEY"</span> + i,</span><br><span class="line">                        (<span class="string">"Hello RocketMQ "</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                <span class="comment">//send half message给broker</span></span><br><span class="line">                <span class="comment">//如果sendResult是sendOk会开始执行transactionListener.executeLocalTransaction逻辑,即本地事务。</span></span><br><span class="line">                <span class="comment">//然后根据localTransactionState发送请求给RequestCode.END_TRANSACTION，broker来选择事务是否完成</span></span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>TransactionMQProducer关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionMQProducer</span> <span class="keyword">extends</span> <span class="title">DefaultMQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于borker回查事务消息用</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="comment">//监听器</span></span><br><span class="line">    <span class="keyword">private</span> TransactionListener transactionListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化事务相关的环境具体见小面代码</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducerImpl.initTransactionEnv();</span><br><span class="line">        <span class="keyword">super</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.shutdown();</span><br><span class="line">        <span class="comment">//停止事务</span></span><br><span class="line">        <span class="keyword">this</span>.defaultMQProducerImpl.destroyTransactionEnv();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Object arg)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.transactionListener) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"TransactionListener is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//发送事务类型的消息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultMQProducerImpl.sendMessageInTransaction(msg, <span class="keyword">null</span>, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defaultMQProducerImpl的相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTransactionEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//TransactionMQProducer中的defaultMQProducerImpl持有的对象只可能是TransactionMQProducer</span></span><br><span class="line">    TransactionMQProducer producer = (TransactionMQProducer) <span class="keyword">this</span>.defaultMQProducer;</span><br><span class="line">    <span class="keyword">if</span> (producer.getExecutorService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.checkExecutor = producer.getExecutorService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.checkRequestQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(producer.getCheckRequestHoldMax());</span><br><span class="line">        <span class="keyword">this</span>.checkExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                producer.getCheckThreadPoolMinSize(),</span><br><span class="line">                producer.getCheckThreadPoolMaxSize(),</span><br><span class="line">                <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">this</span>.checkRequestQueue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyTransactionEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.checkExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.checkExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.发送half-message消息sendOk执行本地任务</span></span><br><span class="line"><span class="comment"> * 2.执行完本地事务通过endTransaction消息通知borker事务结果</span></span><br><span class="line"><span class="comment"> * 3.封装TransactionSendResult返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg half message</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> localTransactionExecuter 已经不在需要了传空就好了，5.0.0会用producer的transactionListener替代</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg 消息参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> TransactionSendResult 返回执行结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MQClientException 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TransactionSendResult <span class="title">sendMessageInTransaction</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">final</span> LocalTransactionExecuter localTransactionExecuter, <span class="keyword">final</span> Object arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    TransactionListener transactionListener = getCheckListener();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionExecuter &amp;&amp; <span class="keyword">null</span> == transactionListener) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"tranExecutor is null"</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//为Message设置相关Tranaction的属性，根据PROPERTY_TRANSACTION_PREPARED属性broker知道是half-message</span></span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, <span class="string">"true"</span>);</span><br><span class="line">    MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    <span class="comment">//发送half-message</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        sendResult = <span class="keyword">this</span>.send(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"send message Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">    Throwable localException = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (sendResult.getSendStatus()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEND_OK: &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//发送结果返回了transactionId，将结果写入到Property。暂时没用到感觉，而且sendResult.getTransactionId为空</span></span><br><span class="line">                <span class="keyword">if</span> (sendResult.getTransactionId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    msg.putUserProperty(<span class="string">"__transactionId__"</span>, sendResult.getTransactionId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//发送消息调用setUniqID时候生成的唯一ID作为事务ID:业务方通过这个事务ID和本地事务绑定处理反差逻辑</span></span><br><span class="line">                String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != transactionId &amp;&amp; !<span class="string">""</span>.equals(transactionId)) &#123;</span><br><span class="line">                    msg.setTransactionId(transactionId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//不用关心5.0.0会删掉</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != localTransactionExecuter) &#123;</span><br><span class="line">                    localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">"Used new transaction API"</span>);</span><br><span class="line">                    <span class="comment">//处理本地事物返回localTransactionState</span></span><br><span class="line">                    localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == localTransactionState) &#123;</span><br><span class="line">                    localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                    log.info(<span class="string">"executeLocalTransactionBranch return &#123;&#125;"</span>, localTransactionState);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.info(<span class="string">"executeLocalTransactionBranch exception"</span>, e);</span><br><span class="line">                log.info(msg.toString());</span><br><span class="line">                localException = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLUSH_DISK_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">        <span class="keyword">case</span> SLAVE_NOT_AVAILABLE:</span><br><span class="line">            localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给borker发送本地事物结束的request</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.warn(<span class="string">"local transaction execute "</span> + localTransactionState + <span class="string">", but end broker transaction failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransactionSendResult transactionSendResult = <span class="keyword">new</span> TransactionSendResult();</span><br><span class="line">    transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">    transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">    transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">    transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">    transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">    transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">    <span class="keyword">return</span> transactionSendResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endTransaction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SendResult sendResult,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Throwable localException)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">//通过half-message获取MessageId,优先取OffsetMsgId:消息追加到磁盘时候生成的ID16byte，包含【来源地址+msg在文件中的偏移量】）</span></span><br><span class="line">    <span class="keyword">final</span> MessageId id;</span><br><span class="line">    <span class="keyword">if</span> (sendResult.getOffsetMsgId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为空</span></span><br><span class="line">    String transactionId = sendResult.getTransactionId();</span><br><span class="line">    <span class="comment">//查找borker地址</span></span><br><span class="line">    <span class="keyword">final</span> String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建EndTransactionRequest请求</span></span><br><span class="line">    EndTransactionRequestHeader requestHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">    requestHeader.setTransactionId(transactionId);</span><br><span class="line">    requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">    <span class="comment">//设置Message的标记是回滚还是commit</span></span><br><span class="line">    <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">        <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UNKNOW:</span><br><span class="line">            requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">    requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">    String remark = localException != <span class="keyword">null</span> ? (<span class="string">"executeLocalTransactionBranch exception: "</span> + localException.toString()) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">            <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h3><p>主要有3个部分</p><h4 id="接收半消息消息"><a href="#接收半消息消息" class="headerlink" title="接收半消息消息"></a>接收半消息消息</h4><p>  处理half-message的入口在SendMessageProcessor.processRequest()方法中，前面介绍消息发送时候介绍过这里不在过多赘述，最终我们跟到SendMessageProcessor.sendMessage方法中，这里在处理发送的事件时候会判断消息的PROPERTY_TRANSACTION_PREPARED标记是否为true如果为true。会调用brokerController.getTransactionalMessageService().prepareMessage，具体如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> SendMessageContext sendMessageContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> SendMessageRequestHeader requestHeader)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">                                            ......</span><br><span class="line">String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">        <span class="keyword">if</span> (traFlag != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(traFlag)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">                response.setRemark(</span><br><span class="line">                        <span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1()</span><br><span class="line">                                + <span class="string">"] sending transaction message is forbidden"</span>);</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里就是重点</span></span><br><span class="line">            putMessageResult = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().prepareMessage(msgInner);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟下去：brokerController.getTransactionalMessageService中TransactionalMessageService的实现类TransactionalMessageServiceImpl的prepareMessage方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">prepareMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transactionalMessageBridge.putHalfMessage(messageInner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putHalfMessage</span><span class="params">(MessageExtBrokerInner messageInner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.putMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理preparedMessage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MessageExtBrokerInner <span class="title">parseHalfMessageInner</span><span class="params">(MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());</span><br><span class="line">    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,</span><br><span class="line">        String.valueOf(msgInner.getQueueId()));</span><br><span class="line">    msgInner.setSysFlag(</span><br><span class="line">        MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">    <span class="comment">//RMQ_SYS_TRANS_HALF_TOPIC,queueId始终为0</span></span><br><span class="line">    msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());</span><br><span class="line">    msgInner.setQueueId(<span class="number">0</span>);</span><br><span class="line">    msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">    <span class="keyword">return</span> msgInner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回查half-message"><a href="#回查half-message" class="headerlink" title="回查half-message"></a>回查half-message</h4><p>  brokerController在启动时候，会启动一个检查线程定期林旭RMQ_SYS_TRANS_HALF_TOPIC这个Topic中是否有过期的half-message，然后对这个half-message的producer发送RequestCode.CHECK_TRANSACTION_STATE的请求</p><p>过程和代码如下：</p><ol><li>brokerController在initialTransaction初始化TransactionalMessageCheckService</li><li>brokerController在start时候调用TransactionalMessageCheckService的start方法启动线程</li><li>TransactionalMessageCheckService每隔1分钟轮询一次RMQ_SYS_TRANS_HALF_TOPIC这个topic，发现过期half-message后通知producer。</li></ol><p>TransactionalMessageCheckService关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWaitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeout = brokerController.getBrokerConfig().getTransactionTimeOut();</span><br><span class="line">    <span class="keyword">int</span> checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();</span><br><span class="line">    <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">    log.info(<span class="string">"Begin to check prepare message, begin time:&#123;&#125;"</span>, begin);</span><br><span class="line">    <span class="comment">//检查过期事务</span></span><br><span class="line">    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().check(timeout, checkMax, <span class="keyword">this</span>.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">    log.info(<span class="string">"End to check prepare message, consumed time:&#123;&#125;"</span>, System.currentTimeMillis() - begin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟TransactionalMessageServiceImpl.check</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> transactionTimeout, <span class="keyword">int</span> transactionCheckMax,</span></span></span><br><span class="line"><span class="function"><span class="params">    AbstractTransactionalMessageCheckListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Half-message topic</span></span><br><span class="line">        String topic = MixAll.RMQ_SYS_TRANS_HALF_TOPIC;</span><br><span class="line">        Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">        <span class="keyword">if</span> (msgQueues == <span class="keyword">null</span> || msgQueues.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"The queue of topic is empty :"</span> + topic);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"Check topic=&#123;&#125;, queues=&#123;&#125;"</span>, topic, msgQueues);</span><br><span class="line">        <span class="comment">//有Half-message,检查如果有消息过期默认是6sec,省略大部分校验过程</span></span><br><span class="line">        <span class="keyword">for</span> (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">            <span class="keyword">long</span> opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            List&lt;Long&gt; doneOpOffset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            HashMap&lt;Long, Long&gt; removeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// single thread</span></span><br><span class="line">            <span class="keyword">int</span> getMessageNullCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> newOffset = halfOffset;</span><br><span class="line">            <span class="keyword">long</span> i = halfOffset;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (removeMap.containsKey(i)) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//读取</span></span><br><span class="line">                    GetResult getResult = getHalfMsg(messageQueue, i);</span><br><span class="line">                    MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                    <span class="keyword">if</span> (msgExt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        .....</span><br><span class="line">                    &#125;</span><br><span class="line">                    List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">                    <span class="keyword">boolean</span> isNeedCheck = (opMsg == <span class="keyword">null</span> &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                        || (opMsg != <span class="keyword">null</span> &amp;&amp; (opMsg.get(opMsg.size() - <span class="number">1</span>).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                        || (valueOfCurrentMinusBorn &lt;= -<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (isNeedCheck) &#123;</span><br><span class="line">                        <span class="comment">//给msgExt赋值half-message的msgId等属性</span></span><br><span class="line">                        <span class="keyword">if</span> (!putBackHalfMsgQueue(msgExt, i)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//处理half-message</span></span><br><span class="line">                        listener.resolveHalfMsg(msgExt);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                newOffset = i + <span class="number">1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (newOffset != halfOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">            <span class="keyword">if</span> (newOpOffset != opOffset) &#123;</span><br><span class="line">                transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">"Check error"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟进listener.resolveHalfMsg中去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resolveHalfMsg</span><span class="params">(<span class="keyword">final</span> MessageExt msgExt)</span> </span>&#123;</span><br><span class="line">    executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sendCheckMessage(msgExt);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Send check message error!"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendCheckMessage</span><span class="params">(MessageExt msgExt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CheckTransactionStateRequestHeader checkTransactionStateRequestHeader = <span class="keyword">new</span> CheckTransactionStateRequestHeader();</span><br><span class="line">    checkTransactionStateRequestHeader.setCommitLogOffset(msgExt.getCommitLogOffset());</span><br><span class="line">    checkTransactionStateRequestHeader.setOffsetMsgId(msgExt.getMsgId());</span><br><span class="line">    <span class="comment">//注意下这个MsgId就是MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX，分布式任务开始时，发送half-message设置</span></span><br><span class="line">    checkTransactionStateRequestHeader.setMsgId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));</span><br><span class="line">    checkTransactionStateRequestHeader.setTransactionId(checkTransactionStateRequestHeader.getMsgId());</span><br><span class="line"></span><br><span class="line">    checkTransactionStateRequestHeader.setTranStateTableOffset(msgExt.getQueueOffset());</span><br><span class="line">    msgExt.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC));</span><br><span class="line">    msgExt.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line">    msgExt.setStoreSize(<span class="number">0</span>);</span><br><span class="line">    String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">    Channel channel = brokerController.getProducerManager().getAvaliableChannel(groupId);</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGGER.warn(<span class="string">"Check transaction failed, channel is null. groupId=&#123;&#125;"</span>, groupId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  prouder处理RequestCode.CHECK_TRANSACTION_STATE</p><ol><li>produer的ClientRemotingProcessor会调用 this.checkTransactionState(ctx, request);</li><li>this.checkTransactionState(ctx, request);会调用producer.checkTransactionState(addr, messageExt, requestHeader);</li><li>producer.checkTransactionState(addr, messageExt, requestHeader);处理事务的逻辑代码如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkTransactionState</span><span class="params">(<span class="keyword">final</span> String addr, <span class="keyword">final</span> MessageExt msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CheckTransactionStateRequestHeader header)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用线程池去处理</span></span><br><span class="line">    Runnable request = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String brokerAddr = addr;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageExt message = msg;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CheckTransactionStateRequestHeader checkRequestHeader = header;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String group = DefaultMQProducerImpl.<span class="keyword">this</span>.defaultMQProducer.getProducerGroup();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            TransactionListener transactionListener = getCheckListener();</span><br><span class="line">            <span class="keyword">if</span> (transactionCheckListener != <span class="keyword">null</span> || transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (transactionCheckListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ......</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (transactionListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        log.debug(<span class="string">"Used new check API in transaction message"</span>);</span><br><span class="line">                        <span class="comment">//...业务自己处理检查事务状态</span></span><br><span class="line">                        localTransactionState = transactionListener.checkLocalTransaction(message);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.warn(<span class="string">"CheckTransactionState, pick transactionListener by group[&#123;&#125;] failed"</span>, group);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"Broker call checkTransactionState, but checkLocalTransactionState exception"</span>, e);</span><br><span class="line">                    exception = e;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//内部方法</span></span><br><span class="line">                <span class="keyword">this</span>.processTransactionState(</span><br><span class="line">                        localTransactionState,</span><br><span class="line">                        group,</span><br><span class="line">                        exception);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"CheckTransactionState, pick transactionCheckListener by group[&#123;&#125;] failed"</span>, group);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processTransactionState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> LocalTransactionState localTransactionState,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> String producerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">final</span> Throwable exception)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> EndTransactionRequestHeader thisHeader = <span class="keyword">new</span> EndTransactionRequestHeader();</span><br><span class="line">            thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());</span><br><span class="line">            thisHeader.setProducerGroup(producerGroup);</span><br><span class="line">            thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());</span><br><span class="line">            thisHeader.setFromTransactionCheck(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取消息的msgID，优先取事务中的MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX，如果为空会取，发送来的MsgId</span></span><br><span class="line">            String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">            <span class="keyword">if</span> (uniqueKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">                uniqueKey = message.getMsgId();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            thisHeader.setMsgId(uniqueKey);</span><br><span class="line">            <span class="comment">//这个值和最开始发送办消息的message是一样的见上面</span></span><br><span class="line">            thisHeader.setTransactionId(checkRequestHeader.getTransactionId());</span><br><span class="line">            <span class="keyword">switch</span> (localTransactionState) &#123;</span><br><span class="line">                <span class="keyword">case</span> COMMIT_MESSAGE:</span><br><span class="line">                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ROLLBACK_MESSAGE:</span><br><span class="line">                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">                    log.warn(<span class="string">"when broker check, client rollback this transaction, &#123;&#125;"</span>, thisHeader);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> UNKNOW:</span><br><span class="line">                    thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">                    log.warn(<span class="string">"when broker check, client does not know this transaction state, &#123;&#125;"</span>, thisHeader);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String remark = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                remark = <span class="string">"checkLocalTransactionState Exception: "</span> + RemotingHelper.exceptionSimpleDesc(exception);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                DefaultMQProducerImpl.<span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark,</span><br><span class="line">                        <span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"endTransactionOneway exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.checkExecutor.submit(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="处理EndTransaction"><a href="#处理EndTransaction" class="headerlink" title="处理EndTransaction"></a>处理EndTransaction</h4><p>  在本地事务完成或者检查后都需要给broker发送RequestCode.END_TRANSACTION信息，broker在接到请求流程是</p><p>  EndTransactionProcessor的processRequest处理具体请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> EndTransactionRequestHeader requestHeader =</span><br><span class="line">        (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">    LOGGER.info(<span class="string">"Transaction request:&#123;&#125;"</span>, requestHeader);</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">        response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">        LOGGER.warn(<span class="string">"Message store is slave mode, so end transaction is forbidden. "</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求来自于TransactionCheck，打印log</span></span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getFromTransactionCheck()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OperationResult result = <span class="keyword">new</span> OperationResult();</span><br><span class="line">    <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            <span class="comment">//校验halfmessage的Offset和Produceguroup的信息等</span></span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="comment">//重点，将消息移到真实的Topic和QueueId，这样consumer才能看到</span></span><br><span class="line">                MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                <span class="comment">//重置标记等信息</span></span><br><span class="line">                msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                RemotingCommand sendResult = sendFinalMessage(msgInner);</span><br><span class="line">                <span class="comment">//删除halfmessage</span></span><br><span class="line">                <span class="keyword">if</span> (sendResult.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">        <span class="comment">//回滚事务</span></span><br><span class="line">        result = <span class="keyword">this</span>.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">        <span class="keyword">if</span> (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">            RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">            <span class="keyword">if</span> (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                <span class="keyword">this</span>.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setCode(result.getResponseCode());</span><br><span class="line">    response.setRemark(result.getResponseRemark());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-NIO-ByteBuffer</title>
      <link href="JAVA-NIO-ByteBuffer/"/>
      <url>JAVA-NIO-ByteBuffer/</url>
      
        <content type="html"><![CDATA[<h2 id="bytebuffer"><a href="#bytebuffer" class="headerlink" title="bytebuffer"></a>bytebuffer</h2><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li>position:下一次读取或写入的位置。</li><li>limit:指定还有多少数据需要取出(在从缓冲区写入通道时)，或者还有多少空间可以放入数据(在从通道读入缓冲区时)。</li><li>capacity:指定了可以存储在缓冲区中的最大数据容量，实际上，它指定了底层数组的大小，或者至少是指定了准许我们使用的底层数组的容量。</li><li>mark:标记位配置mark和reset方法</li></ul><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><ul><li>allocateDirect：堆外内存</li><li>allocate：堆内内存</li></ul><h2 id="几个重要的方法介绍"><a href="#几个重要的方法介绍" class="headerlink" title="几个重要的方法介绍"></a>几个重要的方法介绍</h2><h3 id="compact-压缩缓冲区，将未读的数据放在缓冲区头部"><a href="#compact-压缩缓冲区，将未读的数据放在缓冲区头部" class="headerlink" title="compact-压缩缓冲区，将未读的数据放在缓冲区头部"></a>compact-压缩缓冲区，将未读的数据放在缓冲区头部</h3><p> 将position到limit的数据复制到0到limit-postion中，同时position等于limit-postion，limit等于capacity。一般用于继续写。</p><p> 例如：postion=1,limit=10,capacity=10，经过compact后，position=9，limit=10，capacity=10</p><h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p>  position为0，limit=capacity，一般在写之前调用，buffer可以从头开始写。</p><h3 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h3><p>  limit变为当前的position，用于读取，一般在读取buffer之前调用，可以返回0-limit之间的数据。</p><h3 id="rewind"><a href="#rewind" class="headerlink" title="rewind"></a>rewind</h3><p>  读写都可以用，只是将position置为0，mark置为-1。表示可以重新读写。</p><h3 id="mark和reset"><a href="#mark和reset" class="headerlink" title="mark和reset"></a>mark和reset</h3><p>  mark：指定一个特定的position一个标记位<br>  reset：在mark指定的标记位开始进行操作</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>  slice() 方法根据现有的缓冲区创建一个子缓冲区,俩者共享数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer orgBuffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line">orgBuffer.put(<span class="string">"liuhao"</span>.getBytes());</span><br><span class="line">orgBuffer.flip();</span><br><span class="line"></span><br><span class="line">ByteBuffer newBuffer = orgBuffer.slice();</span><br><span class="line">System.out.println(<span class="string">"newBuffer init slice ="</span> + newBuffer);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"============"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] stringNew = <span class="keyword">new</span> <span class="keyword">byte</span>[newBuffer.limit()];</span><br><span class="line">newBuffer.get(stringNew);</span><br><span class="line">System.out.println(<span class="string">"read new buffer "</span> + <span class="keyword">new</span> String(stringNew));<span class="comment">//和orgBuffer读出来的一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对newBuffer做了修改，影响了orgBuffer</span></span><br><span class="line">newBuffer.clear();</span><br><span class="line">newBuffer.put(<span class="string">"lzh"</span>.getBytes());</span><br><span class="line"><span class="keyword">byte</span>[] stringOrg = <span class="keyword">new</span> <span class="keyword">byte</span>[orgBuffer.limit()];</span><br><span class="line">orgBuffer.get(stringOrg);</span><br><span class="line">System.out.println(<span class="string">"read org buffer "</span> + <span class="keyword">new</span> String(stringOrg));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoketMq源码学习-六-Offset的存储</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%85%AD-Offset%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%85%AD-Offset%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<p>Consumer维护OffSet的接口是：OffsetStore，有俩个实现类</p><ul><li>RemoteBrokerOffsetStore：消息模式是Cluster会用到它</li><li>LocalFileOffsetStore：消息模式是BoardCast会用到它</li></ul><p>我们以RemoteBrokerOffsetStore为例来看读取offset的顺序</p><h2 id="RemoteBrokerOffsetStore读取offset的顺序"><a href="#RemoteBrokerOffsetStore读取offset的顺序" class="headerlink" title="RemoteBrokerOffsetStore读取offset的顺序"></a>RemoteBrokerOffsetStore读取offset的顺序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq, <span class="keyword">final</span> ReadOffsetType type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> MEMORY_FIRST_THEN_STORE:</span><br><span class="line">            <span class="keyword">case</span> READ_FROM_MEMORY: &#123;</span><br><span class="line">                AtomicLong offset = <span class="keyword">this</span>.offsetTable.get(mq);</span><br><span class="line">                <span class="keyword">if</span> (offset != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> offset.get();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ReadOffsetType.READ_FROM_MEMORY == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> READ_FROM_STORE: &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> brokerOffset = <span class="keyword">this</span>.fetchConsumeOffsetFromBroker(mq);</span><br><span class="line">                    AtomicLong offset = <span class="keyword">new</span> AtomicLong(brokerOffset);</span><br><span class="line">                    <span class="keyword">this</span>.updateOffset(mq, offset.get(), <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">return</span> brokerOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// No offset in broker</span></span><br><span class="line">                <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Other exceptions</span></span><br><span class="line">                <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"fetchConsumeOffsetFromBroker exception, "</span> + mq, e);</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要从broker读取的时候调用fetchConsumeOffsetFromBroker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">fetchConsumeOffsetFromBroker</span><span class="params">(MessageQueue mq)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException,</span></span><br><span class="line"><span class="function">        InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    <span class="comment">//获取broker from memory</span></span><br><span class="line">    FindBrokerResult findBrokerResult = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == findBrokerResult) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(mq.getTopic());</span><br><span class="line">        findBrokerResult = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInAdmin(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sendBroker get Offset</span></span><br><span class="line">    <span class="keyword">if</span> (findBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        QueryConsumerOffsetRequestHeader requestHeader = <span class="keyword">new</span> QueryConsumerOffsetRequestHeader();</span><br><span class="line">        requestHeader.setTopic(mq.getTopic());</span><br><span class="line">        requestHeader.setConsumerGroup(<span class="keyword">this</span>.groupName);</span><br><span class="line">        requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从broker取consumerOffSet</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().queryConsumerOffset(</span><br><span class="line">                findBrokerResult.getBrokerAddr(), requestHeader, <span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">queryConsumerOffset</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> QueryConsumerOffsetRequestHeader requestHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.QUERY_CONSUMER_OFFSET, requestHeader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送同步请求,这时候当前线程会阻塞</span></span><br><span class="line">    RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class="keyword">this</span>.clientConfig.isVipChannelEnabled(), addr),</span><br><span class="line">            request, timeoutMillis);</span><br><span class="line">    <span class="keyword">assert</span> response != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS: &#123;</span><br><span class="line">            QueryConsumerOffsetResponseHeader responseHeader =</span><br><span class="line">                    (QueryConsumerOffsetResponseHeader) response.decodeCommandCustomHeader(QueryConsumerOffsetResponseHeader.class);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> responseHeader.getOffset();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broker处理QUERY_CONSUMER_OFFSET请求的逻辑</p><p>从ConsumerQueue中获取offset</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">queryConsumerOffset</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="comment">//创建响应</span></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response =</span><br><span class="line">        RemotingCommand.createResponseCommand(QueryConsumerOffsetResponseHeader.class);</span><br><span class="line">    <span class="comment">//响应头</span></span><br><span class="line">    <span class="keyword">final</span> QueryConsumerOffsetResponseHeader responseHeader =</span><br><span class="line">        (QueryConsumerOffsetResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="comment">//请求头</span></span><br><span class="line">    <span class="keyword">final</span> QueryConsumerOffsetRequestHeader requestHeader =</span><br><span class="line">        (QueryConsumerOffsetRequestHeader) request</span><br><span class="line">            .decodeCommandCustomHeader(QueryConsumerOffsetRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> offset =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().queryOffset(</span><br><span class="line">            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果&gt;=0</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        responseHeader.setOffset(offset);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> minOffset =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().getMinOffsetInQueue(requestHeader.getTopic(),</span><br><span class="line">                requestHeader.getQueueId());</span><br><span class="line">        <span class="comment">//如果小于等于0，并且创建ConsumerQueue成功</span></span><br><span class="line">        <span class="keyword">if</span> (minOffset &lt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; !<span class="keyword">this</span>.brokerController.getMessageStore().checkInDiskByConsumeOffset(</span><br><span class="line">            requestHeader.getTopic(), requestHeader.getQueueId(), <span class="number">0</span>)) &#123;</span><br><span class="line">            responseHeader.setOffset(<span class="number">0L</span>);</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//错误</span></span><br><span class="line">            response.setCode(ResponseCode.QUERY_NOT_FOUND);</span><br><span class="line">            response.setRemark(<span class="string">"Not found, V3_0_6_SNAPSHOT maybe this group consumer boot first"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMinOffsetInQueue</span><span class="params">(String topic, <span class="keyword">int</span> queueId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//getAndCreateQueue</span></span><br><span class="line">    ConsumeQueue logic = <span class="keyword">this</span>.findConsumeQueue(topic, queueId);</span><br><span class="line">    <span class="keyword">if</span> (logic != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//找到队列里最小的offsetminLogicOffset / CQ_STORE_UNIT_SIZE</span></span><br><span class="line">        <span class="keyword">return</span> logic.getMinOffsetInQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConsumeQueue <span class="title">findConsumeQueue</span><span class="params">(String topic, <span class="keyword">int</span> queueId)</span> </span>&#123;</span><br><span class="line">    ConcurrentMap&lt;Integer, ConsumeQueue&gt; map = consumeQueueTable.get(topic);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == map) &#123;</span><br><span class="line">        <span class="comment">//防止并发</span></span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; newMap = <span class="keyword">new</span> ConcurrentHashMap&lt;Integer, ConsumeQueue&gt;(<span class="number">128</span>);</span><br><span class="line">        ConcurrentMap&lt;Integer, ConsumeQueue&gt; oldMap = consumeQueueTable.putIfAbsent(topic, newMap);</span><br><span class="line">        <span class="keyword">if</span> (oldMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map = oldMap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map = newMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ConsumeQueue logic = map.get(queueId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == logic) &#123;</span><br><span class="line"></span><br><span class="line">        ConsumeQueue newLogic = <span class="keyword">new</span> ConsumeQueue(</span><br><span class="line">                topic,</span><br><span class="line">                queueId,</span><br><span class="line">                StorePathConfigHelper.getStorePathConsumeQueue(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()),</span><br><span class="line">                <span class="keyword">this</span>.getMessageStoreConfig().getMapedFileSizeConsumeQueue(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//防止并发</span></span><br><span class="line">        ConsumeQueue oldLogic = map.putIfAbsent(queueId, newLogic);</span><br><span class="line">        <span class="keyword">if</span> (oldLogic != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logic = oldLogic;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logic = newLogic;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logic;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoketMq源码学习-五-消息的消费-下</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9-%E4%B8%8B/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9-%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<p>  上一篇讲了rocketmq在消费消息时候consumer的流程和原理，本章会将broker做了什么。</p><h2 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h2><p>  这里会涉及到一个关键类是ConsumeQueue，rocketmq为了规避kafka在mq增多时候会导致磁盘IO下降的问题，特有的设计。它是一个逻辑队列，里面保存了CommitLog的index。每次拉取消息broker会根据MessageQueue的Id去里面查找偏移量然后去commitLog拉取消息</p><p>  它保存的信息格式如下：<br>  <img src="/RoketMq源码学习-五-消息的消费-下/cmq.png" alt="avatror"><br>  其中：消息的起始物理偏移量physical offset(long 8字节)+消息大小size(int 4字节)+tagsCode(long 8字节)，每条数据的大小为20个字节，从而每个文件的默认大小为600万个字节。</p><p>  文件的地址是：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}</p><p>  每个cosumequeue文件的名称fileName，名字长度为20位，左边补零，剩余为起始偏移量；比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为600W，当第一个文件满之后创建的第二个文件的名字为00000000000006000000，起始偏移量为6000000，以此类推，第三个文件名字为00000000000012000000，起始偏移量为12000000，消息存储的时候会顺序写入文件，当文件满了，写入下一个文件</p><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="Broker处理PULL-MESSAGE请求"><a href="#Broker处理PULL-MESSAGE请求" class="headerlink" title="Broker处理PULL_MESSAGE请求"></a>Broker处理PULL_MESSAGE请求</h3><p>通过PullMessageProcessor#processRequest来处理拉取消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">processRequest</span><span class="params">(<span class="keyword">final</span> Channel channel, RemotingCommand request, <span class="keyword">boolean</span> brokerAllowSuspend)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="comment">//响应</span></span><br><span class="line">    RemotingCommand response = RemotingCommand.createResponseCommand(PullMessageResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> PullMessageResponseHeader responseHeader = (PullMessageResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="comment">//解析请求头</span></span><br><span class="line">    <span class="keyword">final</span> PullMessageRequestHeader requestHeader =</span><br><span class="line">        (PullMessageRequestHeader) request.decodeCommandCustomHeader(PullMessageRequestHeader.class);</span><br><span class="line">    <span class="comment">//Reponse setOpaque用于处理响应</span></span><br><span class="line">    response.setOpaque(request.getOpaque());</span><br><span class="line"></span><br><span class="line">    ...... 验证权限</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取订阅组配置，如果不存在就new一个</span></span><br><span class="line">    SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getConsumerGroup());</span><br><span class="line"></span><br><span class="line">    ......验证订阅组</span><br><span class="line"></span><br><span class="line">    <span class="comment">//见consumer的PullSysFlag.buildSysFlag</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasSuspendFlag = PullSysFlag.hasSuspendFlag(requestHeader.getSysFlag());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasCommitOffsetFlag = PullSysFlag.hasCommitOffsetFlag(requestHeader.getSysFlag());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasSubscriptionFlag = PullSysFlag.hasSubscriptionFlag(requestHeader.getSysFlag());</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> suspendTimeoutMillisLong = hasSuspendFlag ? requestHeader.getSuspendTimeoutMillis() : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证topic权限</span></span><br><span class="line">    TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">    ...验证topic</span><br><span class="line"></span><br><span class="line">    <span class="comment">//验证queueId</span></span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getQueueId() &lt; <span class="number">0</span> || requestHeader.getQueueId() &gt;= topicConfig.getReadQueueNums()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubscriptionData subscriptionData = <span class="keyword">null</span>;</span><br><span class="line">    ConsumerFilterData consumerFilterData = <span class="keyword">null</span>;</span><br><span class="line">    ...... 校验过滤方式</span><br><span class="line">    MessageFilter messageFilter;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isFilterSupportRetry()) &#123;</span><br><span class="line">        messageFilter = <span class="keyword">new</span> ExpressionForRetryMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        messageFilter = <span class="keyword">new</span> ExpressionMessageFilter(subscriptionData, consumerFilterData,</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerFilterManager());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键代码从MessageStore中读取Message</span></span><br><span class="line">    <span class="comment">// 这里是根据请求的QueueId也就是MessageQueue的queueId去查询当前的ConsumerQueue对应的消息（没有则创建一个）</span></span><br><span class="line">    <span class="keyword">final</span> GetMessageResult getMessageResult =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getMessageStore().getMessage(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">            requestHeader.getQueueId(), requestHeader.getQueueOffset(), requestHeader.getMaxMsgNums(), messageFilter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getMessageResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//设置response</span></span><br><span class="line">        response.setRemark(getMessageResult.getStatus().name());</span><br><span class="line">        responseHeader.setNextBeginOffset(getMessageResult.getNextBeginOffset());</span><br><span class="line">        responseHeader.setMinOffset(getMessageResult.getMinOffset());</span><br><span class="line">        responseHeader.setMaxOffset(getMessageResult.getMaxOffset());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置SuggestWhichBrokerId</span></span><br><span class="line">        <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">            <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SLAVE:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">            <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">            <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// consume ok</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理响应值</span></span><br><span class="line">        <span class="keyword">switch</span> (getMessageResult.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> FOUND:</span><br><span class="line">                response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_WAS_REMOVING:</span><br><span class="line">                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NO_MATCHED_LOGIC_QUEUE:</span><br><span class="line">            <span class="keyword">case</span> NO_MESSAGE_IN_QUEUE:</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != requestHeader.getQueueOffset()) &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> NO_MATCHED_MESSAGE:</span><br><span class="line">                response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_FOUND_NULL:</span><br><span class="line">                response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_OVERFLOW_BADLY:</span><br><span class="line">                response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                log.info(<span class="string">"the request offset: &#123;&#125; over flow badly, broker max offset: &#123;&#125;, consumer: &#123;&#125;"</span>,</span><br><span class="line">                    requestHeader.getQueueOffset(), getMessageResult.getMaxOffset(), channel.remoteAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_OVERFLOW_ONE:</span><br><span class="line">                response.setCode(ResponseCode.PULL_NOT_FOUND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OFFSET_TOO_SMALL:</span><br><span class="line">                response.setCode(ResponseCode.PULL_OFFSET_MOVED);</span><br><span class="line">                log.info(<span class="string">"the request offset too small. group=&#123;&#125;, topic=&#123;&#125;, requestOffset=&#123;&#125;, brokerMinOffset=&#123;&#125;, clientIp=&#123;&#125;"</span>,</span><br><span class="line">                    requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueOffset(),</span><br><span class="line">                    getMessageResult.getMinOffset(), channel.remoteAddress());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook()) &#123;</span><br><span class="line">            .....<span class="comment">//执行hook</span></span><br><span class="line">            <span class="keyword">this</span>.executeConsumeMessageHookBefore(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">                <span class="comment">//处理统计信息</span></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                    getMessageResult.getMessageCount());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                    getMessageResult.getBufferTotalSize());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTransferMsgByHeap()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = <span class="keyword">this</span>.brokerController.getMessageStore().now();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重点代码 getMessageResult读取Message并且写入到reponse中</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] r = <span class="keyword">this</span>.readGetMessageResult(getMessageResult, requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetLatency(requestHeader.getConsumerGroup(),</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getQueueId(),</span><br><span class="line">                        (<span class="keyword">int</span>) (<span class="keyword">this</span>.brokerController.getMessageStore().now() - beginTimeMills));</span><br><span class="line">                    response.setBody(r);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//zero-copy??</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        FileRegion fileRegion =</span><br><span class="line">                            <span class="keyword">new</span> ManyMessageTransfer(response.encodeHeader(getMessageResult.getBufferTotalSize()), getMessageResult);</span><br><span class="line">                        channel.writeAndFlush(fileRegion).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                getMessageResult.release();</span><br><span class="line">                                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                                    log.error(<span class="string">"transfer many message by pagecache failed, &#123;&#125;"</span>, channel.remoteAddress(), future.cause());</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"transfer many message by pagecache exception"</span>, e);</span><br><span class="line">                        getMessageResult.release();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    response = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (brokerAllowSuspend &amp;&amp; hasSuspendFlag) &#123;</span><br><span class="line">                    <span class="keyword">long</span> pollingTimeMills = suspendTimeoutMillisLong;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;</span><br><span class="line">                        pollingTimeMills = <span class="keyword">this</span>.brokerController.getBrokerConfig().getShortPollingTimeMills();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String topic = requestHeader.getTopic();</span><br><span class="line">                    <span class="keyword">long</span> offset = requestHeader.getQueueOffset();</span><br><span class="line">                    <span class="keyword">int</span> queueId = requestHeader.getQueueId();</span><br><span class="line">                    PullRequest pullRequest = <span class="keyword">new</span> PullRequest(request, channel, pollingTimeMills,</span><br><span class="line">                        <span class="keyword">this</span>.brokerController.getMessageStore().now(), offset, subscriptionData, messageFilter);</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getPullRequestHoldService().suspendPullRequest(topic, queueId, pullRequest);</span><br><span class="line">                    response = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE</span><br><span class="line">                    || <span class="keyword">this</span>.brokerController.getMessageStoreConfig().isOffsetCheckInSlave()) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">                    mq.setTopic(requestHeader.getTopic());</span><br><span class="line">                    mq.setQueueId(requestHeader.getQueueId());</span><br><span class="line">                    mq.setBrokerName(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName());</span><br><span class="line"></span><br><span class="line">                    OffsetMovedEvent event = <span class="keyword">new</span> OffsetMovedEvent();</span><br><span class="line">                    event.setConsumerGroup(requestHeader.getConsumerGroup());</span><br><span class="line">                    event.setMessageQueue(mq);</span><br><span class="line">                    event.setOffsetRequest(requestHeader.getQueueOffset());</span><br><span class="line">                    event.setOffsetNew(getMessageResult.getNextBeginOffset());</span><br><span class="line">                    <span class="keyword">this</span>.generateOffsetMovedEvent(event);</span><br><span class="line">                    log.warn(</span><br><span class="line">                        <span class="string">"PULL_OFFSET_MOVED:correction offset. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, newOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), event.getOffsetRequest(), event.getOffsetNew(),</span><br><span class="line">                        responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">                    response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                    log.warn(<span class="string">"PULL_OFFSET_MOVED:none correction. topic=&#123;&#125;, groupId=&#123;&#125;, requestOffset=&#123;&#125;, suggestBrokerId=&#123;&#125;"</span>,</span><br><span class="line">                        requestHeader.getTopic(), requestHeader.getConsumerGroup(), requestHeader.getQueueOffset(),</span><br><span class="line">                        responseHeader.getSuggestWhichBrokerId());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">        response.setRemark(<span class="string">"store getMessage return null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;</span><br><span class="line">    storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag;</span><br><span class="line">    storeOffsetEnable = storeOffsetEnable</span><br><span class="line">        &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;</span><br><span class="line">    <span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">        <span class="comment">//记录消费的Offset</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultMessageStore#getMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> beginTime = <span class="keyword">this</span>.getSystemClock().now();</span><br><span class="line">    GetMessageStatus status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">    <span class="keyword">long</span> nextBeginOffset = offset;</span><br><span class="line">    <span class="keyword">long</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> maxOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    GetMessageResult getResult = <span class="keyword">new</span> GetMessageResult();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//物理队列最大偏移量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxOffsetPy = <span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get or create</span></span><br><span class="line">    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    <span class="keyword">if</span> (consumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//consumerQueue中消息的最小偏移量和最大偏移量，这里是消息数 校验</span></span><br><span class="line">        minOffset = consumeQueue.getMinOffsetInQueue();</span><br><span class="line">        maxOffset = consumeQueue.getMaxOffsetInQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxOffset == <span class="number">0</span>) &#123;</span><br><span class="line">            status = GetMessageStatus.NO_MESSAGE_IN_QUEUE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_TOO_SMALL;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset == maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_ONE;</span><br><span class="line">            nextBeginOffset = nextOffsetCorrection(offset, offset);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; maxOffset) &#123;</span><br><span class="line">            status = GetMessageStatus.OFFSET_OVERFLOW_BADLY;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == minOffset) &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, minOffset);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, maxOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//重点方法,这里的offset是消息的index，代表从这条消息开始读，所以转成真正的offset要*20</span></span><br><span class="line">            SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">            <span class="keyword">if</span> (bufferConsumeQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                    <span class="comment">//标志位</span></span><br><span class="line">                    <span class="keyword">long</span> nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    <span class="keyword">long</span> maxPhyOffsetPulling = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//一次最大拉取多少条信息这里是自己数，所以是Nums*20（）</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> maxFilterMessageCount = Math.max(<span class="number">16000</span>, maxMsgNums * ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> diskFallRecorded = <span class="keyword">this</span>.messageStoreConfig.isDiskFallRecorded();</span><br><span class="line">                    ConsumeQueueExt.CqExtUnit cqExtUnit = <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                    <span class="comment">//开始读取bufferConsumeQueue步长是20也就是一次读取一条，不超过bufferConsumeQueue的size和设置的最大条数</span></span><br><span class="line">                    <span class="keyword">for</span> (; i &lt; bufferConsumeQueue.getSize() &amp;&amp; i &lt; maxFilterMessageCount; i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        <span class="comment">//这就是ConsumerQueue每条消息的长度，</span></span><br><span class="line">                        <span class="comment">// offsetPy-物理消息偏移量</span></span><br><span class="line">                        <span class="comment">// sizePy-物理消息长度</span></span><br><span class="line">                        <span class="comment">// tag的hashCode</span></span><br><span class="line">                        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">                        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">                        <span class="keyword">long</span> tagsCode = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line"></span><br><span class="line">                        maxPhyOffsetPulling = offsetPy;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (nextPhyFileStartOffset != Long.MIN_VALUE) &#123;</span><br><span class="line">                            <span class="comment">//todo ??</span></span><br><span class="line">                            <span class="keyword">if</span> (offsetPy &lt; nextPhyFileStartOffset)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//检验消息是在磁盘还是内存，这里是maxOffsetPy-offsetPy&gt;memary（这里是总物理内存*使用40%），并且检查是否已满</span></span><br><span class="line">                        <span class="keyword">boolean</span> isInDisk = checkInDiskByCommitOffset(offsetPy, maxOffsetPy);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),</span><br><span class="line">                                isInDisk)) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//消息过滤</span></span><br><span class="line">                        <span class="keyword">boolean</span> extRet = <span class="keyword">false</span>, isTagsCodeLegal = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (consumeQueue.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                            extRet = consumeQueue.getExt(tagsCode, cqExtUnit);</span><br><span class="line">                            <span class="keyword">if</span> (extRet) &#123;</span><br><span class="line">                                tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// can't find ext content.Client will filter messages by tag also.</span></span><br><span class="line">                                log.error(<span class="string">"[BUG] can't find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;, topic=&#123;&#125;, group=&#123;&#125;"</span>,</span><br><span class="line">                                        tagsCode, offsetPy, sizePy, topic, group);</span><br><span class="line">                                isTagsCodeLegal = <span class="keyword">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//从ConsumerQueue过滤消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                                &amp;&amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : <span class="keyword">null</span>, extRet ? cqExtUnit : <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//根据ConsumeQueue从commitLog中读取消息</span></span><br><span class="line">                        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == selectResult) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.MESSAGE_WAS_REMOVING;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果没有消息，滚动到下一个文件开始</span></span><br><span class="line">                            nextPhyFileStartOffset = <span class="keyword">this</span>.commitLog.rollNextFile(offsetPy);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//从commitLog过滤消息</span></span><br><span class="line">                        <span class="keyword">if</span> (messageFilter != <span class="keyword">null</span></span><br><span class="line">                                &amp;&amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (getResult.getBufferTotalSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                                status = GetMessageStatus.NO_MATCHED_MESSAGE;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// release...</span></span><br><span class="line">                            selectResult.release();</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//统计信息</span></span><br><span class="line">                        <span class="keyword">this</span>.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();</span><br><span class="line">                        <span class="comment">//添加到结果中</span></span><br><span class="line">                        getResult.addMessage(selectResult);</span><br><span class="line">                        status = GetMessageStatus.FOUND;</span><br><span class="line">                        nextPhyFileStartOffset = Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (diskFallRecorded) &#123;</span><br><span class="line">                        <span class="keyword">long</span> fallBehind = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line">                    <span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">                            * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">                    getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    bufferConsumeQueue.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status = GetMessageStatus.OFFSET_FOUND_NULL;</span><br><span class="line">                nextBeginOffset = nextOffsetCorrection(offset, consumeQueue.rollNextFile(offset));</span><br><span class="line">                log.warn(<span class="string">"consumer request topic: "</span> + topic + <span class="string">"offset: "</span> + offset + <span class="string">" minOffset: "</span> + minOffset + <span class="string">" maxOffset: "</span></span><br><span class="line">                        + maxOffset + <span class="string">", but access logic queue failed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = GetMessageStatus.NO_MATCHED_LOGIC_QUEUE;</span><br><span class="line">        nextBeginOffset = nextOffsetCorrection(offset, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (GetMessageStatus.FOUND == status) &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalFound().incrementAndGet();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.storeStatsService.getGetMessageTimesTotalMiss().incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> eclipseTime = <span class="keyword">this</span>.getSystemClock().now() - beginTime;</span><br><span class="line">    <span class="keyword">this</span>.storeStatsService.setGetMessageEntireTimeMax(eclipseTime);</span><br><span class="line"></span><br><span class="line">    getResult.setStatus(status);</span><br><span class="line">    getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">    getResult.setMaxOffset(maxOffset);</span><br><span class="line">    getResult.setMinOffset(minOffset);</span><br><span class="line">    <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取索引<br>ConsumerQueue#getIndexBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line">    <span class="keyword">long</span> offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="keyword">this</span>.getMinLogicOffset()) &#123;</span><br><span class="line">        <span class="comment">//通过偏移量找到所在的文件</span></span><br><span class="line">        MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">        <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//重点方法 pos=offset % mappedFileSize即当前的偏移量</span></span><br><span class="line">            <span class="comment">//fileFromOffset+pos，byteBuffer(position:pos,limit:readPosition - pos),size:readPosition - pos,file：this</span></span><br><span class="line">            SelectMappedBufferResult result = mappedFile.selectMappedBuffer((<span class="keyword">int</span>) (offset % mappedFileSize));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReputService"><a href="#ReputService" class="headerlink" title="ReputService"></a>ReputService</h2><p>在broker启动时会启动改线程，没1ms执行一次负责将CommitLog中的新消息的信息记录cosumeQueue和IndexFile文件中。给出关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReputMessageService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> reputFromOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommitLogAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.reputFromOffset &lt; DefaultMessageStore.<span class="keyword">this</span>.commitLog.getMaxOffset();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//doNext and reputFromOffset小于broker的最大的可读的offset即最后一个文件的写活提交的offset</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">boolean</span> doNext = <span class="keyword">true</span>; <span class="keyword">this</span>.isCommitLogAvailable() &amp;&amp; doNext; ) &#123;</span><br><span class="line">               ......</span><br><span class="line"></span><br><span class="line">               <span class="comment">//当前commit文件reputFromOffset到ReadPostion的的byteBuffer</span></span><br><span class="line">               SelectMappedBufferResult result = DefaultMessageStore.<span class="keyword">this</span>.commitLog.getData(reputFromOffset);</span><br><span class="line">               <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       <span class="comment">//更新reputFromOffset</span></span><br><span class="line">                       <span class="keyword">this</span>.reputFromOffset = result.getStartOffset();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> readSize = <span class="number">0</span>; readSize &lt; result.getSize() &amp;&amp; doNext; ) &#123;</span><br><span class="line">                           <span class="comment">// 生成重放消息重放调度请求</span></span><br><span class="line">                           DispatchRequest dispatchRequest =</span><br><span class="line">                                   DefaultMessageStore.<span class="keyword">this</span>.commitLog.checkMessageAndReturnSize(result.getByteBuffer(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                           <span class="comment">// -1-失败，0-到文件尾，1-正常</span></span><br><span class="line">                           <span class="keyword">int</span> size = dispatchRequest.getMsgSize();</span><br><span class="line">                           <span class="keyword">if</span> (dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="comment">//构建ConsumeQueue</span></span><br><span class="line">                                   DefaultMessageStore.<span class="keyword">this</span>.doDispatch(dispatchRequest);</span><br><span class="line"></span><br><span class="line">                                   <span class="keyword">if</span> (BrokerRole.SLAVE != DefaultMessageStore.<span class="keyword">this</span>.getMessageStoreConfig().getBrokerRole()</span><br><span class="line">                                           &amp;&amp; DefaultMessageStore.<span class="keyword">this</span>.brokerConfig.isLongPollingEnable()) &#123;</span><br><span class="line">                                       <span class="comment">//通知有新的消息</span></span><br><span class="line">                                       DefaultMessageStore.<span class="keyword">this</span>.messageArrivingListener.arriving(dispatchRequest.getTopic(),</span><br><span class="line">                                               dispatchRequest.getQueueId(), dispatchRequest.getConsumeQueueOffset() + <span class="number">1</span>,</span><br><span class="line">                                               dispatchRequest.getTagsCode(), dispatchRequest.getStoreTimestamp(),</span><br><span class="line">                                               dispatchRequest.getBitMap(), dispatchRequest.getPropertiesMap());</span><br><span class="line">                                   &#125;</span><br><span class="line"></span><br><span class="line">                                   <span class="comment">//更新reputFromOffset下次构建从新的地方开始，readSize也增加</span></span><br><span class="line">                                   <span class="keyword">this</span>.reputFromOffset += size;</span><br><span class="line">                                   readSize += size;</span><br><span class="line">                                   ......</span><br><span class="line">                               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                                   <span class="comment">//见checkMessageAndReturnSize有可能遇到(msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank)这种情况所以返回0</span></span><br><span class="line">                                   <span class="comment">//这里reputFromOffset重置并且指定到下个文件</span></span><br><span class="line">                                   <span class="keyword">this</span>.reputFromOffset = DefaultMessageStore.<span class="keyword">this</span>.commitLog.rollNextFile(<span class="keyword">this</span>.reputFromOffset);</span><br><span class="line">                                   readSize = result.getSize();</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!dispatchRequest.isSuccess()) &#123;</span><br><span class="line">                             ......</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                       result.release();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   doNext = <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>CommitLog#checkMessageAndReturnSize校验消息返回message的校验结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * check the message and returns the message size</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 0 Come the end of the file // &gt;0 Normal messages // -1 Message checksum failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DispatchRequest <span class="title">checkMessageAndReturnSize</span><span class="params">(java.nio.ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">boolean</span> checkCRC,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">final</span> <span class="keyword">boolean</span> readBody)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1 TOTAL SIZE</span></span><br><span class="line">        <span class="keyword">int</span> totalSize = byteBuffer.getInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 MAGIC CODE</span></span><br><span class="line">        <span class="keyword">int</span> magicCode = byteBuffer.getInt();</span><br><span class="line">        <span class="keyword">switch</span> (magicCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_MAGIC_CODE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BLANK_MAGIC_CODE:</span><br><span class="line">                <span class="comment">//当存储消息的时候发现剩余空间不足一条消息时候就会触发这个结果</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DispatchRequest(<span class="number">0</span>, <span class="keyword">true</span> <span class="comment">/* success */</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                log.warn(<span class="string">"found a illegal magic code 0x"</span> + Integer.toHexString(magicCode));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DispatchRequest(-<span class="number">1</span>, <span class="keyword">false</span> <span class="comment">/* success */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">int</span> bodyLen = byteBuffer.getInt();</span><br><span class="line">        <span class="keyword">if</span> (bodyLen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (readBody) &#123;</span><br><span class="line">                <span class="comment">//......省略body校验</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                byteBuffer.position(byteBuffer.position() + bodyLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        String topic = <span class="keyword">new</span> String(bytesContent, <span class="number">0</span>, topicLen, MessageDecoder.CHARSET_UTF8);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//read properties</span></span><br><span class="line">        ......</span><br><span class="line">        Map&lt;String, String&gt; propertiesMap = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (propertiesLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            propertiesMap = MessageDecoder.string2messageProperties(properties);</span><br><span class="line"></span><br><span class="line">            keys = propertiesMap.get(MessageConst.PROPERTY_KEYS);</span><br><span class="line"></span><br><span class="line">            uniqKey = propertiesMap.get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line"></span><br><span class="line">            String tags = propertiesMap.get(MessageConst.PROPERTY_TAGS);</span><br><span class="line">            <span class="keyword">if</span> (tags != <span class="keyword">null</span> &amp;&amp; tags.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tagsCode = MessageExtBrokerInner.tagsString2tagsCode(MessageExt.parseTopicFilterType(sysFlag), tags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Timing message processing</span></span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="comment">// 延时消息将tagsCode设置为时间戳，为什么tagsCode要设置为时间戳后续讲延时消息的时候会分析</span></span><br><span class="line">                String t = propertiesMap.get(MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">                <span class="keyword">if</span> (ScheduleMessageService.SCHEDULE_TOPIC.equals(topic) &amp;&amp; t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> delayLevel = Integer.parseInt(t);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                        delayLevel = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (delayLevel &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        tagsCode = <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().computeDeliverTimestamp(delayLevel,</span><br><span class="line">                                storeTimestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> readLength = calMsgLength(bodyLen, topicLen, propertiesLength);</span><br><span class="line">        <span class="keyword">if</span> (totalSize != readLength) &#123;</span><br><span class="line">            doNothingForDeadCode(reconsumeTimes);</span><br><span class="line">            doNothingForDeadCode(flag);</span><br><span class="line">            doNothingForDeadCode(bornTimeStamp);</span><br><span class="line">            doNothingForDeadCode(byteBuffer1);</span><br><span class="line">            doNothingForDeadCode(byteBuffer2);</span><br><span class="line">            log.error(</span><br><span class="line">                    <span class="string">"[BUG]read total count not equals msg total size. totalSize=&#123;&#125;, readTotalCount=&#123;&#125;, bodyLen=&#123;&#125;, topicLen=&#123;&#125;, propertiesLength=&#123;&#125;"</span>,</span><br><span class="line">                    totalSize, readLength, bodyLen, topicLen, propertiesLength);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DispatchRequest(totalSize, <span class="keyword">false</span><span class="comment">/* success */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DispatchRequest(</span><br><span class="line">                topic,<span class="comment">//</span></span><br><span class="line">                queueId,<span class="comment">//这条消息的queueId</span></span><br><span class="line">                physicOffset,</span><br><span class="line">                totalSize,</span><br><span class="line">                tagsCode,</span><br><span class="line">                storeTimestamp,</span><br><span class="line">                queueOffset,</span><br><span class="line">                keys,</span><br><span class="line">                uniqKey,</span><br><span class="line">                sysFlag,</span><br><span class="line">                preparedTransactionOffset,</span><br><span class="line">                propertiesMap</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DispatchRequest(-<span class="number">1</span>, <span class="keyword">false</span> <span class="comment">/* success */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到DefaultMessageStore.this.doDispatch(dispatchRequest)方法，会调用CommitLogDispatcher#dispatch</p><p>这里分别是CommitLogDispatcherBuildConsumeQueue和CommitLogDispatcherBuildIndex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildConsumeQueue</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(request.getSysFlag());</span><br><span class="line">        <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">                DefaultMessageStore.<span class="keyword">this</span>.putMessagePositionInfo(request);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">            <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以后讲indexFile时候会讲。大致就是支持随机访问为了性能所以需要IndexFile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommitLogDispatcherBuildIndex</span> <span class="keyword">implements</span> <span class="title">CommitLogDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DefaultMessageStore.<span class="keyword">this</span>.messageStoreConfig.isMessageIndexEnable()) &#123;</span><br><span class="line">            DefaultMessageStore.<span class="keyword">this</span>.indexService.buildIndex(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在CommitLogDispatcherBuildConsumeQueue中主要方法是putMessagePostionInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfo</span><span class="params">(DispatchRequest dispatchRequest)</span> </span>&#123;</span><br><span class="line">    ConsumeQueue cq = <span class="keyword">this</span>.findConsumeQueue(dispatchRequest.getTopic(), dispatchRequest.getQueueId());</span><br><span class="line">    cq.putMessagePositionInfoWrapper(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConsumeQueue#putMessagePositionInfoWrapper中将这条消息的索引持久化到consumeQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxRetries &amp;&amp; canWrite; i++) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//关键代码</span></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">this</span>.putMessagePositionInfo(request.getCommitLogOffset(),</span><br><span class="line">                request.getMsgSize(), tagsCode, request.getConsumeQueueOffset());</span><br><span class="line"></span><br><span class="line">        ......处理结果</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="keyword">if</span> (offset &lt;= <span class="keyword">this</span>.maxPhysicOffset) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将这条消息的offset size tag写到consumeQueue文件中</span></span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoketMq源码学习-五-消息的消费-上</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9-%E4%B8%8A/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%94-%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>  关于消息的消费分为consumer和broker俩个模块，会分为俩篇文章阐述</p><p>  消费者按照消费方式的不同分为:</p><ul><li>MQPushConsumer实现类是：DefaultMQPushConsumer,由broker推送消息给consumer</li><li><p>MQPullConsumer实现类是：DefaultMQPullConsumer,定期去borker拉取消息</p><p>消费消息的逻辑通过接口MessageListener，它有俩个实现接口</p></li><li><p>MessageListenerConcurrently：并发的消费</p></li><li><p>MessageListenerOrderly：保序消费，</p><p>消费分为俩种模式MessageModel，即：</p></li><li><p>CLUSTERING:集群，默认</p></li><li>BROADCASTING:广播</li></ul><h2 id="DefaultMQPushConsumer"><a href="#DefaultMQPushConsumer" class="headerlink" title="DefaultMQPushConsumer"></a>DefaultMQPushConsumer</h2><p>类图：</p><p><img src="/RoketMq源码学习-五-消息的消费/DefaultMQPushConsumer.jpg" alt="avator"></p><p>整个流程如下：new DefaultMQPushConsumer()–&gt;subscribe–&gt;start()</p><h3 id="create以及重要属性"><a href="#create以及重要属性" class="headerlink" title="create以及重要属性"></a>create以及重要属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor specifying namespace, consumer group, RPC hook and message queue allocating algorithm.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> namespace Namespace for this MQ Producer instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumerGroup Consume queue.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rpcHook RPC hook to execute before each remoting command.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allocateMessageQueueStrategy Message queue allocating algorithm.消费端实现的队列选择器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String namespace, <span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">    AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">    <span class="keyword">this</span>.namespace = namespace;</span><br><span class="line">    <span class="keyword">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">    defaultMQPushConsumerImpl = <span class="keyword">new</span> DefaultMQPushConsumerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要属性</p><ul><li>defaultMQPushConsumerImpl：内部实现</li><li>consumerGroup：消费组</li><li>messageModel：消费方式默认是CLUSTERING、BROADCASTING:广播</li><li>consumeFromWhere,消费者启动前要设置ConsumeFromWhere，他们的含义是<ul><li>ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET：新消费第一次启动时候从最开始的Offset开始消费</li><li>ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET：新消费第一次启动时候从最近的Offset开始消费</li><li>ConsumeFromWhere.CONSUME_FROM_TIMESTAMP：：新消费第一次启动时候从最时间戳开始消费</li></ul></li><li>consumeTimestamp：默认半小时前和CONSUME_FROM_TIMESTAMP配合使用</li><li>allocateMessageQueueStrategy：消费者端的队列选择器，消费者从特定的queue消费消息’</li><li>subscription：tag的过滤器</li><li>messageListener：负责消息的消费</li><li>offsetStore：负责存储offset</li><li>consumeThreadMin和consumeThreadMax：消费消息启动的最小、最大线程数</li><li>adjustThreadPoolNumsThreshold：当消息堆积到该阈值时候会动态的调整消费线程数</li><li>consumeConcurrentlyMaxSpan：当队列允许的最大offset的跨度，到达后触发限流。只对并发消费（ConsumeMessageConcurrentlyService）有效</li><li>pullThresholdForQueue：每条consume queue的消息拉取下来后会缓存到本地，消费结束会删除。当累积达到一个阈值后，会触发该consumerqueue限流</li><li>pullThresholdForTopic：同上只是这个是针对topic的</li><li>pullThresholdSizeForQueue和pullThresholdSizeForTopic：限制消息缓存的大小单位是MiB，默认无限制</li><li>pullInterval：拉取消息队列的间隔，默认是0</li><li>consumeMessageBatchMaxSize：批量消费消息的条数，messageListener的方法中是个List[&lt;]MessageExt[&gt;] msgs，这个值就是控制msgs的的数量</li><li>pullBatchSize：去broker拉取消息一次多少条，和上面的属性关系一次拉取pullBatchSize条，分成pullBatchSize/consumeMessageBatchMaxSize个任务去消费 ？？</li><li>postSubscriptionWhenPull:每次拉取的时候是否更新订阅关系</li><li>unitMode:</li><li>maxReconsumeTimes:重试次数，达到会进入到私信队列，默认是是-1<ul><li>并行：16次</li><li>串行：无限次。一直等到消费成功后才会笑一次</li></ul></li><li>suspendCurrentQueueTimeMillis：串行消费重试的建个</li><li>consumeTimeout：消费过期时间</li></ul><h3 id="subscribe-订阅"><a href="#subscribe-订阅" class="headerlink" title="subscribe-订阅"></a>subscribe-订阅</h3><p>通过调用DefaultMQPushConsumerImpl#subscribe方法实现订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(String topic, String subExpression)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">            topic, subExpression);</span><br><span class="line">        <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mQClientFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"subscription exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><p>DefaultMQPushConsumer#start()会调用DefaultMQPushConsumerImpl#start(),即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                    <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel(), <span class="keyword">this</span>.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">            <span class="comment">//防止重复启动先改状态</span></span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消费者的配置校验</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理subcription和messageListenerInner</span></span><br><span class="line">            <span class="keyword">this</span>.copySubscription();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//defaultMQPushConsumer的InstanceName改为PID</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建MQClient和生产者共用一个类</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">            <span class="comment">//默认是AllocateMessageQueueAveragely</span></span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">            <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化拉取消息的Api封装类</span></span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                    mQClientFactory,</span><br><span class="line">                    <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">            <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//初始化OffsetStore，根据消息类型，如果是广播LocalFileOffsetStore，如果是集群消息需要RemoteBrokerOffsetStore</span></span><br><span class="line">            <span class="comment">//RemoteBrokerOffsetStore 从broker获取topic的</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                        <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="keyword">this</span>.offsetStore);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加载offset</span></span><br><span class="line">            <span class="keyword">this</span>.offsetStore.load();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据消费方式初始化并且启动consumeMessageService todo 重点看</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.consumeMessageService.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//mqClinetInstance注册消费者到内存中</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mQClientFactory.start();</span><br><span class="line">            log.info(<span class="string">"the consumer [&#123;&#125;] start OK."</span>, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The PushConsumer service state not OK, maybe started once, "</span></span><br><span class="line">                    + <span class="keyword">this</span>.serviceState</span><br><span class="line">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果订阅关系存在通过ReblanceImpl获取订阅关系rebalanceImpl#getSubscriptionInner,获取订阅关系</span></span><br><span class="line"><span class="comment">     * 如果订阅关系不为空。通过NameServer获取TopicRouteInfo并且更新rebalanceImpl中的topicSubscribeInfoTable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">    <span class="comment">//去broker校验Consumer状态，包括consumer的substring的有孝心等</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">    <span class="comment">//给所有的Broker发送心跳包(code是HEART_BEAT)，包括遍历每个消费者生成Consumer信息包括，消费这的类型、消息模式、FromWhere、订阅信息等,</span></span><br><span class="line">    <span class="comment">// broker发送HEAT_BEAT请求，完成消费者的注册等工作</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">    <span class="comment">// 1.mQClientFactory#rebalanceImmediately唤醒RebalanceService</span></span><br><span class="line">    <span class="comment">// 2.RebalanceService#run调用mQClientFactory#doRebalance</span></span><br><span class="line">    <span class="comment">// 3.mQClientFactory#doRebalance遍历ConsumerTable（上面registerConsumer方法put的consumer），调用DefaultMQPushConsumerImpl#doRebalance</span></span><br><span class="line">    <span class="comment">// 4.DefaultMQPushConsumerImpl#doRebalance调用RebalanceImpl.doRebalance进行遍历</span></span><br><span class="line">    <span class="comment">// 5.**还有个重要的目的通过dorebalnce激活pullmessageService的run方法，在死循环中向broker发送pullMessage的消息</span></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>broker在收到HEAT_BEAT的请求后，会调用heatbeat方法，该方法同时处理prodcuer和consumer的注册，其中consumer的注册是调用this.brokerController#getConsumerManager#registerConsumer的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">heartBeat</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">        ...... <span class="comment">//解析协议</span></span><br><span class="line">        <span class="keyword">boolean</span> isNotifyConsumerIdsChangedEnable = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != subscriptionGroupConfig) &#123;</span><br><span class="line">            isNotifyConsumerIdsChangedEnable = subscriptionGroupConfig.isNotifyConsumerIdsChangedEnable();</span><br><span class="line">            <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (data.isUnitMode()) &#123;</span><br><span class="line">                topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建RetryTopic：%RETRY%ConsumerGroup，给所有的broker发送信息注册这个topic</span></span><br><span class="line">            String newTopic = MixAll.getRetryTopic(data.getGroupName());</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(</span><br><span class="line">                newTopic,</span><br><span class="line">                subscriptionGroupConfig.getRetryQueueNums(),<span class="comment">//默认是1</span></span><br><span class="line">                PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//broker通过consumerManager注册消费者</span></span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">this</span>.brokerController.getConsumerManager().registerConsumer(</span><br><span class="line">            data.getGroupName(),</span><br><span class="line">            clientChannelInfo,</span><br><span class="line">            data.getConsumeType(),</span><br><span class="line">            data.getMessageModel(),</span><br><span class="line">            data.getConsumeFromWhere(),</span><br><span class="line">            data.getSubscriptionDataSet(),</span><br><span class="line">            isNotifyConsumerIdsChangedEnable</span><br><span class="line">        );</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册消费者</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group                            消费组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clientChannelInfo                客户端链接的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumeType                      消费类型 push or pull</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageModel                     消息类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> consumeFromWhere                 fromWhere</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> subList                          订阅关系的列表，每个consumer的RebalanceImpl#subscriptionInner在注册时候put进去的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isNotifyConsumerIdsChangedEnable 是否通知客户端的开关</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerConsumer</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> ClientChannelInfo clientChannelInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ConsumeType consumeType, MessageModel messageModel, ConsumeFromWhere consumeFromWhere,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> Set&lt;SubscriptionData&gt; subList, <span class="keyword">boolean</span> isNotifyConsumerIdsChangedEnable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//get or create ConsumerGroupInfo</span></span><br><span class="line">    ConsumerGroupInfo consumerGroupInfo = <span class="keyword">this</span>.consumerTable.get(group);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == consumerGroupInfo) &#123;</span><br><span class="line">        ConsumerGroupInfo tmp = <span class="keyword">new</span> ConsumerGroupInfo(group, consumeType, messageModel, consumeFromWhere);</span><br><span class="line">        ConsumerGroupInfo prev = <span class="keyword">this</span>.consumerTable.putIfAbsent(group, tmp);</span><br><span class="line">        consumerGroupInfo = prev != <span class="keyword">null</span> ? prev : tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新clientChannelInfo</span></span><br><span class="line">    <span class="keyword">boolean</span> r1 =</span><br><span class="line">            consumerGroupInfo.updateChannel(clientChannelInfo, consumeType, messageModel,</span><br><span class="line">                    consumeFromWhere);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新SubscriptionData，将remote的更新到本地，并且清理掉已经不存在的SubscriptionData</span></span><br><span class="line">    <span class="keyword">boolean</span> r2 = consumerGroupInfo.updateSubscription(subList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r1 || r2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNotifyConsumerIdsChangedEnable) &#123;</span><br><span class="line">            <span class="comment">//通知所有的消费者，该group订阅关系发送变化 发送NOTIFY_CONSUMER_IDS_CHANGED事件，所有该group下的consumer会立刻做doBalance操作</span></span><br><span class="line">            <span class="keyword">this</span>.consumerIdsChangeListener.handle(ConsumerGroupEvent.CHANGE, group, consumerGroupInfo.getAllChannel());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consumerIdsChangeListener处理注册事件，调用getConsumerFilterManager().register todo mark 待看</span></span><br><span class="line">    <span class="keyword">this</span>.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r1 || r2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遗留问题：this.consumerIdsChangeListener.handle(ConsumerGroupEvent.REGISTER, group, subList);</p><h3 id="SubscriptionData"><a href="#SubscriptionData" class="headerlink" title="SubscriptionData"></a>SubscriptionData</h3><h3 id="rebalanceImpl"><a href="#rebalanceImpl" class="headerlink" title="rebalanceImpl"></a>rebalanceImpl</h3><h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><p>  虽然叫做DefaultMQPushConusmerImpl,但是消息的消费实际上是一个pull的过程，那么消息是如何保证实时性的呢？</p><p>  消息的消费分为拉取消息和消费消息里俩步，拉取消息是PullMessageService类来负责，消费消息ConsumeMessageService来负责</p><p>  在PullMessageService中是一个用阻塞队列实现的典型的生产者消费者模式实现的。见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePullRequestImmediately</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullRequestQueue.put(pullRequest);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">"executePullRequestImmediately pullRequestQueue.put"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环，从队列中拉取消息</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PullRequest pullRequest = <span class="keyword">this</span>.pullRequestQueue.take();</span><br><span class="line">            <span class="keyword">this</span>.pullMessage(pullRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Pull Message Service Run Method exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中executePullRequestImmediately就是触发PullRequest的。</p><ol><li>当我们的消费者start()之后会调用mQClientFactory.rebalanceImmediately()，在跟进该方法的过程中发现updateProcessQueueTableInRebalance方法，最终会调用dispatchPullRequest该方法会调用executePullRequestImmediately实际上就触发了消息的拉取</li><li>run会调用DefaultMQPushConsumerImpl的pullMessage方法在改方法中通过pullAPIWrapper.pullKernelImpl去broker拉取消息。</li><li>在拉取之后并且在pullCallback中调用ConsumeMessageService消费消息。并且重新调用executePullRequestImmediately重复上述2。</li></ol><p>综上，rocketmq就是用这种不停的take–&gt;pull–&gt;add来保证消息的实时性的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pullMessage</span><span class="params">(<span class="keyword">final</span> PullRequest pullRequest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessQueue processQueue = pullRequest.getProcessQueue();</span><br><span class="line">    <span class="comment">//省略校验操作</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">    PullCallback pullCallback = <span class="keyword">new</span> PullCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(PullResult pullResult)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (pullResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pullResult = DefaultMQPushConsumerImpl.<span class="keyword">this</span>.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span><br><span class="line">                        subscriptionData);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//FOUND NO_NEW_MSG NO_MATCHED_MSG OFFSET_ILLEGAL都会将pullRequest重新放入到pullRequestQueue对列中，</span></span><br><span class="line">                <span class="comment">//然后PullMessageService的run()方法在进行下一次的拉取。</span></span><br><span class="line">                <span class="comment">//PullMessageService的run方法是个死循环，通过pullRequestQueue.take来保证实时性。</span></span><br><span class="line">                <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> FOUND:</span><br><span class="line">                        <span class="keyword">long</span> prevRequestOffset = pullRequest.getNextOffset();</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line">                        <span class="keyword">long</span> pullRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span><br><span class="line">                                pullRequest.getMessageQueue().getTopic(), pullRT);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> firstMsgOffset = Long.MAX_VALUE;</span><br><span class="line">                        <span class="comment">//如果msgFoundList为空</span></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getMsgFoundList() == <span class="keyword">null</span> || pullResult.getMsgFoundList().isEmpty()) &#123;</span><br><span class="line">                            <span class="comment">//</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            firstMsgOffset = pullResult.getMsgFoundList().get(<span class="number">0</span>).getQueueOffset();</span><br><span class="line"></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span><br><span class="line">                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">boolean</span> dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span><br><span class="line">                            <span class="comment">//消息的消费逻辑</span></span><br><span class="line">                            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.consumeMessageService.submitConsumeRequest(</span><br><span class="line">                                    pullResult.getMsgFoundList(),</span><br><span class="line">                                    processQueue,</span><br><span class="line">                                    pullRequest.getMessageQueue(),</span><br><span class="line">                                    dispatchToConsume);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//根据设置进行下一次的拉取任务</span></span><br><span class="line">                            <span class="keyword">if</span> (DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest,</span><br><span class="line">                                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.defaultMQPushConsumer.getPullInterval());</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span><br><span class="line">                                || firstMsgOffset &lt; prevRequestOffset) &#123;</span><br><span class="line">                            log.warn(</span><br><span class="line">                                    <span class="string">"[BUG] pull message result maybe data wrong, nextBeginOffset: &#123;&#125; firstMsgOffset: &#123;&#125; prevRequestOffset: &#123;&#125;"</span>,</span><br><span class="line">                                    pullResult.getNextBeginOffset(),</span><br><span class="line">                                    firstMsgOffset,</span><br><span class="line">                                    prevRequestOffset);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.correctTagsOffset(pullRequest);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestImmediately(pullRequest);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line"></span><br><span class="line">                        log.warn(<span class="string">"the pull request offset illegal, &#123;&#125; &#123;&#125;"</span>,</span><br><span class="line">                                pullRequest.toString(), pullResult.toString());</span><br><span class="line">                        pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span><br><span class="line"></span><br><span class="line">                        pullRequest.getProcessQueue().setDropped(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">//OFFSET_ILLEGAL 在10s后会通过rebalanceImpl#removeProcessQueue摘除messageQueue</span></span><br><span class="line">                        DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executeTaskLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span><br><span class="line">                                            pullRequest.getNextOffset(), <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.offsetStore.persist(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    DefaultMQPushConsumerImpl.<span class="keyword">this</span>.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span><br><span class="line"></span><br><span class="line">                                    log.warn(<span class="string">"fix the pull request offset, &#123;&#125;"</span>, pullRequest);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                                    log.error(<span class="string">"executeTaskLater Exception"</span>, e);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="number">10000</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                log.warn(<span class="string">"execute the pull request exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DefaultMQPushConsumerImpl.<span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> commitOffsetEnable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffsetValue = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">if</span> (MessageModel.CLUSTERING == <span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        commitOffsetValue = <span class="keyword">this</span>.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span><br><span class="line">        <span class="keyword">if</span> (commitOffsetValue &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            commitOffsetEnable = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String subExpression = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> classFilter = <span class="keyword">false</span>;</span><br><span class="line">    SubscriptionData sd = <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span><br><span class="line">    <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) &#123;</span><br><span class="line">            subExpression = sd.getSubString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        classFilter = sd.isClassFilterMode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sysFlag = PullSysFlag.buildSysFlag(</span><br><span class="line">            commitOffsetEnable, <span class="comment">// commitOffset</span></span><br><span class="line">            <span class="keyword">true</span>, <span class="comment">// suspend</span></span><br><span class="line">            subExpression != <span class="keyword">null</span>, <span class="comment">// subscription</span></span><br><span class="line">            classFilter <span class="comment">// class filter</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重点:想broker发送PULL_MESSAGE的请求拉取消息，拉取后将response转成PullResultExt然后经过pullCallback处理拉取结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">                pullRequest.getMessageQueue(),</span><br><span class="line">                subExpression,</span><br><span class="line">                subscriptionData.getExpressionType(),</span><br><span class="line">                subscriptionData.getSubVersion(),</span><br><span class="line">                pullRequest.getNextOffset(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQPushConsumer.getPullBatchSize(),</span><br><span class="line">                sysFlag,</span><br><span class="line">                commitOffsetValue,</span><br><span class="line">                BROKER_SUSPEND_MAX_TIME_MILLIS,</span><br><span class="line">                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,</span><br><span class="line">                CommunicationMode.ASYNC,</span><br><span class="line">                pullCallback</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"pullKernelImpl exception"</span>, e);</span><br><span class="line">        <span class="keyword">this</span>.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拉取消息在consumer测的过程"><a href="#拉取消息在consumer测的过程" class="headerlink" title="拉取消息在consumer测的过程"></a>拉取消息在consumer测的过程</h3><ol><li>pullAPIWrapper.pullKernelImpl会调用MQClientAPIImpl#pullMessage方法给broker发送RequestCode.PULL_MESSAGE请求</li><li>发送方式默认是ASYNC,所以在pullMessageAsync方法中会处理将response转成PullResultExt对象，这时候MsgList是空。<ul><li>通过调用  processPullResponse()方法来转换</li></ul></li><li>之后在InvokeCallback回调中调用pullCallback完成消费</li></ol><p>pullMessageAsync具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pullMessageAsync</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> RemotingCommand request,//pullmessage请求</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> PullCallback pullCallback</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.remotingClient.invokeAsync(addr, request, timeoutMillis, <span class="keyword">new</span> InvokeCallback() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ResponseFuture responseFuture)</span> </span>&#123;</span><br><span class="line">            RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    PullResult pullResult = MQClientAPIImpl.<span class="keyword">this</span>.processPullResponse(response);</span><br><span class="line">                    <span class="keyword">assert</span> pullResult != <span class="keyword">null</span>;</span><br><span class="line">                    pullCallback.onSuccess(pullResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    pullCallback.onException(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pullCallback.onException...省略</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processPullResponse具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PullResult <span class="title">processPullResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> RemotingCommand response)</span> <span class="keyword">throws</span> MQBrokerException, RemotingCommandException </span>&#123;</span><br><span class="line">    PullStatus pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">    <span class="comment">//根据repsonse转换code</span></span><br><span class="line">    <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">            pullStatus = PullStatus.FOUND;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_NOT_FOUND:</span><br><span class="line">            pullStatus = PullStatus.NO_NEW_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_RETRY_IMMEDIATELY:</span><br><span class="line">            pullStatus = PullStatus.NO_MATCHED_MSG;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ResponseCode.PULL_OFFSET_MOVED:</span><br><span class="line">            pullStatus = PullStatus.OFFSET_ILLEGAL;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PullMessageResponseHeader responseHeader =</span><br><span class="line">            (PullMessageResponseHeader) response.decodeCommandCustomHeader(PullMessageResponseHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PullResultExt(pullStatus, responseHeader.getNextBeginOffset(), responseHeader.getMinOffset(),</span><br><span class="line">            responseHeader.getMaxOffset(), <span class="keyword">null</span>, responseHeader.getSuggestWhichBrokerId(), response.getBody());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="consumer消费消息"><a href="#consumer消费消息" class="headerlink" title="consumer消费消息"></a>consumer消费消息</h3><p>拉取到消息后，在PullCallBack中会调用consumeMessageService.submitConsumeRequest来消费消息，实际上是封装成ConsumeRequest在线程池中批量消费消息，具体见下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MessageExt&gt; msgs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConsumeRequest</span><span class="params">(List&lt;MessageExt&gt; msgs, ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.msgs = msgs;</span><br><span class="line">            <span class="keyword">this</span>.processQueue = processQueue;</span><br><span class="line">            <span class="keyword">this</span>.messageQueue = messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;MessageExt&gt; <span class="title">getMsgs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> msgs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ProcessQueue <span class="title">getProcessQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> processQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            MessageListenerConcurrently listener = ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.messageListener;</span><br><span class="line">            ConsumeConcurrentlyContext context = <span class="keyword">new</span> ConsumeConcurrentlyContext(messageQueue);</span><br><span class="line">            ConsumeConcurrentlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">                consumeMessageContext.setConsumerGroup(defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">                consumeMessageContext.setMq(messageQueue);</span><br><span class="line">                consumeMessageContext.setMsgList(msgs);</span><br><span class="line">                consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">                <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                        MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//自定义的消费逻辑</span></span><br><span class="line">                status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.warn(<span class="string">"consumeMessage exception: &#123;&#125; Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                    RemotingHelper.exceptionSimpleDesc(e),</span><br><span class="line">                    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                    msgs,</span><br><span class="line">                    messageQueue);</span><br><span class="line">                hasException = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行consumer的hook</span></span><br><span class="line">            <span class="keyword">long</span> consumeRT = System.currentTimeMillis() - beginTimestamp;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasException) &#123;</span><br><span class="line">                    returnType = ConsumeReturnType.EXCEPTION;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    returnType = ConsumeReturnType.RETURNNULL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (consumeRT &gt;= defaultMQPushConsumer.getConsumeTimeout() * <span class="number">60</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                returnType = ConsumeReturnType.TIME_OUT;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.RECONSUME_LATER == status) &#123;</span><br><span class="line">                returnType = ConsumeReturnType.FAILED;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status) &#123;</span><br><span class="line">                returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                consumeMessageContext.getProps().put(MixAll.CONSUME_CONTEXT_TYPE, returnType.name());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">                log.warn(<span class="string">"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                    ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                    msgs,</span><br><span class="line">                    messageQueue);</span><br><span class="line">                status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                consumeMessageContext.setStatus(status.toString());</span><br><span class="line">                consumeMessageContext.setSuccess(ConsumeConcurrentlyStatus.CONSUME_SUCCESS == status);</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookAfter(consumeMessageContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.getConsumerStatsManager()</span><br><span class="line">                .incConsumeRT(ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, messageQueue.getTopic(), consumeRT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">                <span class="comment">//处理消费结果</span></span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">getMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> messageQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>  和Currently类似，不过首先对消息进行排序，首先将消息放入到processQueue的红黑树中，另外在消费时候先加锁，所粒度是MessageQueue，保证每个MessageQueue的顺序是一致的。如代码：</p><p>  由于consumer只能做到单messageQueue消息有序，我们在producer侧生产消息时候应该按照我们的保序字段selectQueue才行，保证相同id的都打到一个messageQueue中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ConsumeRequest只是面向processQueue和messageQueue的</span></span><br><span class="line">    <span class="comment">//这里设计的很不错，由于顺序消费针对MessageQueue所以单Queue的消费是线性的，为了提高吞吐，采用了ProcessQueue镜像队列，用红黑树的思想对消息offset排序然后压进队列，ConsumeRequest不停的消费ProcessQueue里弹出来的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumeRequest</span><span class="params">(ProcessQueue processQueue, MessageQueue messageQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.processQueue = processQueue;</span><br><span class="line">        <span class="keyword">this</span>.messageQueue = messageQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessQueue <span class="title">getProcessQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> processQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageQueue <span class="title">getMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关键代码锁机制，锁粒度是messageQueue，一个MessageQueue对应一个锁，也就是单一的messageQueue消费有序，需要发送时候选择messageQueue</span></span><br><span class="line">        <span class="keyword">final</span> Object objLock = messageQueueLock.fetchLockObject(<span class="keyword">this</span>.messageQueue);</span><br><span class="line">        <span class="keyword">synchronized</span> (objLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.messageModel())</span><br><span class="line">                || (<span class="keyword">this</span>.processQueue.isLocked() &amp;&amp; !<span class="keyword">this</span>.processQueue.isLockExpired())) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//todo 大哥你用个while不行么！！！一直从processQueue中弹出来BatchSize个消息，进行消费知道空为止</span></span><br><span class="line">                <span class="comment">//因为，不同的pullMessage会不停的给processQueue中压值知道满足阈值为止。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>; continueConsume; ) &#123;</span><br><span class="line">                    <span class="comment">//....省略校验逻辑</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize =</span><br><span class="line">                        ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//从processQueue的红黑树按照顺序take出consumeBatchSize个消息</span></span><br><span class="line">                    List&lt;MessageExt&gt; msgs = <span class="keyword">this</span>.processQueue.takeMessags(consumeBatchSize);</span><br><span class="line">                    <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">final</span> ConsumeOrderlyContext context = <span class="keyword">new</span> ConsumeOrderlyContext(<span class="keyword">this</span>.messageQueue);</span><br><span class="line"></span><br><span class="line">                        ConsumeOrderlyStatus status = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                        ConsumeMessageContext consumeMessageContext = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.hasHook()) &#123;</span><br><span class="line">                            consumeMessageContext = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">                            consumeMessageContext</span><br><span class="line">                                .setConsumerGroup(ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                            consumeMessageContext.setMq(messageQueue);</span><br><span class="line">                            consumeMessageContext.setMsgList(msgs);</span><br><span class="line">                            consumeMessageContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">// init the consume context type</span></span><br><span class="line">                            consumeMessageContext.setProps(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br><span class="line">                            ConsumeMessageOrderlyService.<span class="keyword">this</span>.defaultMQPushConsumerImpl.executeHookBefore(consumeMessageContext);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">                        ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">                        <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//保证线程安全，保证每个消息消费的线程安全</span></span><br><span class="line">                            <span class="keyword">this</span>.processQueue.getLockConsume().lock();</span><br><span class="line">                            <span class="comment">//.....</span></span><br><span class="line">                            <span class="comment">//消费逻辑</span></span><br><span class="line">                            status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                            <span class="comment">//......</span></span><br><span class="line">                            hasException = <span class="keyword">true</span>;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="comment">//解锁</span></span><br><span class="line">                            <span class="keyword">this</span>.processQueue.getLockConsume().unlock();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 处理消费结果</span></span><br><span class="line">                        continueConsume = ConsumeMessageOrderlyService.<span class="keyword">this</span>.processConsumeResult(msgs, status, context, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ......</span></span><br><span class="line">                ConsumeMessageOrderlyService.<span class="keyword">this</span>.tryLockLaterAndReconsume(<span class="keyword">this</span>.messageQueue, <span class="keyword">this</span>.processQueue, <span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  由于顺序消费为每个MessageQueue要加锁，为了创建大量的无用线程，在processQueue#putMessage方法会判断consuming的状态，如果当前processQueue已经在消费中了，消息只是放入红黑树但是不会启动线程去消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Messages放到红黑树中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msgs message信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果msgTreeMap不为空，且当前不在消费返回true，为true启动线程开始消费,如果消费中就不在启动线程了防止高并发情况下大量的异步线程将线程池打满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> dispatchToConsume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//锁因为msgTreeMap不是线程安全的</span></span><br><span class="line">        <span class="keyword">this</span>.lockTreeMap.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> validMsgCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                MessageExt old = msgTreeMap.put(msg.getQueueOffset(), msg);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">                    validMsgCnt++;</span><br><span class="line">                    <span class="keyword">this</span>.queueOffsetMax = msg.getQueueOffset();</span><br><span class="line">                    msgSize.addAndGet(msg.getBody().length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msgCount.addAndGet(validMsgCnt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//message不为空，并且当前没有consuming.</span></span><br><span class="line">            <span class="comment">// 因为顺序消费是启动一个线程一直processQueue中弹Message到processQueue为空</span></span><br><span class="line">            <span class="comment">// 所以当前红黑树不为空，并且不在消费中返回true，起线程开始消费,如果消费中就不在启动线程了防止高并发情况下大量的异步线程将线程池打满</span></span><br><span class="line">            <span class="keyword">if</span> (!msgTreeMap.isEmpty() &amp;&amp; !<span class="keyword">this</span>.consuming) &#123;</span><br><span class="line">                dispatchToConsume = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">this</span>.consuming = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!msgs.isEmpty()) &#123;</span><br><span class="line">                MessageExt messageExt = msgs.get(msgs.size() - <span class="number">1</span>);</span><br><span class="line">                String property = messageExt.getProperty(MessageConst.PROPERTY_MAX_OFFSET);</span><br><span class="line">                <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> accTotal = Long.parseLong(property) - messageExt.getQueueOffset();</span><br><span class="line">                    <span class="keyword">if</span> (accTotal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.msgAccCnt = accTotal;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lockTreeMap.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">"putMessage exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatchToConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理消费请求"><a href="#处理消费请求" class="headerlink" title="处理消费请求"></a>处理消费请求</h2><p>ConsumeMessageConcurrentlyService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeConcurrentlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeConcurrentlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">            <span class="comment">//ackIndex取consumeRequest.getMsgs()最后的一个元素小表</span></span><br><span class="line">            <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;<span class="comment">//size</span></span><br><span class="line">            <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;<span class="comment">//0</span></span><br><span class="line">            <span class="comment">//统计</span></span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">            ackIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">        <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">            <span class="comment">//遍历message列表，发送RequestCode.CONSUMER_SEND_MSG_BACK请求给broker，如果有异常，加入到msgBackFailed</span></span><br><span class="line">            List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                    msgBackFailed.add(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//消费请求中去掉发送CONSUMER_SEND_MSG_BACK的消息，然后对这些发送msgBack失败的消息在消费一遍。</span></span><br><span class="line">            <span class="comment">//这里就是为什么我们程序要做幂等行的判断</span></span><br><span class="line">            <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新内存中的offset</span></span><br><span class="line">    <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orderly和上述类似不过有一个提交过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processConsumeResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyStatus status,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeOrderlyContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ConsumeRequest consumeRequest</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> continueConsume = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">long</span> commitOffset = -<span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">if</span> (context.isAutoCommit()) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                log.warn(<span class="string">"the message queue consume result is illegal, we think you want to ack these message &#123;&#125;"</span>,</span><br><span class="line">                    consumeRequest.getMessageQueue());</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="comment">//提交</span></span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> COMMIT:</span><br><span class="line">                commitOffset = consumeRequest.getProcessQueue().commit();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ROLLBACK:</span><br><span class="line">                consumeRequest.getProcessQueue().rollback();</span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                    consumeRequest.getProcessQueue(),</span><br><span class="line">                    consumeRequest.getMessageQueue(),</span><br><span class="line">                    context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SUSPEND_CURRENT_QUEUE_A_MOMENT:</span><br><span class="line">                <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());</span><br><span class="line">                <span class="keyword">if</span> (checkReconsumeTimes(msgs)) &#123;</span><br><span class="line">                    consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);</span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(</span><br><span class="line">                        consumeRequest.getProcessQueue(),</span><br><span class="line">                        consumeRequest.getMessageQueue(),</span><br><span class="line">                        context.getSuspendCurrentQueueTimeMillis());</span><br><span class="line">                    continueConsume = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (commitOffset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> continueConsume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-源码学习-四-消息的发送</title>
      <link href="RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81/"/>
      <url>RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="消息的生产者类的结构"><a href="#消息的生产者类的结构" class="headerlink" title="消息的生产者类的结构"></a>消息的生产者类的结构</h2><p>DefaultMQProducer（TransactionMQProducer后续事务的消费会提到，下面以DefaultMQProducer开始）,继承了ClientConfig，实现了接口：MQProducer。</p><p>DefaultMQProducer持有DefaultMQProducerImpl对象，DefaultMQProducerImpl实现MQProducerInner接口，</p><h2 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h2><p>DefaultMQProducer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">    defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultMQProducerImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducerImpl</span><span class="params">(<span class="keyword">final</span> DefaultMQProducer defaultMQProducer, RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultMQProducer = defaultMQProducer;</span><br><span class="line">    <span class="keyword">this</span>.rpcHook = rpcHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>DefaultMQProducer#start(),具体见下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> startFactory)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">        <span class="comment">//启动时候默认是是这个状态防止重复启动</span></span><br><span class="line">        <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//检查producerGroup名称合法性</span></span><br><span class="line">            <span class="keyword">this</span>.checkConfig();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否需要设置 InstanceName （不等于CLIENT_INNER_PRODUCER_GROUP，并且InstanceName是default）</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.changeInstanceNameToPID();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//多例模式创建MQClientInstance</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQProducer, rpcHook);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册Producer</span></span><br><span class="line">            <span class="keyword">boolean</span> registerOK = mQClientFactory.registerProducer(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer group["</span> + <span class="keyword">this</span>.defaultMQProducer.getProducerGroup()</span><br><span class="line">                    + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//topic:"TBW102"---&gt;new TopicPublishInfo() 存入topicPublishInfoTable</span></span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.put(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey(), <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动</span></span><br><span class="line">            <span class="keyword">if</span> (startFactory) &#123;</span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"the producer [&#123;&#125;] start OK. sendMessageWithVIPChannel=&#123;&#125;"</span>, <span class="keyword">this</span>.defaultMQProducer.getProducerGroup(),</span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel());</span><br><span class="line">            <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RUNNING:</span><br><span class="line">        <span class="keyword">case</span> START_FAILED:</span><br><span class="line">        <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The producer service state not OK, maybe started once, "</span></span><br><span class="line">                + <span class="keyword">this</span>.serviceState</span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用MQClientInstance#start()，见下面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.serviceState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                <span class="comment">// If not specified,looking address from name server</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                    <span class="comment">//感觉是服务发现</span></span><br><span class="line">                    <span class="keyword">this</span>.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Start request-response channel 处理rocktmq的coumser相关的系统事件和CONSUME_MESSAGE_DIRECTLY等信息</span></span><br><span class="line">                <span class="keyword">this</span>.mQClientAPIImpl.start();</span><br><span class="line">                <span class="comment">// Start various schedule tasks 服务发现的任务保证服务的发现</span></span><br><span class="line">                <span class="keyword">this</span>.startScheduledTask();</span><br><span class="line">                <span class="comment">// Start pull service  启动pullMessageService通过queue拉取线程</span></span><br><span class="line">                <span class="keyword">this</span>.pullMessageService.start();</span><br><span class="line">                <span class="comment">// Start rebalance service 每隔一段时间执行一次doReblance方法</span></span><br><span class="line">                <span class="keyword">this</span>.rebalanceService.start();</span><br><span class="line">                <span class="comment">// Start push service 启动push服务</span></span><br><span class="line">                <span class="keyword">this</span>.defaultMQProducer.getDefaultMQProducerImpl().start(<span class="keyword">false</span>);</span><br><span class="line">                log.info(<span class="string">"the client factory [&#123;&#125;] start OK"</span>, <span class="keyword">this</span>.clientId);</span><br><span class="line">                <span class="keyword">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The Factory object["</span> + <span class="keyword">this</span>.getClientId() + <span class="string">"] has been created before, and failed."</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此Procuer启动完成</p><h2 id="消息发送的过程"><a href="#消息发送的过程" class="headerlink" title="消息发送的过程"></a>消息发送的过程</h2><ol><li>DefaultMQProducer#send–&gt;DefaultMQProducerImpl#send–&gt;DefaultMQProducerImpl#sendOneway、sendDefaultImpl、sendKernelImpl–&gt;MQClientAPIImpl#sendMessage–&gt;nettyRemotingClient#invokeSync、invokeAsync、invokeOneWay</li><li>sendOneway-&gt;sendDefaultImpl-&gt;sendKernelImpl</li></ol><p>重点的类有</p><ul><li>DefaultMQProducerImpl-生产者的实现</li><li>MQClientAPIImpl-MqClientApi的实现，包含生产者和消费者部分</li><li>nettyRemotingClient</li></ul><h3 id="DefaultMQProducerImpl"><a href="#DefaultMQProducerImpl" class="headerlink" title="DefaultMQProducerImpl"></a>DefaultMQProducerImpl</h3><h4 id="重点方法获取topicPublishInfo–tryToFindTopicPublishInfo"><a href="#重点方法获取topicPublishInfo–tryToFindTopicPublishInfo" class="headerlink" title="重点方法获取topicPublishInfo–tryToFindTopicPublishInfo"></a>重点方法获取topicPublishInfo–tryToFindTopicPublishInfo</h4><p>根据message中的topic属性获取本地TopicPublishInfo，如果本地没用去nameServer获取，发送RequestCode为GET_ROUTEINTO_BY_TOPIC的请求获取topicRouteData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">        TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="comment">//没有或者messageQueueList为空去nameserv获取</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">            <span class="comment">//重点</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">            topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">            <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">            topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">            <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mQClientFactory#updateTopicRouteInfoFromNameServer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateTopicRouteInfoFromNameServer</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">boolean</span> isDefault,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      DefaultMQProducer defaultMQProducer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取路由信息</span></span><br><span class="line">                    TopicRouteData topicRouteData;</span><br><span class="line">                    <span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//发送RequestCode为GET_ROUTEINTO_BY_TOPIC的请求获取topicRouteData</span></span><br><span class="line">                        topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">                                <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line">                        <span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line">                        ......</span><br><span class="line">                        <span class="comment">//如果发生改变将TopicRouteData转成TopicPublishInfo 和 subscribeInfo 更新</span></span><br><span class="line">                        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                            TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line">                            <span class="comment">// Update Pub info</span></span><br><span class="line">                            &#123;</span><br><span class="line">                                TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">                                publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">                                Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">                                <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                                    Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">                                    MQProducerInner impl = entry.getValue();</span><br><span class="line">                                    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                        impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            ......</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.lockNamesrv.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="sendKernelImpl"><a href="#sendKernelImpl" class="headerlink" title="sendKernelImpl"></a>sendKernelImpl</h4><p>他们的封装关系：<br>sendOneway-&gt;sendDefaultImpl-&gt;sendKernelImpl，这3种方式最终都会调用到sendKernelImpl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mq                write-message-queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> communicationMode async sync oneway</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sendCallback</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topicPublishInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MQClientException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MQBrokerException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//得到BrokerAddr，没有在更新topic</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SendMessageContext context = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (brokerAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据配置返回VipChannel</span></span><br><span class="line">        brokerAddr = MixAll.brokerVIPChannel(<span class="keyword">this</span>.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line">        <span class="keyword">byte</span>[] prevBody = msg.getBody();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line">            <span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">                MessageClientIDSetter.setUniqID(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//压缩单体的消息messagebody</span></span><br><span class="line">            <span class="keyword">int</span> sysFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> msgBodyCompressed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                msgBodyCompressed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//是否事务消息</span></span><br><span class="line">            <span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">            <span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行CheckForbiddenHook</span></span><br><span class="line">            <span class="keyword">if</span> (hasCheckForbiddenHook()) &#123;</span><br><span class="line">                CheckForbiddenContext checkForbiddenContext = <span class="keyword">new</span> CheckForbiddenContext();</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">this</span>.executeCheckForbiddenHook(checkForbiddenContext);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行SendMessageHookBefore</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构建requestHeader</span></span><br><span class="line">            SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">            requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">            requestHeader.setTopic(msg.getTopic());</span><br><span class="line">            requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">            requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">            requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">            requestHeader.setSysFlag(sysFlag);</span><br><span class="line">            requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">            requestHeader.setFlag(msg.getFlag());</span><br><span class="line">            requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">            requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">            requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">            <span class="comment">//如果是重复消费的次数</span></span><br><span class="line">            <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                &#125;</span><br><span class="line">                String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                    MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> ASYNC:</span><br><span class="line">                    Message tmpMessage = msg;</span><br><span class="line">                    <span class="comment">//如果消息被压缩过，msgbody为原来的消息</span></span><br><span class="line">                    <span class="comment">// 否则如果这个消息是发送失败的，并且消息体依然大于压缩阈值，被压缩了俩次。</span></span><br><span class="line">                    <span class="comment">// 所以tmpMessage从msgclone了新对象，原Message不变，如果失败了可以通过原message进行重发</span></span><br><span class="line">                    <span class="keyword">if</span> (msgBodyCompressed) &#123;</span><br><span class="line">                        <span class="comment">//If msg body was compressed, msgbody should be reset using prevBody.</span></span><br><span class="line">                        <span class="comment">//Clone new message using commpressed message body and recover origin massage.</span></span><br><span class="line">                        <span class="comment">//Fix bug:https://github.com/apache/rocketmq-externals/issues/66</span></span><br><span class="line">                        tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                        <span class="comment">//todo FIXME?? 这一步是否有必要要，因为有finnaly</span></span><br><span class="line">                        msg.setBody(prevBody);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ......</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                            brokerAddr,</span><br><span class="line">                            mq.getBrokerName(),</span><br><span class="line">                            tmpMessage,</span><br><span class="line">                            requestHeader,</span><br><span class="line">                            timeout - costTimeAsync,</span><br><span class="line">                            communicationMode,</span><br><span class="line">                            sendCallback,</span><br><span class="line">                            topicPublishInfo,</span><br><span class="line">                            <span class="keyword">this</span>.mQClientFactory,</span><br><span class="line">                            <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(),</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">case</span> SYNC:</span><br><span class="line">                    <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendKernelImpl call timeout"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(</span><br><span class="line">                            brokerAddr,</span><br><span class="line">                            mq.getBrokerName(),</span><br><span class="line">                            msg,</span><br><span class="line">                            requestHeader,</span><br><span class="line">                            timeout - costTimeSync,</span><br><span class="line">                            communicationMode,</span><br><span class="line">                            context,</span><br><span class="line">                            <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//执行hook</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context.setSendResult(sendResult);</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookAfter(context);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sendResult;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//因为msg.body已经被压缩过了，所以需要重置body</span></span><br><span class="line">            msg.setBody(prevBody);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The broker["</span> + mq.getBrokerName() + <span class="string">"] not exist"</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发送消息-MQClientAPIImpl-sendMessage"><a href="#发送消息-MQClientAPIImpl-sendMessage" class="headerlink" title="发送消息-MQClientAPIImpl#sendMessage"></a>发送消息-MQClientAPIImpl#sendMessage</h3><p>MQClientAPIImpl是rocketmq作为client的api实现，这里看发送消息即：sendMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息给Broker,Broker接收后对消息进行存储 RequestCode是SEND_MESSAGE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr                     broker地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brokerName               broker名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg                      消息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestHeader            消息Header头</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeoutMillis            过期时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> communicationMode        发送类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sendCallback             callback记过</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topicPublishInfo         publishinfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> instance                 clientInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> retryTimesWhenSendFailed 失败重试次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context                  上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> producer                 producer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MQBrokerException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SendResult <span class="title">sendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SendMessageRequestHeader requestHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MQClientInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> retryTimesWhenSendFailed,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SendMessageContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> DefaultMQProducerImpl producer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.RequestCommand,RequestCode是SEND_MESSAGE，接收者是</span></span><br><span class="line">    RemotingCommand request = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (sendSmartMsg || msg <span class="keyword">instanceof</span> MessageBatch) &#123;</span><br><span class="line">        SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);</span><br><span class="line">        request = RemotingCommand.createRequestCommand(msg <span class="keyword">instanceof</span> MessageBatch ? RequestCode.SEND_BATCH_MESSAGE : RequestCode.SEND_MESSAGE_V2, requestHeaderV2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set body</span></span><br><span class="line">    request.setBody(msg.getBody());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> ONEWAY:</span><br><span class="line">            <span class="comment">//单向发送：用nettyRemotingClient的invokeOneway，无返回值</span></span><br><span class="line">            <span class="keyword">this</span>.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">//异步发送</span></span><br><span class="line">            <span class="keyword">final</span> AtomicInteger times = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">            <span class="keyword">long</span> costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; costTimeAsync) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendMessage call timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.sendMessageAsync(addr, brokerName, msg, timeoutMillis - costTimeAsync, request, sendCallback, topicPublishInfo, instance,</span><br><span class="line">                    retryTimesWhenSendFailed, times, context, producer);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">case</span> SYNC:</span><br><span class="line">            <span class="keyword">long</span> costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; costTimeSync) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendMessage call timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.sendMessageSync(addr, brokerName, msg, timeoutMillis - costTimeSync, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="MessageQueueSelector自定义队列选择器实现消息黏着等功能"><a href="#MessageQueueSelector自定义队列选择器实现消息黏着等功能" class="headerlink" title="MessageQueueSelector自定义队列选择器实现消息黏着等功能"></a>MessageQueueSelector自定义队列选择器实现消息黏着等功能</h2><p>在上述的三种send方式，默认是RoundRobin，但是我们也可以通过传入MessageQueueSelector接口的实现队列的选择器将一定规则的队列发送到同一个队列中</p><p>MessageQueueSelector 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageQueueSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列选择接口，在sendSelectImpl中调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqs topicPublishInfo中的MessageQueues列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg 队列选择器的参数，我们可以依据它来选择队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">MessageQueue <span class="title">select</span><span class="params">(<span class="keyword">final</span> List&lt;MessageQueue&gt; mqs, <span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultMQProducerImpl#sendSelectImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendSelectImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">            MessageQueueSelector selector,</span></span></span><br><span class="line"><span class="function"><span class="params">            Object arg,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> SendCallback sendCallback, <span class="keyword">final</span> <span class="keyword">long</span> timeout</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.makeSureStateOK();</span><br><span class="line">        Validators.checkMessage(msg, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取topicPublishInfo</span></span><br><span class="line">        TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        <span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//用自定义的selector，从getMessageQueueList选择一个队列</span></span><br><span class="line">                mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue throwed exception."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeout &lt; costTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"sendSelectImpl call timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, <span class="keyword">null</span>, timeout - costTime);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"select message queue return null."</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"No route info for this topic, "</span> + msg.getTopic(), <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以参照代码中的几个示例：SelectMessageQueueByRandom，SelectMessageQueueByMachineRoom，SelectMessageQueueByHash</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-源码学习-三-Store模块消息的存储(**持久化消息队列的重点**)</title>
      <link href="RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%89-Store%E6%A8%A1%E5%9D%97%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8/"/>
      <url>RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%89-Store%E6%A8%A1%E5%9D%97%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>broker的一个重点就是消息的持久化，它决定这MQ的使用场景、性能、以及可用性</p></blockquote><h2 id="存储消息的调用时序"><a href="#存储消息的调用时序" class="headerlink" title="存储消息的调用时序"></a>存储消息的调用时序</h2><p>  nettyRemotingServer接到请求–&gt;SendMessageProcessor.processRequest–&gt;DefaultMessageStore.putMessage–&gt;CommitLog.putMessage–&gt;MappedFile.appendMessage–&gt;CommitLog.DefaultAppendMessageCallback.doAppend<br>  最终调用MappedFile的–&gt;MappedByteBuffer来写入文件</p><h2 id="SendMessageProcessor"><a href="#SendMessageProcessor" class="headerlink" title="SendMessageProcessor"></a>SendMessageProcessor</h2><p>  上一节提到的broker在启动过程。其中registerProcessor()方法中第一个就初始化了SendMessageProcessor。<br>  SendMessageProcessor采用模板模式，实现了抽象类AbstractSendMessageProcessor，并且实现了NettyRequestProcessor，它是netty的事件的处理类。</p><h2 id="NettyRequestProcessor-processRequest"><a href="#NettyRequestProcessor-processRequest" class="headerlink" title="NettyRequestProcessor-processRequest"></a>NettyRequestProcessor-processRequest</h2><p>实现了NettyRequestProcessor接口的processRequest发方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.consumerSendMsgBack(ctx, request);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            <span class="keyword">if</span> (requestHeader == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            <span class="keyword">if</span> (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                response = <span class="keyword">this</span>.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h2><ul><li>commitLog的文件管理</li><li>消息的存储</li></ul><h3 id="putMessage"><a href="#putMessage" class="headerlink" title="putMessage"></a>putMessage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取消息的事物类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//延时消息</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">            <span class="comment">// Backup real topic, queueId 将消息设置成topic</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"></span><br><span class="line">    putMessageLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取mappedFile 如果mappedFile或者为空，createAndGet</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            <span class="comment">//getOrCreate</span></span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">// Create a new file, re-write the message</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eclipseTimeInLock &gt; <span class="number">500</span>) &#123;</span><br><span class="line">        log.warn(<span class="string">"[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;"</span>, eclipseTimeInLock, msg.getBody().length, result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Statistics</span></span><br><span class="line">    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).incrementAndGet();</span><br><span class="line">    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).addAndGet(result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitLog文件管理"><a href="#commitLog文件管理" class="headerlink" title="commitLog文件管理"></a>commitLog文件管理</h3><p>获取最后一个mappeedFile，如果没有创建一个</p><h4 id="AllocateMappedFileService–一次创建俩个文件"><a href="#AllocateMappedFileService–一次创建俩个文件" class="headerlink" title="AllocateMappedFileService–一次创建俩个文件"></a>AllocateMappedFileService–一次创建俩个文件</h4><p>由DefaultMessageSotre中初始化，传递个MappedFileQueue，类继承了ServiceThread。创建文件采用生产者消费者模式，一次创建俩个文件，当前文件直接返回。后续文件异步创建，提升了性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者模式。同步的放文件到队列中，线程中异步的去创建文件，</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextFilePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nextNextFilePath</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileSize</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath, String nextNextFilePath, <span class="keyword">int</span> fileSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//nextFile的异步请求</span></span><br><span class="line">    AllocateRequest nextReq = <span class="keyword">new</span> AllocateRequest(nextFilePath, fileSize);</span><br><span class="line">    <span class="keyword">boolean</span> nextPutOK = <span class="keyword">this</span>.requestTable.putIfAbsent(nextFilePath, nextReq) == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextPutOK) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//丢到队列中</span></span><br><span class="line">        <span class="keyword">boolean</span> offerOK = <span class="keyword">this</span>.requestQueue.offer(nextReq);</span><br><span class="line">        <span class="keyword">if</span> (!offerOK) &#123;</span><br><span class="line">            log.warn(<span class="string">"never expected here, add a request to preallocate queue failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nextNextFile的异步请求</span></span><br><span class="line">    AllocateRequest nextNextReq = <span class="keyword">new</span> AllocateRequest(nextNextFilePath, fileSize);</span><br><span class="line">    <span class="keyword">boolean</span> nextNextPutOK = <span class="keyword">this</span>.requestTable.putIfAbsent(nextNextFilePath, nextNextReq) == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextNextPutOK) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> offerOK = <span class="keyword">this</span>.requestQueue.offer(nextNextReq);</span><br><span class="line">            <span class="keyword">if</span> (!offerOK) &#123;</span><br><span class="line">                log.warn(<span class="string">"never expected here, add a request to preallocate queue failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一次创建俩个文件nextFile和nextNextFile，nextFile异步转同步返回，nextNextFile下一次创建时候可以直接到这里，</span></span><br><span class="line">    AllocateRequest result = <span class="keyword">this</span>.requestTable.get(nextFilePath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> waitOK = result.getCountDownLatch().await(waitTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!waitOK) &#123;</span><br><span class="line">                log.warn(<span class="string">"create mmap timeout "</span> + result.getFilePath() + <span class="string">" "</span> + result.getFileSize());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.requestTable.remove(nextFilePath);</span><br><span class="line">                <span class="keyword">return</span> result.getMappedFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(<span class="string">"find preallocate mmap failed, this never happen"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run方法中的关键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">    <span class="comment">//关键方法</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped() &amp;&amp; <span class="keyword">this</span>.mmapOperation()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">mmapOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    AllocateRequest req = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取请求</span></span><br><span class="line">        req = <span class="keyword">this</span>.requestQueue.take();</span><br><span class="line">        <span class="comment">//校验请求状态</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.getMappedFile() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//俩种方式TransientStorePool和MappedFileByteBuffer</span></span><br><span class="line">            <span class="keyword">if</span> (messageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mappedFile = ServiceLoader.load(MappedFile.class).iterator().next();</span><br><span class="line">                    mappedFile.init(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    log.warn(<span class="string">"Use default implementation."</span>);</span><br><span class="line">                    mappedFile = <span class="keyword">new</span> MappedFile(req.getFilePath(), req.getFileSize(), messageStore.getTransientStorePool());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mappedFile = <span class="keyword">new</span> MappedFile(req.getFilePath(), req.getFileSize());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// pre write mappedFile</span></span><br><span class="line">            ......</span><br><span class="line">            req.setMappedFile(mappedFile);</span><br><span class="line">            <span class="keyword">this</span>.hasException = <span class="keyword">false</span>;</span><br><span class="line">            isSuccess = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//被中断返回false</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (req != <span class="keyword">null</span> &amp;&amp; isSuccess)</span><br><span class="line">            req.getCountDownLatch().countDown();</span><br><span class="line">        <span class="comment">//完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MappedFile"><a href="#MappedFile" class="headerlink" title="MappedFile"></a>MappedFile</h4><p>底层采用javanio的RandomAccessFile和mappedByteBuffer，见init方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> String fileName, <span class="keyword">final</span> <span class="keyword">int</span> fileSize)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    <span class="keyword">this</span>.fileSize = fileSize;</span><br><span class="line">    <span class="keyword">this</span>.file = <span class="keyword">new</span> File(fileName);</span><br><span class="line">    <span class="keyword">this</span>.fileFromOffset = Long.parseLong(<span class="keyword">this</span>.file.getName());</span><br><span class="line">    <span class="keyword">boolean</span> ok = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ensureDirOK(<span class="keyword">this</span>.file.getParent());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileChannel = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.file, <span class="string">"rw"</span>).getChannel();</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer = <span class="keyword">this</span>.fileChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, fileSize);</span><br><span class="line">        TOTAL_MAPPED_VIRTUAL_MEMORY.addAndGet(fileSize);</span><br><span class="line">        TOTAL_MAPPED_FILES.incrementAndGet();</span><br><span class="line">        ok = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        log.error(<span class="string">"create file channel "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">"map file "</span> + <span class="keyword">this</span>.fileName + <span class="string">" Failed. "</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ok &amp;&amp; <span class="keyword">this</span>.fileChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fileChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息的存储"><a href="#消息的存储" class="headerlink" title="消息的存储"></a>消息的存储</h3><p>CommitLog#putMessage–&gt;mapFile#appendMessagesInner–&gt;CommitLog.DefaultAppendMessageCallback#doAppend</p><h4 id="MappedFileQueue"><a href="#MappedFileQueue" class="headerlink" title="MappedFileQueue"></a>MappedFileQueue</h4><p>putMessage方法存消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ...校验消息以及设置消息里面的属性...</span><br><span class="line">    <span class="comment">//获取消息的事物类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE</span><br><span class="line">            || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// Delay Delivery</span></span><br><span class="line">        <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) &#123;</span><br><span class="line">                msg.setDelayTimeLevel(<span class="keyword">this</span>.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//延时消息</span></span><br><span class="line">            topic = ScheduleMessageService.SCHEDULE_TOPIC;</span><br><span class="line">            queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Backup real topic, queueId 将消息设置成topic</span></span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());</span><br><span class="line">            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));</span><br><span class="line">            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line"></span><br><span class="line">            msg.setTopic(topic);</span><br><span class="line">            msg.setQueueId(queueId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//获取mappedFile 如果mappedFile或者为空，createAndGet</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">            mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>); <span class="comment">// Mark: NewFile may be cause noise</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//mappedFile的put</span></span><br><span class="line">        result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">        <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PUT_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> END_OF_FILE:</span><br><span class="line">                <span class="comment">//文件不够发送该消息，创建个新文件，并且重发</span></span><br><span class="line">                unlockMappedFile = mappedFile;</span><br><span class="line">                <span class="comment">//因为上一条消息woritePosition改变，已经满了，所以会已新的哦createPosition创建文件</span></span><br><span class="line">                mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">XXX:</span> warn and notify me</span></span><br><span class="line">                    log.error(<span class="string">"create mapped file2 error, topic: "</span> + msg.getTopic() + <span class="string">" clientAddr: "</span> + msg.getBornHostString());</span><br><span class="line">                    beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result);</span><br><span class="line">                &#125;</span><br><span class="line">                result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MESSAGE_SIZE_EXCEEDED:</span><br><span class="line">            <span class="keyword">case</span> PROPERTIES_SIZE_EXCEEDED:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result);</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN_ERROR:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">        beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != unlockMappedFile &amp;&amp; <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.unlockMappedFile(unlockMappedFile);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    PutMessageResult putMessageResult = <span class="keyword">new</span> PutMessageResult(PutMessageStatus.PUT_OK, result);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mappedFile-appendMessage"><a href="#mappedFile-appendMessage" class="headerlink" title="mappedFile#appendMessage"></a>mappedFile#appendMessage</h4><p>appendMessage–&gt;appendMessagesInner哎方法中调用AppendMessageCallback.doAppend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> messageExt != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">assert</span> cb != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写的position，如果还有空余</span></span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line">    <span class="keyword">if</span> (currentPos &lt; <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        <span class="comment">//缓冲区切片，获取子缓冲区，position=0，起始位置是主缓冲区的position，容量是limit-position看，这里是指写缓冲区中，剩下的缓冲区。</span></span><br><span class="line">        ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        <span class="comment">//设置当前消息写的position</span></span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        AppendMessageResult result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBrokerInner) &#123;</span><br><span class="line">            <span class="comment">//文件开始位置，写的bytebuffer，剩余位置，消息体</span></span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBrokerInner) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (messageExt <span class="keyword">instanceof</span> MessageExtBatch) &#123;</span><br><span class="line">            result = cb.doAppend(<span class="keyword">this</span>.getFileFromOffset(), byteBuffer, <span class="keyword">this</span>.fileSize - currentPos, (MessageExtBatch) messageExt);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(result.getWroteBytes());</span><br><span class="line">        <span class="keyword">this</span>.storeTimestamp = result.getStoreTimestamp();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cb-doAppend"><a href="#cb-doAppend" class="headerlink" title="cb#doAppend"></a>cb#doAppend</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fileFromOffset 文件其实的自己数1G的整数倍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> byteBuffer mappedByteBuffer的子缓冲区</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> maxBlank 空余byteslength</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msgInner 消息体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> MessageExtBrokerInner msgInner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PHY OFFSET =文件起始的位置+当前写的位置</span></span><br><span class="line">    <span class="keyword">long</span> wroteOffset = fileFromOffset + byteBuffer.position();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算msgId</span></span><br><span class="line">    <span class="comment">//msgIdMemory+16位 MSG_ID_LENGTH=8+8具体见下面</span></span><br><span class="line">    <span class="comment">//msgInner.getStoreHostBytes(hostHolder)总共8位=Addr数组+port</span></span><br><span class="line">    <span class="comment">//wroteOffset long类型占8位</span></span><br><span class="line">    <span class="keyword">this</span>.resetByteBuffer(hostHolder, <span class="number">8</span>);</span><br><span class="line">    String msgId = MessageDecoder.createMessageId(<span class="keyword">this</span>.msgIdMemory, msgInner.getStoreHostBytes(hostHolder), wroteOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record ConsumeQueue information</span></span><br><span class="line">    keyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getTopic());</span><br><span class="line">    keyBuilder.append(<span class="string">'-'</span>);</span><br><span class="line">    keyBuilder.append(msgInner.getQueueId());</span><br><span class="line">    String key = keyBuilder.toString(); <span class="comment">// topic-queueid</span></span><br><span class="line">    <span class="comment">//get queue current offset</span></span><br><span class="line">    Long queueOffset = CommitLog.<span class="keyword">this</span>.topicQueueTable.get(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == queueOffset) &#123;</span><br><span class="line">        queueOffset = <span class="number">0L</span>;</span><br><span class="line">        CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, queueOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transaction messages that require special handling 处理事物消息待看</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msgInner.getSysFlag());</span><br><span class="line">    <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">        <span class="comment">// Prepared and Rollback message is not consumed, will not enter the</span></span><br><span class="line">        <span class="comment">// consumer queuec</span></span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">            queueOffset = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取properties</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] propertiesData =</span><br><span class="line">            msgInner.getPropertiesString() == <span class="keyword">null</span> ? <span class="keyword">null</span> : msgInner.getPropertiesString().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> propertiesLength = propertiesData == <span class="keyword">null</span> ? <span class="number">0</span> : propertiesData.length;</span><br><span class="line">    <span class="keyword">if</span> (propertiesLength &gt; Short.MAX_VALUE) &#123;</span><br><span class="line">        log.warn(<span class="string">"putMessage message properties length too long. length=&#123;&#125;"</span>, propertiesData.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PROPERTIES_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取topic信息</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] topicData = msgInner.getTopic().getBytes(MessageDecoder.CHARSET_UTF8);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> topicLength = topicData.length;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bodyLength = msgInner.getBody() == <span class="keyword">null</span> ? <span class="number">0</span> : msgInner.getBody().length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算消息的长度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> msgLen = calMsgLength(bodyLength, topicLength, propertiesLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Exceeds the maximum message 默认是512k</span></span><br><span class="line">    <span class="keyword">if</span> (msgLen &gt; <span class="keyword">this</span>.maxMessageSize) &#123;</span><br><span class="line">        CommitLog.log.warn(<span class="string">"message size exceeded, msg total size: "</span> + msgLen + <span class="string">", msg body size: "</span> + bodyLength</span><br><span class="line">                + <span class="string">", maxMessageSize: "</span> + <span class="keyword">this</span>.maxMessageSize);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.MESSAGE_SIZE_EXCEEDED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determines whether there is sufficient free space 文件内容不足以写消息返回END_OF_FILE类型的result</span></span><br><span class="line">    <span class="keyword">if</span> ((msgLen + END_FILE_MIN_BLANK_LENGTH) &gt; maxBlank) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resetByteBuffer(<span class="keyword">this</span>.msgStoreItemMemory, maxBlank);</span><br><span class="line">        <span class="comment">// 1 TOTALSIZE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(maxBlank);</span><br><span class="line">        <span class="comment">// 2 MAGICCODE</span></span><br><span class="line">        <span class="keyword">this</span>.msgStoreItemMemory.putInt(CommitLog.BLANK_MAGIC_CODE);</span><br><span class="line">        <span class="comment">// 3 The remaining space may be any value</span></span><br><span class="line">        <span class="comment">// Here the length of the specially set maxBlank</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">        byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, maxBlank);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.END_OF_FILE, wroteOffset, maxBlank, msgId, msgInner.getStoreTimestamp(),</span><br><span class="line">                queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialization of storage space 初始化读取空间先flip在设置limit,写消息</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> beginTimeMills = CommitLog.<span class="keyword">this</span>.defaultMessageStore.now();</span><br><span class="line">    <span class="comment">// Write messages to the queue buffer</span></span><br><span class="line">    byteBuffer.put(<span class="keyword">this</span>.msgStoreItemMemory.array(), <span class="number">0</span>, msgLen);</span><br><span class="line"></span><br><span class="line">    AppendMessageResult result = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, msgLen, msgId,</span><br><span class="line">            msgInner.getStoreTimestamp(), queueOffset, CommitLog.<span class="keyword">this</span>.defaultMessageStore.now() - beginTimeMills);</span><br><span class="line">    <span class="comment">//处理事务</span></span><br><span class="line">    <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">        <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">            <span class="comment">// The next update ConsumeQueue information</span></span><br><span class="line">            CommitLog.<span class="keyword">this</span>.topicQueueTable.put(key, ++queueOffset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息的存储–ConsumerQueue"><a href="#消息的存储–ConsumerQueue" class="headerlink" title="消息的存储–ConsumerQueue"></a>消息的存储–ConsumerQueue</h2><p>在DefaultMessageStore.load()和findOffset时候会创建ConsumerQueue。</p><h3 id="ConsumerQueue"><a href="#ConsumerQueue" class="headerlink" title="ConsumerQueue"></a>ConsumerQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建新的逻辑队列ConsumeQueue和ConsumeQueueExt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic               topic</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> queueId             queueId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> storePath           storePathRootDir/consumerqueue/topic/queueId</span></span><br><span class="line"><span class="comment"> *                            storePathRootDir/consumerqueu_ext/topic/queueId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mappedFileSize      大小是30W消息*每条20字节</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> defaultMessageStore</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConsumeQueue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String topic,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> queueId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String storePath,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.storePath = storePath;</span><br><span class="line">    <span class="keyword">this</span>.mappedFileSize = mappedFileSize;</span><br><span class="line">    <span class="keyword">this</span>.defaultMessageStore = defaultMessageStore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.topic = topic;</span><br><span class="line">    <span class="keyword">this</span>.queueId = queueId;</span><br><span class="line"></span><br><span class="line">    String queueDir = <span class="keyword">this</span>.storePath</span><br><span class="line">            + File.separator + topic</span><br><span class="line">            + File.separator + queueId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.mappedFileQueue = <span class="keyword">new</span> MappedFileQueue(queueDir, mappedFileSize, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex = ByteBuffer.allocate(CQ_STORE_UNIT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (defaultMessageStore.getMessageStoreConfig().isEnableConsumeQueueExt()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.consumeQueueExt = <span class="keyword">new</span> ConsumeQueueExt(</span><br><span class="line">                topic,</span><br><span class="line">                queueId,</span><br><span class="line">                StorePathConfigHelper.getStorePathConsumeQueueExt(defaultMessageStore.getMessageStoreConfig().getStorePathRootDir()),</span><br><span class="line">                defaultMessageStore.getMessageStoreConfig().getMappedFileSizeConsumeQueueExt(),</span><br><span class="line">                defaultMessageStore.getMessageStoreConfig().getBitMapLengthConsumeQueueExt()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-源码学习-二-Nameserv</title>
      <link href="RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%8C-Nameserv/"/>
      <url>RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%BA%8C-Nameserv/</url>
      
        <content type="html"><![CDATA[<p>nameserv是服务发现中心，底层采用netty监听</p><h2 id="NamesrvStartup"><a href="#NamesrvStartup" class="headerlink" title="NamesrvStartup"></a>NamesrvStartup</h2><p>服务的启动类，通过命令行参数初始化NamesrvController，并且启动NamesrvController。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title">createNamesrvController</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, JoranException </span>&#123;</span><br><span class="line">    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));</span><br><span class="line">    <span class="comment">//PackageConflictDetect.detectFastjson();</span></span><br><span class="line"></span><br><span class="line">    Options options = ServerUtil.buildCommandlineOptions(<span class="keyword">new</span> Options());</span><br><span class="line">    commandLine = ServerUtil.parseCmdLine(<span class="string">"mqnamesrv"</span>, args, buildCommandlineOptions(options), <span class="keyword">new</span> PosixParser());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == commandLine) &#123;</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化nameservconfig和netteyServerConfig</span></span><br><span class="line">    <span class="keyword">final</span> NamesrvConfig namesrvConfig = <span class="keyword">new</span> NamesrvConfig();</span><br><span class="line">    <span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键代码，创建NamesrvController</span></span><br><span class="line">    <span class="keyword">final</span> NamesrvController controller = <span class="keyword">new</span> NamesrvController(namesrvConfig, nettyServerConfig);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">    controller.getConfiguration().registerConfig(properties);</span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NamesrvController <span class="title">start</span><span class="params">(<span class="keyword">final</span> NamesrvController controller)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化配置</span></span><br><span class="line">    <span class="keyword">boolean</span> initResult = controller.initialize();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHookThread(log, <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            controller.shutdown();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键代码start</span></span><br><span class="line">    controller.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NamesrvController"><a href="#NamesrvController" class="headerlink" title="NamesrvController"></a>NamesrvController</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NamesrvController</span><span class="params">(NamesrvConfig namesrvConfig, NettyServerConfig nettyServerConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//nameserver的配置</span></span><br><span class="line">    <span class="keyword">this</span>.namesrvConfig = namesrvConfig;</span><br><span class="line">    <span class="comment">//netty相关的配置</span></span><br><span class="line">    <span class="keyword">this</span>.nettyServerConfig = nettyServerConfig;</span><br><span class="line">    <span class="comment">//kv存储的管理类</span></span><br><span class="line">    <span class="keyword">this</span>.kvConfigManager = <span class="keyword">new</span> KVConfigManager(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//broker topic的信息管理</span></span><br><span class="line">    <span class="keyword">this</span>.routeInfoManager = <span class="keyword">new</span> RouteInfoManager();</span><br><span class="line">    <span class="comment">//broker心跳的类，是ChannelEventListener的实现类，Netty的事件触发后处理事件的详细的类，具体调用见NettyConnectManageHandler</span></span><br><span class="line">    <span class="keyword">this</span>.brokerHousekeepingService = <span class="keyword">new</span> BrokerHousekeepingService(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.configuration = <span class="keyword">new</span> Configuration(</span><br><span class="line">        log,</span><br><span class="line">        <span class="keyword">this</span>.namesrvConfig, <span class="keyword">this</span>.nettyServerConfig</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//storePath的保存</span></span><br><span class="line">    <span class="keyword">this</span>.configuration.setStorePathFromConfig(<span class="keyword">this</span>.namesrvConfig, <span class="string">"configStorePath"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//kv设置load到内存</span></span><br><span class="line">       <span class="keyword">this</span>.kvConfigManager.load();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//核心：创建nettyserver</span></span><br><span class="line">       <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//远程命令处理类,具体调用在NettyRemotingAbstract的processMessageReceived里</span></span><br><span class="line">       <span class="keyword">this</span>.remotingExecutor =</span><br><span class="line">           Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"RemotingExecutorThread_"</span>));</span><br><span class="line">       <span class="keyword">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//扫描未活跃的broker并且移除他们每10秒一次</span></span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               NamesrvController.<span class="keyword">this</span>.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//打印所有kvstore的kv</span></span><br><span class="line">       <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               NamesrvController.<span class="keyword">this</span>.kvConfigManager.printAllPeriodically();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="number">1</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//tls--监控tls的文件状态如果修改了重新reload--一个私有方法reloadServerSslContext</span></span><br><span class="line">       <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">           <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               fileWatchService = <span class="keyword">new</span> FileWatchService(</span><br><span class="line">                   ......见源码</span><br><span class="line">               );</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.warn(<span class="string">"FileWatchService created error, can't load the certificate dynamically"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="start"><a href="#start" class="headerlink" title="start"></a>start</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//start servbice</span></span><br><span class="line">    <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听ssl的变化，如果有变化remotingServer.loadSslContext()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remotingServer–NettyRemotingServer"><a href="#remotingServer–NettyRemotingServer" class="headerlink" title="remotingServer–NettyRemotingServer"></a>remotingServer–NettyRemotingServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultEventExecutorGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(</span><br><span class="line">        nettyServerConfig.getServerWorkerThreads(),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> AtomicInteger threadIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thread(r, <span class="string">"NettyServerCodecThread_"</span> + <span class="keyword">this</span>.threadIndex.incrementAndGet());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    ServerBootstrap childHandler =</span><br><span class="line">        <span class="keyword">this</span>.serverBootstrap.group(<span class="keyword">this</span>.eventLoopGroupBoss, <span class="keyword">this</span>.eventLoopGroupSelector)<span class="comment">//bossgruop和workgroup</span></span><br><span class="line">            .channel(useEpoll() ? EpollServerSocketChannel.class : NioServerSocketChannel.class)</span><br><span class="line">            .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)<span class="comment">//listerner的长度，过小会导致tcp链接简历失败</span></span><br><span class="line">            .option(ChannelOption.SO_REUSEADDR, <span class="keyword">true</span>)<span class="comment">//服务器端口可被重用</span></span><br><span class="line">            .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">false</span>)</span><br><span class="line">            .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)<span class="comment">//禁用Nagle算法，有效提高网络负载</span></span><br><span class="line">            .childOption(ChannelOption.SO_SNDBUF, nettyServerConfig.getServerSocketSndBufSize())<span class="comment">//发送缓冲区大小</span></span><br><span class="line">            .childOption(ChannelOption.SO_RCVBUF, nettyServerConfig.getServerSocketRcvBufSize())<span class="comment">//接受缓冲区大小</span></span><br><span class="line">            .localAddress(<span class="keyword">new</span> InetSocketAddress(<span class="keyword">this</span>.nettyServerConfig.getListenPort()))<span class="comment">//设置端口</span></span><br><span class="line">            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//注意：使用第三个EventGroup,defaultEventExecutorGroup，建立链接、读写任务分开</span></span><br><span class="line">                    ch.pipeline()</span><br><span class="line">                        .addLast(defaultEventExecutorGroup, HANDSHAKE_HANDLER_NAME,</span><br><span class="line">                            <span class="keyword">new</span> HandshakeHandler(TlsSystemConfig.tlsMode))</span><br><span class="line">                        .addLast(defaultEventExecutorGroup,</span><br><span class="line">                            <span class="keyword">new</span> NettyEncoder(),<span class="comment">//MessageToByteEncoder</span></span><br><span class="line">                            <span class="keyword">new</span> NettyDecoder(),<span class="comment">//LengthFieldBasedFrameDecoder具体见netty,解决粘包问题</span></span><br><span class="line">                            <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, nettyServerConfig.getServerChannelMaxIdleTimeSeconds()),<span class="comment">//心跳检测机制</span></span><br><span class="line">                            <span class="keyword">new</span> NettyConnectManageHandler(),<span class="comment">//处理io链接相关的事件注意啊channelActive,channelInActive,userEventTriggered（心跳）,exceptionCaught</span></span><br><span class="line">                            <span class="keyword">new</span> NettyServerHandler()<span class="comment">//处理request和response信息</span></span><br><span class="line">                        );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nettyServerConfig.isServerPooledByteBufAllocatorEnable()) &#123;</span><br><span class="line">        <span class="comment">//重用缓冲区</span></span><br><span class="line">        childHandler.childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//监听端口</span></span><br><span class="line">        ChannelFuture sync = <span class="keyword">this</span>.serverBootstrap.bind().sync();</span><br><span class="line">        InetSocketAddress addr = (InetSocketAddress) sync.channel().localAddress();</span><br><span class="line">        <span class="keyword">this</span>.port = addr.getPort();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"this.serverBootstrap.bind().sync() InterruptedException"</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//netty的事件处理类</span></span><br><span class="line">    <span class="comment">// 1.nettyEventExecutor是一个线程，run里是死循环，nettyEventExecutor维护了个阻塞队列，采用生产者消费者模式。putNettEvent放事件，线程异步消费事件</span></span><br><span class="line">    <span class="comment">// 2.事件来了后，通过NettyRemotingServer.this.channelEventListener方法类处理事件</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.channelEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nettyEventExecutor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.timer.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                NettyRemotingServer.<span class="keyword">this</span>.scanResponseTable();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"scanResponseTable exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-源码学习-一-Broker</title>
      <link href="RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%80-Broker/"/>
      <url>RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E4%B8%80-Broker/</url>
      
        <content type="html"><![CDATA[<p>rocketmq的消息的存储模块，broker角色支持ASYNC_MASTER,SYNC_MASTER,SLAVE</p><h2 id="broker的主要属性"><a href="#broker的主要属性" class="headerlink" title="broker的主要属性"></a>broker的主要属性</h2><p>命令是<br>mqbroker -m</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr=</span><br><span class="line">brokerIP1=<span class="number">10.96</span>.83.21</span><br><span class="line">brokerName=localhost</span><br><span class="line">brokerClusterName=DefaultCluster</span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line">autoCreateTopicEnable=<span class="keyword">true</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="keyword">true</span></span><br><span class="line">msgTraceTopicName=RMQ_SYS_TRACE_TOPIC</span><br><span class="line">traceTopicEnable=<span class="keyword">false</span></span><br><span class="line">rejectTransactionMessage=<span class="keyword">false</span></span><br><span class="line">fetchNamesrvAddrByAddressServer=<span class="keyword">false</span></span><br><span class="line">transactionTimeOut=<span class="number">6000</span></span><br><span class="line">transactionCheckMax=<span class="number">15</span></span><br><span class="line">transactionCheckInterval=<span class="number">60000</span></span><br><span class="line">aclEnable=<span class="keyword">false</span></span><br><span class="line">storePathRootDir=/root/store</span><br><span class="line">storePathCommitLog=/root/store/commitlog</span><br><span class="line">flushIntervalCommitLog=<span class="number">500</span></span><br><span class="line">commitIntervalCommitLog=<span class="number">200</span></span><br><span class="line">flushCommitLogTimed=<span class="keyword">false</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">72</span></span><br><span class="line">maxTransferBytesOnMessageInMemory=<span class="number">262144</span></span><br><span class="line">maxTransferCountOnMessageInMemory=<span class="number">32</span></span><br><span class="line">maxTransferBytesOnMessageInDisk=<span class="number">65536</span></span><br><span class="line">maxTransferCountOnMessageInDisk=<span class="number">8</span></span><br><span class="line">accessMessageInMemoryMaxRatio=<span class="number">40</span></span><br><span class="line">messageIndexEnable=<span class="keyword">true</span></span><br><span class="line">messageIndexSafe=<span class="keyword">false</span></span><br><span class="line">haMasterAddress=</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">cleanFileForciblyEnable=<span class="keyword">true</span></span><br><span class="line">transientStorePoolEnable=<span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="BrokerStartup"><a href="#BrokerStartup" class="headerlink" title="BrokerStartup"></a>BrokerStartup</h2><p>程序的入口，调用createBrokerController通过配置文件创建BrokerController，调用start方法启动</p><h3 id="createBrokerController"><a href="#createBrokerController" class="headerlink" title="createBrokerController"></a>createBrokerController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title">createBrokerController</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//broker既是netty的server端又是客户端</span></span><br><span class="line">        <span class="keyword">final</span> BrokerConfig brokerConfig = <span class="keyword">new</span> BrokerConfig();</span><br><span class="line">        <span class="keyword">final</span> NettyServerConfig nettyServerConfig = <span class="keyword">new</span> NettyServerConfig();</span><br><span class="line">        <span class="keyword">final</span> NettyClientConfig nettyClientConfig = <span class="keyword">new</span> NettyClientConfig();</span><br><span class="line"></span><br><span class="line">        nettyClientConfig.setUseTLS(Boolean.parseBoolean(System.getProperty(TLS_ENABLE,</span><br><span class="line">            String.valueOf(TlsSystemConfig.tlsMode == TlsMode.ENFORCING))));</span><br><span class="line">        <span class="comment">//默认监听10911端口</span></span><br><span class="line">        nettyServerConfig.setListenPort(<span class="number">10911</span>);</span><br><span class="line">        <span class="comment">//比较重要，消息存储的配置，Ha端口监听10911，即10911+1 //见HMessageStoreConfig中的AService</span></span><br><span class="line">        <span class="keyword">final</span> MessageStoreConfig messageStoreConfig = <span class="keyword">new</span> MessageStoreConfig();</span><br><span class="line">        ......<span class="comment">//初始化配置并且进行配置检查</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化BrokerController</span></span><br><span class="line">        <span class="keyword">final</span> BrokerController controller = <span class="keyword">new</span> BrokerController(</span><br><span class="line">            brokerConfig,</span><br><span class="line">            nettyServerConfig,</span><br><span class="line">            nettyClientConfig,</span><br><span class="line">            messageStoreConfig);</span><br><span class="line">        <span class="comment">// remember all configs to prevent discard</span></span><br><span class="line">        controller.getConfiguration().registerConfig(properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重要BrokerController的一些初始化操作</span></span><br><span class="line">        <span class="keyword">boolean</span> initResult = controller.initialize();</span><br><span class="line">        <span class="keyword">if</span> (!initResult) &#123;</span><br><span class="line">            controller.shutdown();</span><br><span class="line">            System.exit(-<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> hasShutdown = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">private</span> AtomicInteger shutdownTimes = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    log.info(<span class="string">"Shutdown hook was invoked, &#123;&#125;"</span>, <span class="keyword">this</span>.shutdownTimes.incrementAndGet());</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.hasShutdown) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.hasShutdown = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">long</span> beginTime = System.currentTimeMillis();</span><br><span class="line">                        controller.shutdown();</span><br><span class="line">                        <span class="keyword">long</span> consumingTimeTotal = System.currentTimeMillis() - beginTime;</span><br><span class="line">                        log.info(<span class="string">"Shutdown hook over, consuming total time(ms): &#123;&#125;"</span>, consumingTimeTotal);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"ShutdownHook"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>start()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BrokerController <span class="title">start</span><span class="params">(BrokerController controller)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        controller.start();</span><br><span class="line"></span><br><span class="line">        String tip = <span class="string">"The broker["</span> + controller.getBrokerConfig().getBrokerName() + <span class="string">", "</span></span><br><span class="line">            + controller.getBrokerAddr() + <span class="string">"] boot success. serializeType="</span> + RemotingCommand.getSerializeTypeConfigInThisServer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != controller.getBrokerConfig().getNamesrvAddr()) &#123;</span><br><span class="line">            tip += <span class="string">" and name server is "</span> + controller.getBrokerConfig().getNamesrvAddr();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        log.info(tip);</span><br><span class="line">        System.out.printf(<span class="string">"%s%n"</span>, tip);</span><br><span class="line">        <span class="keyword">return</span> controller;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.exit(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BrokerController"><a href="#BrokerController" class="headerlink" title="BrokerController"></a>BrokerController</h2><p>关键点</p><ul><li>构造方法 初始化config对象</li><li>initialize 关键成员的初始化工作</li><li>start 相关的对象的start还有想nameServer注册能</li><li>关键成员 topicConfigManager、consumerOffsetManager、messageStore、以及remotingServer</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>brokerOuterAPI：nettyClient–用于broker和外部模块沟通，有几个功能：<ul><li>（1）和nameserver交互，进行broker节点的注册和取消；</li><li>（2）和其他broker节点交互；</li></ul></li><li>topicConfigManager</li><li>consumerOffsetManager</li><li>subscriptionGroupManager</li><li>consumerFilterManager</li></ul><h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="comment">//分别从/root/store/config/下的topic.json、consumerOffset.json、consumerFilter.json</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储每个topic的读写队列数、权限、是否顺序等信息</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.topicConfigManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储每个消费者Consumer在每个topic上对于该topic的consumequeue队列的消费进度；</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerOffsetManager.load();</span><br><span class="line">    <span class="comment">//存储每个消费者Consumer的订阅信息。</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.subscriptionGroupManager.load();</span><br><span class="line">    <span class="comment">//存储消费者过滤器的信息</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.consumerFilterManager.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//todo 消息持久化的方法</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore =</span><br><span class="line">                <span class="keyword">new</span> DefaultMessageStore(<span class="keyword">this</span>.messageStoreConfig, <span class="keyword">this</span>.brokerStatsManager, <span class="keyword">this</span>.messageArrivingListener,</span><br><span class="line">                    <span class="keyword">this</span>.brokerConfig);</span><br><span class="line">            <span class="keyword">this</span>.brokerStats = <span class="keyword">new</span> BrokerStats((DefaultMessageStore) <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="comment">//load plugin</span></span><br><span class="line">            MessageStorePluginContext context = <span class="keyword">new</span> MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);</span><br><span class="line">            <span class="comment">//AbstractPluginMessageStore</span></span><br><span class="line">            <span class="keyword">this</span>.messageStore = MessageStoreFactory.build(context, <span class="keyword">this</span>.messageStore);</span><br><span class="line">            <span class="keyword">this</span>.messageStore.getDispatcherList().addFirst(<span class="keyword">new</span> CommitLogDispatcherCalcBitMap(<span class="keyword">this</span>.brokerConfig, <span class="keyword">this</span>.consumerFilterManager));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            result = <span class="keyword">false</span>;</span><br><span class="line">            log.error(<span class="string">"Failed to initialize"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化messageStore</span></span><br><span class="line">    result = result &amp;&amp; <span class="keyword">this</span>.messageStore.load();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">//初始化broker的server</span></span><br><span class="line">        <span class="keyword">this</span>.remotingServer = <span class="keyword">new</span> NettyRemotingServer(<span class="keyword">this</span>.nettyServerConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        NettyServerConfig fastConfig = (NettyServerConfig) <span class="keyword">this</span>.nettyServerConfig.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo *****不知道做什么的和remotingServer功能高度重合*****</span></span><br><span class="line">        fastConfig.setListenPort(nettyServerConfig.getListenPort() - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer = <span class="keyword">new</span> NettyRemotingServer(fastConfig, <span class="keyword">this</span>.clientHousekeepingService);</span><br><span class="line">        <span class="keyword">this</span>.sendMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getSendMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.sendThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"SendMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.pullMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getPullMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.pullThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"PullMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.queryMessageExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getQueryMessageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.queryThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"QueryMessageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.adminBrokerExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getAdminBrokerThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"AdminBrokerThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clientManageExecutor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getClientManageThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.clientManagerThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"ClientManageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.heartbeatExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getHeartbeatThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.heartbeatThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"HeartbeatThread_"</span>, <span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.endTransactionExecutor = <span class="keyword">new</span> BrokerFixedThreadPoolExecutor(</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="keyword">this</span>.brokerConfig.getEndTransactionThreadPoolNums(),</span><br><span class="line">            <span class="number">1000</span> * <span class="number">60</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">this</span>.endTransactionThreadPoolQueue,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">"EndTransactionThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.consumerManageExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(<span class="keyword">this</span>.brokerConfig.getConsumerManageThreadPoolNums(), <span class="keyword">new</span> ThreadFactoryImpl(</span><br><span class="line">                <span class="string">"ConsumerManageThread_"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册netty-channelRead事件处理类</span></span><br><span class="line">        <span class="keyword">this</span>.registerProcessor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> initialDelay = UtilAll.computNextMorningTimeMillis() - System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> period = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line">        <span class="comment">//统计broker put和get的消息，一天一次</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.getBrokerStats().record();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule record error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, initialDelay, period, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//持久化offSet信息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerOffsetManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumerOffset error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="keyword">this</span>.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//持久化consumerFilter信息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.consumerFilterManager.persist();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule persist consumer filter error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//熔断机制，将消费异常的消费组踢下去？防止某些consumer消息堆积</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.protectBroker();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"protectBroker error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">3</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印水位信息</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.printWaterMark();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"printWaterMark error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">10</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取已经持计划到到commitlog，但是还没有被消费的日志的byte大小</span></span><br><span class="line">        <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"dispatch behind commit log &#123;&#125; bytes"</span>, BrokerController.<span class="keyword">this</span>.getMessageStore().dispatchBehindBytes());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"schedule dispatchBehindBytes error."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到nameServAddr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.getNamesrvAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerOuterAPI.updateNameServerAddressList(<span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">            log.info(<span class="string">"Set user specified name server address: &#123;&#125;"</span>, <span class="keyword">this</span>.brokerConfig.getNamesrvAddr());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.brokerConfig.isFetchNamesrvAddrByAddressServer()) &#123;</span><br><span class="line">            <span class="comment">//和nameServAddr的心跳机制</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.brokerOuterAPI.fetchNameServerAddr();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask fetchNameServerAddr exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//slave角色特有的操作</span></span><br><span class="line">        <span class="keyword">if</span> (BrokerRole.SLAVE == <span class="keyword">this</span>.messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress() != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress().length() &gt;= <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.messageStore.updateHaMasterAddress(<span class="keyword">this</span>.messageStoreConfig.getHaMasterAddress());</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.updateMasterHAServerAddrPeriodically = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定期从主同步Broker信息</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"ScheduledTask syncAll slave exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//主会打印主从差异</span></span><br><span class="line">            <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        BrokerController.<span class="keyword">this</span>.printMasterAndSlaveDiff();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        log.error(<span class="string">"schedule printMasterAndSlaveDiff error."</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span> * <span class="number">10</span>, <span class="number">1000</span> * <span class="number">60</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">            <span class="comment">// Register a listener to reload SslContext</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWatchService = <span class="keyword">new</span> FileWatchService(</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;</span><br><span class="line">                        TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">                        TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">                        TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> certChanged, keyChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">                                log.info(<span class="string">"The trust certificate changed, reload the ssl context"</span>);</span><br><span class="line">                                reloadServerSslContext();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">                                certChanged = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">                                keyChanged = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">                                log.info(<span class="string">"The certificate and private key changed, reload the ssl context"</span>);</span><br><span class="line">                                certChanged = keyChanged = <span class="keyword">false</span>;</span><br><span class="line">                                reloadServerSslContext();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reloadServerSslContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">                            ((NettyRemotingServer) fastRemotingServer).loadSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.warn(<span class="string">"FileWatchService created error, can't load the certificate dynamically"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        initialTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerProcessor()方法中各processor的对应关系</p><p>SendMessageProcessor</p><blockquote><p>RequestCode.SEND_MESSAGE、RequestCode.SEND_MESSAGE_V2、RequestCode.SEND_BATCH_MESSAGE、RequestCode.CONSUMER_SEND_MSG_BACK、</p></blockquote><p>PullMessageProcessor–处理拉取消息的请求</p><blockquote><p>RequestCode.PULL_MESSAGE</p></blockquote><p>QueryMessageProcessor</p><blockquote><p>RequestCode.QUERY_MESSAGE、RequestCode.VIEW_MESSAGE_BY_ID</p></blockquote><p>ClientManageProcessor–处理客户端的请求，如心跳等</p><blockquote><p>RequestCode.HEART_BEAT、RequestCode.UNREGISTER_CLIENT、RequestCode.CHECK_CLIENT_CONFIG</p></blockquote><p>ConsumerManageProcessor</p><blockquote><p>RequestCode.GET_CONSUMER_LIST_BY_GROUP、RequestCode.UPDATE_CONSUMER_OFFSET、RequestCode.QUERY_CONSUMER_OFFSET</p></blockquote><p>EndTransactionProcessor</p><blockquote><p>RequestCode.END_TRANSACTION</p></blockquote><p>AdminBrokerProcessor</p><blockquote><p>registerDefaultProcessor</p></blockquote><h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//message保存模块 重要</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.messageStore != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//netty的server端broker监听的端口 重要</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.remotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.remotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//netty的server端 remotingServer端口-2 不知道有什么用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fastRemotingServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fastRemotingServer.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件监听类，和ssl有关不重要</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fileWatchService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fileWatchService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//nettyclient对外和nameserver以及其他broker交互</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerOuterAPI != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerOuterAPI.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理ResponseCode.PULL_NOT_FOUND等异常状态的消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pullRequestHoldService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.pullRequestHoldService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理系统服务服务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.clientHousekeepingService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clientHousekeepingService.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动filterServer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.filterServerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.filterServerManager.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向nameserv发送数据进行broker的注册，注意非单向的equestCode.QUERY_DATA_VERSION,</span></span><br><span class="line">    <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每隔一段时间注册一下broker</span></span><br><span class="line">    <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                BrokerController.<span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">false</span>, brokerConfig.isForceRegister());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                log.error(<span class="string">"registerBrokerAll Exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span> * <span class="number">10</span>, Math.max(<span class="number">10000</span>, Math.min(brokerConfig.getRegisterNameServerPeriod(), <span class="number">60000</span>)), TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerStatsManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerStatsManager.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速返回失败...开启之后每隔10ms会清理过去的request请求，见代码start</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerFastFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerFastFailure.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主的broker开始事物检查</span></span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE != messageStoreConfig.getBrokerRole()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"Start transaction service!"</span>);</span><br><span class="line">            <span class="comment">//run方法里的死循环wait一段时间，然后onWaitEnd中check()</span></span><br><span class="line">            <span class="keyword">this</span>.transactionalMessageCheckService.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="broker心跳机制"><a href="#broker心跳机制" class="headerlink" title="broker心跳机制"></a>broker心跳机制</h2><ul><li>心跳包发送：<ul><li>ClientManageProcessor负责处理producer、consumer、其他broker（topic）发送的心跳包见heartBeat方法</li></ul></li><li>清理：<ul><li>clientHousekeepingService定期会清理不用的链接</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-源码学习-零-提前的一些准备</title>
      <link href="RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E9%9B%B6-%E6%8F%90%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87/"/>
      <url>RocketMq-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E9%9B%B6-%E6%8F%90%E5%89%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<p>看源码的一些准备工作，以下逻辑会出现多次。</p><h2 id="RemotingServer"><a href="#RemotingServer" class="headerlink" title="RemotingServer"></a>RemotingServer</h2><p>rocketMq采用NettyRemotingServer来处理各个组件之间的网络通信。</p><h3 id="处理消息的方式"><a href="#处理消息的方式" class="headerlink" title="处理消息的方式"></a>处理消息的方式</h3><p>NettyRemotingServer的channelRead0()–&gt;NettyServerHandler.processMessageReceived–&gt;NettyServerHandler.processRequestCommand的processorTable处理，其中processorTable的方法是通过下面的方式注册进去</p><ul><li>注册消息的：通过registerProcessor方法，每种消息根据requestcode，来制定消息处理方式。<ul><li>维护了processorTable对象，HashMap&lt;Integer/<em> request code </em>/, Pair&lt;NettyRequestProcessor, ExecutorService&gt;&gt;</li><li>每一种request指定一个ExecutorService和一个registerProcessor来处理</li></ul></li><li>处理消息：通过调用processMessageReceived来处理。</li></ul><h2 id="NettyClient三种发送消息的方式"><a href="#NettyClient三种发送消息的方式" class="headerlink" title="NettyClient三种发送消息的方式"></a>NettyClient三种发送消息的方式</h2><p>见信息的发送</p><h3 id="invokeOneway-单向发送无返回值"><a href="#invokeOneway-单向发送无返回值" class="headerlink" title="invokeOneway:单向发送无返回值"></a>invokeOneway:单向发送无返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeOneway</span><span class="params">(String addr, RemotingCommand request, <span class="keyword">long</span> timeoutMillis)</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">    RemotingConnectException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException </span>&#123;</span><br><span class="line">    <span class="comment">//get or create Channel</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = <span class="keyword">this</span>.getAndCreateChannel(addr);</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rpcHook.doBeforeRequest(addr, request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.invokeOnewayImpl(channel, request, timeoutMillis);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingSendRequestException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"invokeOneway: send request exception, so close the channel[&#123;&#125;]"</span>, addr);</span><br><span class="line">            <span class="keyword">this</span>.closeChannel(addr, channel);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeChannel(addr, channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingConnectException(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeOnewayImpl</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException </span>&#123;</span><br><span class="line">    request.markOnewayRPC();</span><br><span class="line">    <span class="comment">//限流</span></span><br><span class="line">    <span class="keyword">boolean</span> acquired = <span class="keyword">this</span>.semaphoreOneway.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreReleaseOnlyOnce once = <span class="keyword">new</span> SemaphoreReleaseOnlyOnce(<span class="keyword">this</span>.semaphoreOneway);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//释放</span></span><br><span class="line">                    once.release();</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            ......</span><br><span class="line">            once.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingSendRequestException(RemotingHelper.parseChannelRemoteAddr(channel), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"invokeOnewayImpl invoke too fast"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTimeoutException(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="invokeAsync-异步发送方式，invokeCallback中处理返回值信息"><a href="#invokeAsync-异步发送方式，invokeCallback中处理返回值信息" class="headerlink" title="invokeAsync:异步发送方式，invokeCallback中处理返回值信息"></a>invokeAsync:异步发送方式，invokeCallback中处理返回值信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAsync</span><span class="params">(String addr, RemotingCommand request, <span class="keyword">long</span> timeoutMillis, InvokeCallback invokeCallback)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, RemotingConnectException, RemotingTooMuchRequestException, RemotingTimeoutException,</span></span><br><span class="line"><span class="function">    RemotingSendRequestException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = <span class="keyword">this</span>.getAndCreateChannel(addr);</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rpcHook.doBeforeRequest(addr, request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt; costTime) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"invokeAsync call timeout"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.invokeAsyncImpl(channel, request, timeoutMillis - costTime, invokeCallback);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingSendRequestException e) &#123;</span><br><span class="line">            log.warn(<span class="string">"invokeAsync: send request exception, so close the channel[&#123;&#125;]"</span>, addr);</span><br><span class="line">            <span class="keyword">this</span>.closeChannel(addr, channel);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.closeChannel(addr, channel);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingConnectException(addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeAsyncImpl</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> InvokeCallback invokeCallback)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, RemotingTooMuchRequestException, RemotingTimeoutException, RemotingSendRequestException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> opaque = request.getOpaque();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限流</span></span><br><span class="line">    <span class="keyword">boolean</span> acquired = <span class="keyword">this</span>.semaphoreAsync.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (acquired) &#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreReleaseOnlyOnce once = <span class="keyword">new</span> SemaphoreReleaseOnlyOnce(<span class="keyword">this</span>.semaphoreAsync);</span><br><span class="line">        <span class="keyword">long</span> costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">        <span class="keyword">if</span> (timeoutMillis &lt; costTime) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTooMuchRequestException(<span class="string">"invokeAsyncImpl call timeout"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//responseFuture每个请求创建一个responseFuture，在responseFuture调用invokeCallback</span></span><br><span class="line">        <span class="keyword">final</span> ResponseFuture responseFuture = <span class="keyword">new</span> ResponseFuture(channel, opaque, timeoutMillis - costTime, invokeCallback, once);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 标准的rpc异步处理流程</span></span><br><span class="line"><span class="comment">         * 1.这里是讲requestId--&gt;responseFuture放到responseTable</span></span><br><span class="line"><span class="comment">         * 2.当server处理完发送请求之后发送回客户端由processResponseCommand方法处理，responseTable通过repsonse的Id,取到对应的responseFuture</span></span><br><span class="line"><span class="comment">         * 3.invokeCallback来处理后续操作</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">this</span>.responseTable.put(opaque, responseFuture);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.isSuccess()) &#123;</span><br><span class="line">                        responseFuture.setSendRequestOK(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//处理失败的请求</span></span><br><span class="line">                    requestFail(opaque);</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            responseFuture.release();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        异常处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="invokeSync-同步发送，等待返回值"><a href="#invokeSync-同步发送，等待返回值" class="headerlink" title="invokeSync:同步发送，等待返回值"></a>invokeSync:同步发送，等待返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">invokeSync</span><span class="params">(String addr, <span class="keyword">final</span> RemotingCommand request, <span class="keyword">long</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = <span class="keyword">this</span>.getAndCreateChannel(addr);</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rpcHook.doBeforeRequest(addr, request);</span><br><span class="line">            &#125;</span><br><span class="line">            ......超时</span><br><span class="line">            RemotingCommand response = <span class="keyword">this</span>.invokeSyncImpl(channel, request, timeoutMillis - costTime);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.rpcHook != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.rpcHook.doAfterResponse(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingSendRequestException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemotingTimeoutException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">invokeSyncImpl</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> RemotingCommand request,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, RemotingSendRequestException, RemotingTimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> opaque = request.getOpaque();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ResponseFuture responseFuture = <span class="keyword">new</span> ResponseFuture(channel, opaque, timeoutMillis, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.responseTable.put(opaque, responseFuture);</span><br><span class="line">        <span class="keyword">final</span> SocketAddress addr = channel.remoteAddress();</span><br><span class="line">        channel.writeAndFlush(request).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (f.isSuccess()) &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    responseFuture.setSendRequestOK(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                responseTable.remove(opaque);</span><br><span class="line">                responseFuture.setCause(f.cause());</span><br><span class="line">                <span class="comment">//发送消息成功到了通知responseFuture</span></span><br><span class="line">                responseFuture.putResponse(<span class="keyword">null</span>);</span><br><span class="line">                log.warn(<span class="string">"send a request command to channel &lt;"</span> + addr + <span class="string">"&gt; failed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//async是直接交给processResponseCommand就返回了,这里是同步转异步等待一定时间</span></span><br><span class="line">        <span class="comment">// 1.在processResponseCommand可以主动终止，发送ok</span></span><br><span class="line">        <span class="comment">// 2.ChannelFutureListener失败，可以主动终止，失败</span></span><br><span class="line">        <span class="comment">// 3.超时</span></span><br><span class="line">        RemotingCommand responseCommand = responseFuture.waitResponse(timeoutMillis);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == responseCommand) &#123;</span><br><span class="line">            <span class="keyword">if</span> (responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingTimeoutException(RemotingHelper.parseSocketAddressAddr(addr), timeoutMillis,</span><br><span class="line">                    responseFuture.getCause());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemotingSendRequestException(RemotingHelper.parseSocketAddressAddr(addr), responseFuture.getCause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> responseCommand;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.responseTable.remove(opaque);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统优化-CPU-理解CPU的平均负载</title>
      <link href="%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E7%90%86%E8%A7%A3CPU%E7%9A%84%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/"/>
      <url>%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96-CPU-%E7%90%86%E8%A7%A3CPU%E7%9A%84%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>本章主要讲解如何理解CPU的平均负载、以及常见的引起CPU平均负载升高的几种场景。</p><h2 id="什么是CPU的平均负载"><a href="#什么是CPU的平均负载" class="headerlink" title="什么是CPU的平均负载"></a>什么是CPU的平均负载</h2><p>  指单位时间内系统可运行（Runnable）以及不可中断(Uninterruptible Sleep)的平均进程数。其中不可中断是指系统对进程和设备的一种保护，比如读磁盘的文件为了保证系统的一致性这个进程不可中断 ps命令中是D</p><p>  如何查看平均负载呢：</p><blockquote><p>常用命令有：uptime|top|w，我们1以uptime为例，如：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> uptime</span></span><br><span class="line">02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88</span><br></pre></td></tr></table></figure><p>  其中：load average: 0.63, 0.83, 0.88 分别代表了最近1分钟、5分钟、15分钟的cpu平均负载，什么是laod avarage呢</p><p>  平均负载反映了这段时间操作系统的CPU负载的趋势，一般来讲，一个健康的系统的平均负载不应该超过<strong>0.7</strong>。</p><h2 id="引起平均负载升高的常见的三种场景"><a href="#引起平均负载升高的常见的三种场景" class="headerlink" title="引起平均负载升高的常见的三种场景"></a>引起平均负载升高的常见的三种场景</h2><p>  和平均负载相关的另一项数据是CPU的使用率，他们俩的关系根据场景有如下的联系</p><ol><li>计算密集型：cpu使用率和cpu负载会同时升高</li><li>I/O密集型：大量的线程处于i/o-wait，这时候cpu负载高但是cpu使用率并不高</li><li><p>当需要调度的进程数量大于cpu的时候，cpu负载和使用率会同时升高。</p><p>我们怎么确定上述的3中场景呢？这时候我们可以用到如下的工具:</p></li></ol><ul><li>stress 压测工具</li><li>sysstat linux性能分析工具，常用mpstat和pidstat</li></ul><h3 id="模拟计算密集型"><a href="#模拟计算密集型" class="headerlink" title="模拟计算密集型"></a>模拟计算密集型</h3><p>见下图：</p><p>  mpstat的结果显示这时候看%iowait不高，但是%user已经100%了<br>  pidstat的结果显示是stress引起的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">stress --cpu 1 --timeout 600 #一个核打满</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统性能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mpstat -P ALL 5</span></span><br><span class="line">Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)</span><br><span class="line">13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95</span><br><span class="line">13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00</span><br><span class="line">13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">分析由于iowait为0，user很高说明是CPU计算导致的,于是我们</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔 5 秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1</span></span><br><span class="line">13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress</span><br></pre></td></tr></table></figure><h3 id="模拟IO密集型"><a href="#模拟IO密集型" class="headerlink" title="模拟IO密集型"></a>模拟IO密集型</h3><p>见下图：</p><p>  mpstat的结果显示这时候看%iowait很高67.53，但是%user才0.43<br>  pidstat的结果显示是stress引起的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发送sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> stress -i 1 --timeout 600</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统性能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mpstat -P ALL 5 1</span></span><br><span class="line">Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)</span><br><span class="line">13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84</span><br><span class="line">13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74</span><br><span class="line">13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">分析使用率不高但是iowait很高</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔 5 秒后输出一组数据，-u 表示 CPU 指标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1</span></span><br><span class="line">Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)</span><br><span class="line">13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H</span><br><span class="line">13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H</span><br><span class="line">13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress</span><br><span class="line">13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">发现stress导致的</span></span><br></pre></td></tr></table></figure><h3 id="大量CPU调度"><a href="#大量CPU调度" class="headerlink" title="大量CPU调度"></a>大量CPU调度</h3><p>  pidstat的结果显示%wait的结果很高，%iowait和cpu都不高</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发送sync</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> stress -c 8 --timeout 600</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看系统性能</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 间隔 5 秒后输出一组数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pidstat -u 5 1</span></span><br><span class="line">14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command</span><br><span class="line">14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress</span><br><span class="line">14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress</span><br><span class="line">14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress</span><br><span class="line">14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress</span><br><span class="line">14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress</span><br><span class="line">14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress</span><br><span class="line">14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress</span><br><span class="line">14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress</span><br><span class="line">14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">发现stress导致的</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>计算密集型：mpstat如果%user很高，但是%iowait不高，再用pidstat查看进程的%wait如果也不高。</li><li>I/O密集型：mpstat如果%user不高，但是%iowait很高，再用pidstat查看进程的%wait如果也不高。</li><li>大量的进程需要调度：mpstat如果%user不高，但是%iowait不高，再用pidstat查看进程的%wait如果很高。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
          <category> CPU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 性能优化 </tag>
            
            <tag> CPU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RockeMq-初始以及demo的注解</title>
      <link href="RockeMq-%E5%88%9D%E5%A7%8B%E4%BB%A5%E5%8F%8Ademo%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
      <url>RockeMq-%E5%88%9D%E5%A7%8B%E4%BB%A5%E5%8F%8Ademo%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h2><h2 id="send-one-way"><a href="#send-one-way" class="headerlink" title="send-one-way"></a>send-one-way</h2><p>发送后不会检查发送状态,方法返回值void，常用于log的收集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg)</span><br></pre></td></tr></table></figure><p>send-sync</p><p>同步发送场景，发送后会返回sendResult用于检查发送状态，适合于订单等场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg)</span><br></pre></td></tr></table></figure><p>send-async</p><p>异步发送场景，安全性介于上述两者之间，会有发送结果但是在SendCallback回调中处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg,<span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"producer sendResult="</span>+sendResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, -<span class="number">1</span>, e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><h3 id="保续消费"><a href="#保续消费" class="headerlink" title="保续消费"></a>保续消费</h3><p>客户端:send(Message msg, MessageQueueSelector selector, Object arg)</p><ul><li>实现MessageQueueSelector</li></ul><p>消费者</p><ul><li>MessageListenerOrderly:保续消费</li></ul><h3 id="ack机制"><a href="#ack机制" class="headerlink" title="ack机制"></a>ack机制</h3><ul><li>ConsumeConcurrentlyStatus.CONSUME_SUCCESS：消费成功</li><li>ConsumeConcurrentlyStatus.RECONSUME_LATER：重复消费。rocketmq会放到重试队列,这个重试TOPIC的名字是%RETRY%+consumergroup的名字</li></ul><p>注意：</p><ol><li>如果业务的回调没有处理好而抛出异常，会认为是消费失败当ConsumeConcurrentlyStatus.RECONSUME_LATER处理。</li><li>当使用顺序消费的回调MessageListenerOrderly时，由于顺序消费是要前者消费成功才能继续消费，所以没有ConsumeConcurrentlyStatus.RECONSUME_LATER的这个状态，只有ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT来暂停队列的其余消费，直到原消息不断重试成功为止才能继续消费。</li></ol><h3 id="offset的控制"><a href="#offset的控制" class="headerlink" title="offset的控制"></a>offset的控制</h3><p>和kafka类似的机制。</p><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ol><li>后续补充对offset的理解</li><li>保续消费的实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基础</title>
      <link href="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>at-least-once：如果producer收到来自Kafka broker的确认（ack）或者acks = all，则表示该消息已经写入到Kafka。但如果producer ack超时或收到错误，则可能会重试发送消息，客户端会认为该消息未写入Kafka。如果broker在发送Ack之前失败，但在消息成功写入Kafka之后，此重试将导致该消息被写入两次，因此消息会被不止一次地传递给最终consumer，这种策略可能导致重复的工作和不正确的结果。</p><p>at-most-once：如果在ack超时或返回错误时producer不重试，则该消息可能最终不会写入Kafka，因此不会传递给consumer。在大多数情况下，这样做是为了避免重复的可能性，业务上必须接收数据传递可能的丢失。</p><p>exactly-once：即使producer重试发送消息，消息也会保证最多一次地传递给最终consumer。该语义是最理想的，但也难以实现，这是因为它需要消息系统本身与生产和消费消息的应用程序进行协作。例如如果在消费消息成功后，将Kafka consumer的偏移量rollback，我们将会再次从该偏移量开始接收消息。这表明消息传递系统和客户端应用程序必须配合调整才能实现excactly-once。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq-集群搭建笔记</title>
      <link href="RocketMq-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
      <url>RocketMq-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="服务器准备"><a href="#服务器准备" class="headerlink" title="服务器准备"></a>服务器准备</h2><p>10.96.115.40         mq-01              broker-a<br>10.96.83.21          mq-02              broker-b<br>10.96.83.21          mq-02              broker-a-s<br>10.96.115.40         mq-01              broker-b-s<br>10.96.83.21、10.96.115.40          mq-01、mq-02    nameserver、console</p><h2 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h2><p>采用的是源码编译,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/apache/rocketmq.git</span></span><br><span class="line"></span><br><span class="line">cd rocketmq</span><br><span class="line"></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br><span class="line"></span><br><span class="line">cp -rf distribution/target/rocketmq-<span class="number">4.5</span>.2/rocketmq-<span class="number">4.5</span>.2/  &#123;workdir&#125;/rocketmq-<span class="number">4.5</span>.2</span><br><span class="line"></span><br><span class="line">cd &#123;workdir&#125;/rocketmq-<span class="number">4.5</span>.2</span><br></pre></td></tr></table></figure><h2 id="启动nameserver"><a href="#启动nameserver" class="headerlink" title="启动nameserver"></a>启动nameserver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure><h2 id="启动borker"><a href="#启动borker" class="headerlink" title="启动borker"></a>启动borker</h2><p>很贴心的为我们准备了配置的模板2m-2s-async、2m-2s-sync、2m-noslave</p><ul><li>10.96.115.40是broker-a、broker-b-s</li><li>10.96.83.21是broker-b、broker-a-s</li></ul><h3 id="10-96-115-40的操作"><a href="#10-96-115-40的操作" class="headerlink" title="10.96.115.40的操作"></a>10.96.115.40的操作</h3><p>broker-a的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr=<span class="number">10.96</span>.115.40:<span class="number">9876</span>;<span class="number">10.96</span>.83.21:<span class="number">9876</span>    <span class="comment">//所关联的namesrv地址</span></span><br><span class="line">brokerClusterName=TestCluster     <span class="comment">//集群名称</span></span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=<span class="number">0</span>                                                 <span class="comment">//0代表主</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=ASYNC_MASTER             <span class="comment">//角色</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH           <span class="comment">//异步刷盘</span></span><br><span class="line">storePathRootDir=/home/xiaoju/logs/rocketmqlogs/store  </span><br><span class="line">storePathCommitLog=/home/xiaoju/logs/rocketmqlogs/store/commitlog  <span class="comment">//日志存放目录</span></span><br><span class="line">listenPort=<span class="number">10900</span></span><br></pre></td></tr></table></figure><p>broker-b-s的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr=<span class="number">10.96</span>.115.40:<span class="number">9876</span>;<span class="number">10.96</span>.83.21:<span class="number">9876</span></span><br><span class="line">brokerClusterName=TestCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">listenPort=<span class="number">10910</span>   <span class="comment">//更改端口号，同一台机器上两个broker不可采用同一端口</span></span><br><span class="line"></span><br><span class="line">storePathRootDir=/opt/logs/rocketmqlogs/store  </span><br><span class="line">storePathCommitLog=/opt/logs/rocketmqlogs/store/commitlog</span><br></pre></td></tr></table></figure><p>启动broker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#123;workdir&#125;/rocketmq-4.5.2</span><br><span class="line">nohup sh bin/mqbroker -c /home/xiaoju/rocketmq-4.5.2/conf/2m-2s-async/broker-a.properties &amp;</span><br><span class="line">nohup sh bin/mqbroker -c /home/xiaoju/rocketmq-4.5.2/conf/2m-2s-async/broker-b-s.properties &amp;</span><br></pre></td></tr></table></figure><h3 id="10-96-83-21的操作"><a href="#10-96-83-21的操作" class="headerlink" title="10.96.83.21的操作"></a>10.96.83.21的操作</h3><p>broker-b的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr=<span class="number">10.96</span>.115.40:<span class="number">9876</span>;<span class="number">10.96</span>.83.21:<span class="number">9876</span></span><br><span class="line">brokerClusterName=TestCluster</span><br><span class="line">brokerName=broker-b</span><br><span class="line">brokerId=<span class="number">0</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">storePathRootDir=/home/xiaoju/logs/rocketmqlogs/store  </span><br><span class="line">storePathCommitLog=/home/xiaoju/logs/rocketmqlogs/store/commitlog</span><br><span class="line">listenPort=<span class="number">10900</span></span><br></pre></td></tr></table></figure><p>broker-a-s的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">namesrvAddr=<span class="number">10.96</span>.115.40:<span class="number">9876</span>;<span class="number">10.96</span>.83.21:<span class="number">9876</span></span><br><span class="line">brokerClusterName=TestCluster</span><br><span class="line">brokerName=broker-a</span><br><span class="line">brokerId=<span class="number">1</span></span><br><span class="line">deleteWhen=<span class="number">04</span></span><br><span class="line">fileReservedTime=<span class="number">48</span></span><br><span class="line">brokerRole=SLAVE</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line">listenPort=<span class="number">10910</span></span><br><span class="line">storePathRootDir=/opt/logs/rocketmqlogs/store</span><br><span class="line">storePathCommitLog=/opt/logs/rocketmqlogs/store/commitlog</span><br></pre></td></tr></table></figure><p>启动broker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &#123;workdir&#125;/rocketmq-4.5.2</span><br><span class="line">nohup sh bin/mqbroker -c /home/xiaoju/rocketmq-4.5.2/conf/2m-2s-async/broker-b.properties &amp;</span><br><span class="line">nohup sh bin/mqbroker -c /home/xiaoju/rocketmq-4.5.2/conf/2m-2s-async/broker-a-s.properties &amp;</span><br></pre></td></tr></table></figure><h2 id="启动rocketmq-console"><a href="#启动rocketmq-console" class="headerlink" title="启动rocketmq-console"></a>启动rocketmq-console</h2><p>一个springboot工程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals.git</span><br></pre></td></tr></table></figure><h2 id="mqadmin常用命令"><a href="#mqadmin常用命令" class="headerlink" title="mqadmin常用命令"></a>mqadmin常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">查看帮助：</span><br><span class="line"><span class="meta">#</span> sh mqadmin &lt;command&gt; -h</span><br><span class="line">查询Producer的网络连接情况：</span><br><span class="line"><span class="meta">#</span> sh mqadmin producerConnection -n localhost:9876 -g &lt;producer-group&gt; -t &lt;producer-topic&gt;</span><br><span class="line">查询Consumer的网络连接情况：</span><br><span class="line"><span class="meta">#</span> sh mqadmin consumerConnection -n localhost:9876 -g &lt;consumer-group&gt;</span><br><span class="line">查询Consumer的消费状态：</span><br><span class="line"><span class="meta">#</span> sh mqadmin consumerProgress -n localhost:9876 -g &lt;consumer-group&gt;</span><br><span class="line"></span><br><span class="line">查询消息是否发送成功</span><br><span class="line">获取指定Topic：</span><br><span class="line"><span class="meta">#</span> sh mqadmin topicList -n localhost:9876 | grep &lt;topicName&gt;</span><br><span class="line">查看Topic状态：</span><br><span class="line"><span class="meta">#</span> sh mqadmin topicStatus -n localhost:9876 -t &lt;topicName&gt;</span><br><span class="line">根据offset获取消息：</span><br><span class="line"><span class="meta">#</span> sh sh mqadmin queryMsgByOffset -n localhost:9876 -b &lt;broker-name&gt; -i &lt;queueId&gt; -o &lt;offset&gt; -t &lt;topicName&gt;</span><br><span class="line">根据offsetMsgId查询消息：</span><br><span class="line"><span class="meta">#</span> sh sh mqadmin queryMsgById -n localhost:9876 -i &lt;offsetMsgId&gt;</span><br><span class="line"></span><br><span class="line">查询消息是否被消费成功</span><br><span class="line">查询消息详情：</span><br><span class="line"><span class="meta">#</span> sh mqadmin queryMsgById -i &#123;MsgId&#125; -n &#123;NameServerAddr&#125;</span><br><span class="line">查看Consumer Group订阅了哪些TOPIC：</span><br><span class="line"><span class="meta">#</span> sh mqadmin consumerProgress -g &lt;ConsumerGroup&gt; -n &lt;NameServerAddr&gt;</span><br><span class="line"></span><br><span class="line">查询TOPIC被哪些Consumer Group订阅了</span><br><span class="line">没有查询特定TOPIC订阅情况，只能查询所有后再过滤：</span><br><span class="line"><span class="meta">#</span> sh mqadmin statsAll -n &lt;NameServerAddr&gt; | grep &lt;TOPIC&gt;</span><br><span class="line">返回结果：#Topic #Consumer Group #InTPS #OutTPS #InMsg24Hour #OutMsg24Hour</span><br><span class="line"></span><br><span class="line">关闭nameserver和所有的broker:</span><br><span class="line"><span class="meta">#</span> sh mqshutdown namesrv</span><br><span class="line"><span class="meta">#</span> sh mqshutdown broker</span><br><span class="line"></span><br><span class="line">查看所有消费组group:</span><br><span class="line"><span class="meta">#</span> sh mqadmin consumerProgress -n 192.168.23.159:9876</span><br><span class="line">查看指定消费组（kevinGroupConsumer）下的所有topic数据堆积情况：</span><br><span class="line"><span class="meta">#</span> sh mqadmin consumerProgress -n 192.168.23.159:9876 -g kevinGroupConsumer</span><br><span class="line">查看所有topic :</span><br><span class="line"><span class="meta">#</span> sh mqadmin topicList -n 192.168.23.159:9876</span><br><span class="line">查看topic信息列表详情统计</span><br><span class="line"><span class="meta">#</span> sh mqadmin topicstatus -n 192.168.23.159:9876 -t myTopicTest1</span><br><span class="line">新增topic</span><br><span class="line"><span class="meta">#</span> sh mqadmin updateTopic –n 10.96.115.40:9876;10.96.83.21:9876 –c TestCluster –t &lt;TopictName&gt;</span><br><span class="line">删除topic</span><br><span class="line"><span class="meta">#</span> sh mqadmin deleteTopic –n 10.45.47.168:9876 –c DefaultCluster –t ZTEExample</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-短连接生成器</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="通过hash算法产生短网址"><a href="#通过hash算法产生短网址" class="headerlink" title="通过hash算法产生短网址"></a>通过hash算法产生短网址</h2><p>要点：</p><ol><li>选择冲撞小、高效的的hash函数，MurmueHash算法。有32bit和128bit，短连接我们可以选择32bits,求原始地址的hashCode</li><li>进一步缩短网址：网址我们一般会采用a-zA-Z0-9等62个字符，我们可以通过除法、并且取模来生成网址，见代码</li><li>解决Hash冲突，将原始地址和短连接地址保存起来（redis or mysql）等，当我们发现短连接已经存在并且和原始地址一致可直接返回，如果存在，且和原始地址不一致我们可以加一些额外字段,比如当前的纳秒数等等作为计算hash的种子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortUrlGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">char</span>[] charArray = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">genaratorCode</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> code = Math.abs(MurmurHash.murmurhash3_x86_32(input, <span class="number">0</span>, input.length(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (code &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//取模</span></span><br><span class="line">            sb.append(charArray[code % charArray.length]);</span><br><span class="line">            <span class="comment">//整除</span></span><br><span class="line">            code = code / charArray.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过自增ID"><a href="#通过自增ID" class="headerlink" title="通过自增ID"></a>通过自增ID</h2><ul><li>对比上面的方式，对于相同的网址，我们会产生不同的短连接，但是会减少判重的次数（数据库的交互）</li><li>自增ID是全局的，肯定要加锁，为了增加并发我们可以同时用多个发号器来解决，类似分库分表的思想。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-微服务路由鉴权和限流</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1%E5%92%8C%E9%89%B4%E6%9D%83/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1%E5%92%8C%E9%89%B4%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><p>按照从大到小的数组排序，用二分法查找时间复杂度大大减少</p><h3 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h3><p>用字典树的方式解决，不过字典树这次是按照分隔符“/”来进行分割，同一级别按照大小顺序进行分组，用俩分法进行匹配</p><h3 id="包含通配符的模糊匹配"><a href="#包含通配符的模糊匹配" class="headerlink" title="包含通配符的模糊匹配"></a>包含通配符的模糊匹配</h3><p>将url分组，没有通配符的优先匹配复杂度O(logn)<br>有通配符的用回溯算法匹配</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-Disruptor背后的秘密</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Disruptor%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%98%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Disruptor是java内存级的消息队列，堪称java中性能最高的队列，在java的并发篇中提到过，本文主要讲解在算法方面是如何做到的。</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>  JAVA原生多采用ArrayBlockingQueue，注：LinkedBlockingQueue无界队列当消费者消费能力不足会导致OOM。<br>  而Disruptor采用的这种方式本质上是循环队列，在插入、删除等不会出现数据的搬移操作。并且所有数据都已经初始化好减少gc的成本</p><h2 id="无锁操作"><a href="#无锁操作" class="headerlink" title="无锁操作"></a>无锁操作</h2><p>  生产时候会去检查是否有空位，如果没有会用cas一直询问，消费时候会去判断队列是否为空，为空就一直判断。</p><h2 id="解决伪缓存"><a href="#解决伪缓存" class="headerlink" title="解决伪缓存"></a>解决伪缓存</h2><p>  不在这里讨论啦：P,用的是缓存填充法。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 高性能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-搜索引擎中的算法和数据结构</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>搜索引擎分为如下四个部分</p><h2 id="爬虫抓取"><a href="#爬虫抓取" class="headerlink" title="爬虫抓取"></a>爬虫抓取</h2><ol><li>利用graph的bfs方式遍历，每个url就是一个vertex,用links.bin作为bfs搜索的队列，这样支持断点续排，并且也能减少内存的使用</li><li>由于网页的量巨大，我们可以用bloomfilter进行排重，这样能减少内存空间，即bloomfilter.bin</li><li>保存原始网页docs_row.bin,格式是docs_id–&gt;docs_content,docs_id由一个中心计数器生成</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>抽取文本信息：去掉网页中的标签等信息 可以理由ac自动机</li><li>创建临时索引：然后对文本进行分词<ol><li>创建tmp_index.bin，格式是：term_id–&gt;doc_id</li><li>创建term_id.bin,格式是：term_id–&gt;term （散列表）</li><li>term_id通过一个中心计数器生成</li></ol></li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ol><li>分析网页，简历倒排索引：即term_id–&gt;doc_id1,doc_id2,doc_id3。由于临时索引很大，我们可以采用多路归并排序（map-reduce）进行归并，index.bin</li><li>记录term在倒排索引偏移量的文档term_offset.bin</li></ol><p>如图：<br><img src="数据结构与算法-搜索引擎中的算法和数据结构/google_idx.jpg" alt="avator"></p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>我们通过上面提到的文件：term_id.bin、term_offset.bin、index.bin、docs_id.bin，</p><ol><li>想通过且此获取k个term</li><li>在通过term_id.bin获取term_id</li><li>在通过term_offset.bin找到索引中对应的doc_id，看那个doc_id出现的次数最多就说明哪个服务客户需要就排在前面</li><li>按照3的顺序在docs_id.bin查找顺序。</li></ol><h2 id="摘要实现原理"><a href="#摘要实现原理" class="headerlink" title="摘要实现原理"></a>摘要实现原理</h2><p>我们在创建临时索引时候可以将摘要和doc_ic以及term_id存入到schema.bin中，需要的时候查询出来。<br>网页快照可以将doc_id–&gt;doc_row用lru的算法存入到shap_shot.bin中。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-Redis中的数据结构</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>  主要介绍下Redis中数据结构相关的知识点，分别是List,Set,SortSet,Hash</p><p>  Redis是内存数据库（也有持久化功能）</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>  zipList:</p><ul><li>保存的单个数据都小于64字节;</li><li><p>存储的元素不超过512个;</p><p>其他情况会采用双向循环链表，优点：便于处理从尾向前遍历，以及方便删除修改操作。</p></li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>  zipList:</p><ul><li>保存的单个数据都小于64字节;</li><li><p>存储的元素不超过512个;</p><p>其他情况会采用散列表，默认情况下装载因子大于1时候会进行库容，小于0.1时候会进行缩容，扩容方案采用延迟扩容的方案</p></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>  有序数组:</p><ul><li>保存的单个数据都是整数；</li><li><p>存储的元素不超过512个;</p><p>其他情况会采用散列表</p></li></ul><h2 id="SortSet"><a href="#SortSet" class="headerlink" title="SortSet"></a>SortSet</h2><p>  zipList:</p><ul><li>保存的单个数据都小于64字节;</li><li><p>存储的元素不超过128个;</p><p>其他情况会采用跳表+Dict</p></li></ul><h2 id="zipList解释"><a href="#zipList解释" class="headerlink" title="zipList解释"></a>zipList解释</h2><p>是加强版的数组，和数组相比：支持多种数据格式，且每个元素的长度可以不一致。比数组更节省内存的空间。redis在数据量小的时候会采用这种方案取代其他的数据结构，相当于用时间换空间，毕竟redis是内存数据库，在内存的使用上是很敏感的:P</p><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><p>redis在磁盘存储时候会去掉原有的数据结构，以便于节省磁盘空间，当需要将数据加载到内存中时候会还原原有的数据结构。（缺点是加载时间比较长，由于redis是内存级数据库所以这点损耗可接受）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-如何利用并行来提高算法效率</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%9D%A5%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%B9%B6%E8%A1%8C%E6%9D%A5%E6%8F%90%E9%AB%98%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87/</url>
      
        <content type="html"><![CDATA[<p>算法优化是有极限的比如说常见的三种O(NlogN)：快排、归并、堆排序。在算法上我们几乎没有优化的空间，但是在执行效率上我们可以利用计算机的并发来提高执行效率</p><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><ul><li>归并排序：可以将数据分成均分N组，然后每组并发的进行归并排序，最后在对这些数据进行合并。</li><li>快速排序：可以先扫描一遍数据，将数据按从小到大分别分到N个曹中，对应N个线程并发排序，排好即可</li></ul><p>归并排序是先排序，后归并；快排是先分组，在排序。</p><h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p>在用散列表构建索引时候，当散列过了负载因子阈值时候会进行扩容，如果是一个大的散列表会浪费许多资源。同时也没法通过并行提高查找效率。我们可以将散列表分成N个小散列表在查找时候去N个散列表中一起查找，同时也支持对单个散列表进行扩容和缩容。</p><h2 id="并行匹配字符串"><a href="#并行匹配字符串" class="headerlink" title="并行匹配字符串"></a>并行匹配字符串</h2><p>模式串是M</p><ul><li>对于一个大文本，我们可以将文本拆分为N个小文本。用N个线程并发查找。</li><li>由于有可能俩个小文本结尾会把模式串切分开了，我们要对每个小文本特殊处理，也就是将没个小文本的末尾M个字符和下一个文本的开头M个字符连起来2M个长度在进行匹配</li></ul><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>在图的BFS搜索的问题上，我们用一个队列来进行层层搜索，我们可以采用俩个队列A、B，多线程并发处理A将扩展队列放到B中，当A空后在处理B，如此循环。</p><p>Map-Reduce实际上就是并行处理框架</p><h2 id="衍生问题"><a href="#衍生问题" class="headerlink" title="衍生问题"></a>衍生问题</h2><p>上面提到的都是没有依赖的任务，针对有依赖的任务我们可以进行touple排序，没个依赖用一个线程并发去执行。（有依赖就进行拓扑排序）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-Mysql的索引B+树-以及索引数据结构的选型</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Mysql%E7%9A%84%E7%B4%A2%E5%BC%95B-%E6%A0%91/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-Mysql%E7%9A%84%E7%B4%A2%E5%BC%95B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>Mysql的索引采用B+tree的结构，因为索引需要自持范围查寻、等值查询，支持快速的添加、删除，且时间复杂度不能太高，同时占用的空间不能太大。</p><h2 id="b-tree做索引的实现原理"><a href="#b-tree做索引的实现原理" class="headerlink" title="b+tree做索引的实现原理"></a>b+tree做索引的实现原理</h2><p>  查询</p><ol><li>保存在文件中，采用时间换空间的思路，支持大的索引;</li><li>由于节点在磁盘中，每次访问节点都需要一次磁盘的IO，所以b+tree是多叉树，有效降低了树的高度，极大减小了磁盘IO的次数提高了性能;</li><li>b+tree每个节点的大小都对应一个内存的PAGE_SIZE,保证每次加载只有一次磁盘IO</li><li><p>b+tree只保存索引所以，叶子节点由链表串联起来，所以支持范围查找，并且修改值不用改动索引，且索引很小。</p><p>添加:添加如果节点超过了Page容纳的范围，就将原有节点分裂成俩个不同的节点，逐层向父级分裂知道满足需求<br>删除：设置一个阈值，如果b+tree节点数量小于阈值就进行合并，如果合并后节点数超过PAGE_SIZE在和添加一样进行分裂</p></li></ol><h2 id="b-tree和b-tree的区别"><a href="#b-tree和b-tree的区别" class="headerlink" title="b+tree和b-tree的区别"></a>b+tree和b-tree的区别</h2><ol><li>b+tree的节点保存索引，btree保存值。</li><li>b+tree的叶子节点由链表串联起来。</li></ol><h2 id="索引的选型"><a href="#索引的选型" class="headerlink" title="索引的选型"></a>索引的选型</h2><p>索引是所有的数据存储系统的关键，直接关乎查询的效率，常用的适合做索引的数据结构有：</p><ul><li>散列表：查询修改复杂度都是O(1),适合nosql的存储，如redis，memcached等，大部分索引都在内存中</li><li>红黑树：适合做文件系统的索引，插入、修改、查询的事件复杂度都是O(LogN)，也适合构建内存索引</li><li>B+tree：适合构建磁盘索引，如mysql等</li><li>还有布隆过滤器、位图等：虽然有误判，但是我们可以选择他做二级索引，因为索引很小，且效率很高，判断下数据是否存在，如果返回存在在调用其他索引查找。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-利用向量实现推荐系统</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%A9%E7%94%A8%E5%90%91%E9%87%8F%E5%AE%9E%E7%8E%B0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%A9%E7%94%A8%E5%90%91%E9%87%8F%E5%AE%9E%E7%8E%B0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>实现音乐推荐系统算法模块的思路：</p><ol><li>找到和你口味的相近的人，把他听的歌曲推荐给你</li><li>找到和你听的歌曲个特征相似的跟去，把这些歌曲推荐给你</li></ol><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>向量的欧几里得距离</p><p><img src="/数据结构与算法-利用向量实现推荐系统/img1.jpg" alt="avator"></p><h3 id="基于相似口味的人"><a href="#基于相似口味的人" class="headerlink" title="基于相似口味的人"></a>基于相似口味的人</h3><ul><li>把听过的某首歌看为是一个向量</li><li>把听过的歌进行打标（收藏、听、分享、不喜欢）计算每一首歌的向量值;</li><li>然后遍历所有的用户，计算向量的欧几里得距离，设定一个阈值，小于这个阈值的说明口味相近，我们将用户没听过的歌推荐给用户</li></ul><h3 id="基于喜欢的歌曲进行推荐"><a href="#基于喜欢的歌曲进行推荐" class="headerlink" title="基于喜欢的歌曲进行推荐"></a>基于喜欢的歌曲进行推荐</h3><ul><li>用户对于喜欢听的歌曲的成都进行标记</li><li>遍历所有歌曲，计算向量的欧几里得距离，设定一个阈值，小于这个阈值的说明歌曲受欢迎程度相似可以进行推荐。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-如何过滤垃圾短信-朴素贝叶斯算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A6%82%E4%BD%95%E8%BF%87%E6%BB%A4%E5%9E%83%E5%9C%BE%E7%9F%AD%E4%BF%A1-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有一下3中过滤方式</p><h2 id="基于黑名单规律"><a href="#基于黑名单规律" class="headerlink" title="基于黑名单规律"></a>基于黑名单规律</h2><p>可以制作手机号码的黑名单：</p><ol><li>利用bloomfiter来过滤手机黑名单，可能会有误判的可能</li><li>将黑名单方法服务器，利用时间换空间</li></ol><h2 id="基于规则过滤"><a href="#基于规则过滤" class="headerlink" title="基于规则过滤"></a>基于规则过滤</h2><p>可以将垃圾短信的样本中出现的词进行整理，计算他们是垃圾短信的概率和不是垃圾短信的概率如果一个单词是垃圾短信的概率远远大于非垃圾短信的概率说明它是垃圾短信的词语。</p><h2 id="基于概率过滤"><a href="#基于概率过滤" class="headerlink" title="基于概率过滤"></a>基于概率过滤</h2><p>利用朴素贝叶斯算法，计算词语和垃圾短信的关系</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 应用篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 算法应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-bitMap和bloomFilter</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-bitMap%E5%92%8CbloomFilter/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-bitMap%E5%92%8CbloomFilter/</url>
      
        <content type="html"><![CDATA[<p>考虑如下需求:</p><ul><li>爬虫对于大量的URL进行排重</li><li>统计网站的UV;</li><li>对1到1亿的数据进行排序</li></ul><h2 id="位图的使用场景"><a href="#位图的使用场景" class="headerlink" title="位图的使用场景"></a>位图的使用场景</h2><p>如果我们要存储1到1亿个数字，支持排重该如何做呢，可以采用位图。见下面的代码，用位图会极大的节省查找、插入的效率.一次位运算即可，同时也极大的节省了内存空间，现在只许愿1亿个2进制，即12MB左右。如果用散列表至少需要40MB。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int类型的位图下标是4个字节即32bit</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> total)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="keyword">int</span>[total / <span class="number">32</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找到数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = value / <span class="number">32</span>;</span><br><span class="line">        <span class="comment">//通过摩运算找到偏移量</span></span><br><span class="line">        <span class="keyword">int</span> bit = value % <span class="number">32</span>;</span><br><span class="line">        <span class="comment">//通过位运算|找到值</span></span><br><span class="line">        bytes[index] |= <span class="number">1</span> &lt;&lt; bit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; total) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = value / <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> bit = value % <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">return</span> (bytes[index] &amp; <span class="number">1</span> &lt;&lt; bit) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bloomfilter"><a href="#bloomfilter" class="headerlink" title="bloomfilter"></a>bloomfilter</h2><p>  接上面的问题，如果数字的值不多，但是范围很大，比如1亿个数字但是范围是1到10亿，这时候我们的存储空间变成了120MB，不降反升，我们该如何存储呢？这时候就要借用bloomfilter了。</p><p>  boolmfilter底层还是bitMap，大小还可以设置为1亿。在介绍hash散列时候我们遇到hash冲突采用链表来解决hash冲突。在这里我们采用多个hash函数。<br>  比如：</p><ul><li>我们对一个值用h1,h2,h3……hn，分别将值写入到v1,v2,v3…..vn中。</li><li>查询时候我们分别判断如果h1~hn都为true，返回true,只要有一个为false，就返回false</li><li><p>缺点：</p><ul><li>存在误判的情况，随着bloomfilter里1的值越来越多，误判率会加大，最好支持扩容;</li><li>删除会很麻烦;</li></ul><p>开头提到的问题：我们可以采用10倍的bloomfilter存储url，同时进行排重</p></li></ul><h2 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h2><ol><li>假设我们有1亿个整数，数据范围是从1到10亿，进行排序;</li><li>海量图库的排重;</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((bytes[i] &amp; (<span class="number">1</span> &lt;&lt; j)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.print((i*<span class="number">32</span>+j) + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="bitmap在语言中的应用"><a href="#bitmap在语言中的应用" class="headerlink" title="bitmap在语言中的应用"></a>bitmap在语言中的应用</h2><p>java的中bitSet<br>google库guava中的BloomFilter的实现类</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-todo</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-todo/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-todo/</url>
      
        <content type="html"><![CDATA[<p>记录我暂时不感兴趣或者我看不懂的</p><ul><li>最短路径算法。暂时不想看：小顶堆+</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> todo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq源码学习-负载均衡的处理</title>
      <link href="RocketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>RocketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>rocketmq对负载均衡的处理</p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><h3 id="broker发起"><a href="#broker发起" class="headerlink" title="broker发起"></a>broker发起</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRegisterBrokerAll</span><span class="params">(<span class="keyword">boolean</span> checkOrderConfig, <span class="keyword">boolean</span> oneway,</span></span></span><br><span class="line"><span class="function"><span class="params">    TopicConfigSerializeWrapper topicConfigWrapper)</span> </span>&#123;</span><br><span class="line">    List&lt;RegisterBrokerResult&gt; registerBrokerResultList = <span class="keyword">this</span>.brokerOuterAPI.registerBrokerAll(</span><br><span class="line">        <span class="keyword">this</span>.brokerConfig.getBrokerClusterName(),</span><br><span class="line">        <span class="keyword">this</span>.getBrokerAddr(),</span><br><span class="line">        <span class="keyword">this</span>.brokerConfig.getBrokerName(),</span><br><span class="line">        <span class="keyword">this</span>.brokerConfig.getBrokerId(),</span><br><span class="line">        <span class="keyword">this</span>.getHAServerAddr(),</span><br><span class="line">        topicConfigWrapper,</span><br><span class="line">        <span class="keyword">this</span>.filterServerManager.buildNewFilterServerList(),</span><br><span class="line">        oneway,</span><br><span class="line">        <span class="keyword">this</span>.brokerConfig.getRegisterBrokerTimeoutMills(),</span><br><span class="line">        <span class="keyword">this</span>.brokerConfig.isCompressedRegister());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步方法</span></span><br><span class="line">    <span class="keyword">if</span> (registerBrokerResultList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RegisterBrokerResult registerBrokerResult = registerBrokerResultList.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (registerBrokerResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.updateMasterHAServerAddrPeriodically &amp;&amp; registerBrokerResult.getHaServerAddr() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.messageStore.updateHaMasterAddress(registerBrokerResult.getHaServerAddr());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.slaveSynchronize.setMasterAddr(registerBrokerResult.getMasterAddr());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (checkOrderConfig) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getTopicConfigManager().updateOrderTopicConfig(registerBrokerResult.getKvTable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用brokerOutApi的registerBrokerAll方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;RegisterBrokerResult&gt; <span class="title">registerBrokerAll</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> oneway,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">int</span> timeoutMills,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> <span class="keyword">boolean</span> compressed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;RegisterBrokerResult&gt; registerBrokerResultList = Lists.newArrayList();</span><br><span class="line">    List&lt;String&gt; nameServerAddressList = <span class="keyword">this</span>.remotingClient.getNameServerAddressList();</span><br><span class="line">    <span class="keyword">if</span> (nameServerAddressList != <span class="keyword">null</span> &amp;&amp; nameServerAddressList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//关键向nameServer发送RegisterBrokerRequestHeader请求</span></span><br><span class="line">        <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader = <span class="keyword">new</span> RegisterBrokerRequestHeader();</span><br><span class="line">        requestHeader.setBrokerAddr(brokerAddr);</span><br><span class="line">        requestHeader.setBrokerId(brokerId);</span><br><span class="line">        requestHeader.setBrokerName(brokerName);</span><br><span class="line">        requestHeader.setClusterName(clusterName);</span><br><span class="line">        requestHeader.setHaServerAddr(haServerAddr);</span><br><span class="line">        requestHeader.setCompressed(compressed);</span><br><span class="line"></span><br><span class="line">        RegisterBrokerBody requestBody = <span class="keyword">new</span> RegisterBrokerBody();</span><br><span class="line">        requestBody.setTopicConfigSerializeWrapper(topicConfigWrapper);</span><br><span class="line">        requestBody.setFilterServerList(filterServerList);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] body = requestBody.encode(compressed);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bodyCrc32 = UtilAll.crc32(body);</span><br><span class="line">        requestHeader.setBodyCrc32(bodyCrc32);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(nameServerAddressList.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> String namesrvAddr : nameServerAddressList) &#123;</span><br><span class="line">            brokerOuterExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//封装发送逻辑--&gt;这里向nameServer发送</span></span><br><span class="line">                        RegisterBrokerResult result = registerBroker(namesrvAddr,oneway, timeoutMills,requestHeader,body);</span><br><span class="line">                        <span class="comment">//更新注册结果</span></span><br><span class="line">                        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            registerBrokerResultList.add(result);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        log.info(<span class="string">"register broker to name server &#123;&#125; OK"</span>, namesrvAddr);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.warn(<span class="string">"registerBroker Exception, &#123;&#125;"</span>, namesrvAddr, e);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        countDownLatch.countDown();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await(timeoutMills, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registerBrokerResultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NameServ的处理"><a href="#NameServ的处理" class="headerlink" title="NameServ的处理"></a>NameServ的处理</h3><p>在DefaultRequestProcessor中processRequest方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">            <span class="keyword">case</span> RequestCode.REGISTER_BROKER:</span><br><span class="line">                Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">                <span class="keyword">if</span> (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.registerBroker(ctx, request);</span><br><span class="line">                &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>registerBoker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">registerBroker</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">    RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(RegisterBrokerResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerResponseHeader responseHeader = (RegisterBrokerResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> RegisterBrokerRequestHeader requestHeader =</span><br><span class="line">        (RegisterBrokerRequestHeader) request.decodeCommandCustomHeader(RegisterBrokerRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到TopicConfigSerializeWrapper</span></span><br><span class="line">    TopicConfigSerializeWrapper topicConfigWrapper;</span><br><span class="line">    <span class="keyword">if</span> (request.getBody() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        topicConfigWrapper = TopicConfigSerializeWrapper.decode(request.getBody(), TopicConfigSerializeWrapper.class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        topicConfigWrapper = <span class="keyword">new</span> TopicConfigSerializeWrapper();</span><br><span class="line">        topicConfigWrapper.getDataVersion().setCounter(<span class="keyword">new</span> AtomicLong(<span class="number">0</span>));</span><br><span class="line">        topicConfigWrapper.getDataVersion().setTimestamp(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键方法</span></span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().registerBroker(</span><br><span class="line">        requestHeader.getClusterName(),</span><br><span class="line">        requestHeader.getBrokerAddr(),</span><br><span class="line">        requestHeader.getBrokerName(),</span><br><span class="line">        requestHeader.getBrokerId(),</span><br><span class="line">        requestHeader.getHaServerAddr(),</span><br><span class="line">        topicConfigWrapper,</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        ctx.channel()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装response结构</span></span><br><span class="line">    responseHeader.setHaServerAddr(result.getHaServerAddr());</span><br><span class="line">    responseHeader.setMasterAddr(result.getMasterAddr());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] jsonValue = <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVListByNamespace(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG);</span><br><span class="line">    response.setBody(jsonValue);</span><br><span class="line">    response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">    response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RouteInfoManager"><a href="#RouteInfoManager" class="headerlink" title="RouteInfoManager"></a>RouteInfoManager</h3><p>broker和topic的路由信息管理者,重要属性如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">//每个topic对应【Master】Broker的队列信息读队列、写队列、名称信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable;</span><br><span class="line">    <span class="comment">//Broker的信息，包含了borker的id,地址等，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable;</span><br><span class="line">    <span class="comment">//集群和broker的对应关系</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>调用RouteInfoManager的registerBroker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RegisterBrokerResult <span class="title">registerBroker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Channel channel)</span> </span>&#123;</span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">new</span> RegisterBrokerResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新本地的Cluster--&gt;brokerNames</span></span><br><span class="line">            Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">                <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">            &#125;</span><br><span class="line">            brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新rokerData（brokerName--&gt;brokerData）</span></span><br><span class="line">            BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                registerFirst = <span class="keyword">true</span>;</span><br><span class="line">                brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line">                <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">            &#125;</span><br><span class="line">            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">            registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Broker是Master更新topicQueueTable</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                    &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                <span class="comment">//有变化或者是第一次注册</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                        || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                            topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                    <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步和过滤</span></span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                    <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                            System.currentTimeMillis(),</span><br><span class="line">                            topicConfigWrapper.getDataVersion(),</span><br><span class="line">                            channel,</span><br><span class="line">                            haServerAddr));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(<span class="string">"new broker registered, &#123;&#125; HAServer: &#123;&#125;"</span>, brokerAddr, haServerAddr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line">                    <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                        result.setMasterAddr(masterAddr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"registerBroker Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键方法：createAndUpdateQueueData</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册Broker时候</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createAndUpdateQueueData</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> TopicConfig topicConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成队列信息，对于统一个topic来说每个msterbroker对应一个QueueData</span></span><br><span class="line">    QueueData queueData = <span class="keyword">new</span> QueueData();</span><br><span class="line">    queueData.setBrokerName(brokerName);</span><br><span class="line">    queueData.setWriteQueueNums(topicConfig.getWriteQueueNums());</span><br><span class="line">    queueData.setReadQueueNums(topicConfig.getReadQueueNums());</span><br><span class="line">    queueData.setPerm(topicConfig.getPerm());</span><br><span class="line">    queueData.setTopicSynFlag(topicConfig.getTopicSysFlag());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//topic--&gt;多个Broker,所以有多个QueueData</span></span><br><span class="line">    List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topicConfig.getTopicName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == queueDataList) &#123;</span><br><span class="line">        queueDataList = <span class="keyword">new</span> LinkedList&lt;QueueData&gt;();</span><br><span class="line">        queueDataList.add(queueData);</span><br><span class="line">        <span class="keyword">this</span>.topicQueueTable.put(topicConfig.getTopicName(), queueDataList);</span><br><span class="line">        log.info(<span class="string">"new topic registered, &#123;&#125; &#123;&#125;"</span>, topicConfig.getTopicName(), queueData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> addNewOne = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            QueueData qd = it.next();</span><br><span class="line">            <span class="keyword">if</span> (qd.getBrokerName().equals(brokerName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (qd.equals(queueData)) &#123;</span><br><span class="line">                    addNewOne = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">"topic changed, &#123;&#125; OLD: &#123;&#125; NEW: &#123;&#125;"</span>, topicConfig.getTopicName(), qd,</span><br><span class="line">                            queueData);</span><br><span class="line">                    it.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addNewOne) &#123;</span><br><span class="line">            queueDataList.add(queueData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Producer负载均衡"><a href="#Producer负载均衡" class="headerlink" title="Producer负载均衡"></a>Producer负载均衡</h2><h3 id="DefaultMQProducerImpl"><a href="#DefaultMQProducerImpl" class="headerlink" title="DefaultMQProducerImpl"></a>DefaultMQProducerImpl</h3><p>发送消息和负载均衡相关的逻辑是：</p><p>  先通过topicPublishInfo选择一个MessageQueue；<br>  调用DefaultMQProducerImpl#sendKernelImpl，在之前发送消息前会调用findBrokerAddressInPublish方法根据mq.getBrokerName来从本地内存获取brokerAddr，见下面代码，如果不存在会调用，tryToFindTopicPublishInfo方法来重新加载brokerAddrTable和topicPublishInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendKernelImpl</span><span class="params">(<span class="keyword">final</span> Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> MessageQueue mq,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> CommunicationMode communicationMode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> SendCallback sendCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> TopicPublishInfo topicPublishInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> <span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> MQClientException, RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> beginStartTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//得到BrokerAddr，没有在更新topic</span></span><br><span class="line">    String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">        tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">        brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryToFindTopicPublishInfo方法获取TopicPublishInfo，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">//没有或者messageQueueList为空去nameserv获取</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateTopicRouteInfoFromNameServer方法中去nameServ获取TopicRouteData，并且将TopicRouteData转成TopicPublishInfo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateTopicRouteInfoFromNameServer</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">boolean</span> isDefault,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  DefaultMQProducer defaultMQProducer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取路由信息</span></span><br><span class="line">                TopicRouteData topicRouteData;</span><br><span class="line">                <span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//发送RequestCode为GET_ROUTEINTO_BY_TOPIC的请求获取topicRouteData</span></span><br><span class="line">                    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">                            <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">                            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">                            data.setReadQueueNums(queueNums);</span><br><span class="line">                            data.setWriteQueueNums(queueNums);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="comment">//如果发生改变将TopicRouteData转成TopicPublishInfo 和 subscribeInfo 更新</span></span><br><span class="line">                    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                        TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line">                        <span class="comment">//重点 本地维护BorkerName--&gt;bd.getBrokerAddrs()</span></span><br><span class="line">                        <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// Update Pub info</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//转换</span></span><br><span class="line">                            TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">                            publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">                            Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line">                            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                                Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">                                MQProducerInner impl = entry.getValue();</span><br><span class="line">                                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    impl.updateTopicPublishInfo(topic, publishInfo);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Update sub info</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            Set&lt;MessageQueue&gt; subscribeInfo = topicRouteData2TopicSubscribeInfo(topic, topicRouteData);</span><br><span class="line">                            Iterator&lt;Entry&lt;String, MQConsumerInner&gt;&gt; it = <span class="keyword">this</span>.consumerTable.entrySet().iterator();</span><br><span class="line">                            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                                Entry&lt;String, MQConsumerInner&gt; entry = it.next();</span><br><span class="line">                                MQConsumerInner impl = entry.getValue();</span><br><span class="line">                                <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    impl.updateTopicSubscribeInfo(topic, subscribeInfo);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">this</span>.topicRouteTable.put(topic, cloneTopicRouteData);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.warn(<span class="string">"updateTopicRouteInfoFromNameServer, getTopicRouteInfoFromNameServer return null, Topic: &#123;&#125;"</span>, topic);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX) &amp;&amp; !topic.equals(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)) &#123;</span><br><span class="line">                    log.warn(<span class="string">"updateTopicRouteInfoFromNameServer Exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.lockNamesrv.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.warn(<span class="string">"updateTopicRouteInfoFromNameServer tryLock timeout &#123;&#125;ms"</span>, LOCK_TIMEOUT_MILLIS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"updateTopicRouteInfoFromNameServer Exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NameServer收到GET-ROUTEINTO-BY-TOPIC请求的处理"><a href="#NameServer收到GET-ROUTEINTO-BY-TOPIC请求的处理" class="headerlink" title="NameServer收到GET_ROUTEINTO_BY_TOPIC请求的处理"></a>NameServer收到GET_ROUTEINTO_BY_TOPIC请求的处理</h3><p>DefaultRequestProcessor中的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> RequestCode.GET_ROUTEINTO_BY_TOPIC:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getRouteInfoByTopic(ctx, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RemotingCommand <span class="title">getRouteInfoByTopic</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">        RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> GetRouteInfoRequestHeader requestHeader =</span><br><span class="line">            (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关键代码</span></span><br><span class="line">        TopicRouteData topicRouteData = <span class="keyword">this</span>.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.namesrvController.getNamesrvConfig().isOrderMessageEnable()) &#123;</span><br><span class="line">                String orderTopicConf =</span><br><span class="line">                    <span class="keyword">this</span>.namesrvController.getKvConfigManager().getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG,</span><br><span class="line">                        requestHeader.getTopic());</span><br><span class="line">                topicRouteData.setOrderTopicConf(orderTopicConf);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] content = topicRouteData.encode();</span><br><span class="line">            response.setBody(content);</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.setCode(ResponseCode.TOPIC_NOT_EXIST);</span><br><span class="line">        response.setRemark(<span class="string">"No topic route info in name server for the topic: "</span> + requestHeader.getTopic()</span><br><span class="line">            + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="RouteInfoManager-pickupTopicRouteData"><a href="#RouteInfoManager-pickupTopicRouteData" class="headerlink" title="RouteInfoManager#pickupTopicRouteData"></a>RouteInfoManager#pickupTopicRouteData</h3><p>关键方法pickupTopicRouteData，通过上述broker的注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TopicRouteData <span class="title">pickupTopicRouteData</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">     TopicRouteData topicRouteData = <span class="keyword">new</span> TopicRouteData();</span><br><span class="line">     <span class="keyword">boolean</span> foundQueueData = <span class="keyword">false</span>;</span><br><span class="line">     <span class="keyword">boolean</span> foundBrokerData = <span class="keyword">false</span>;</span><br><span class="line">     Set&lt;String&gt; brokerNameSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">     List&lt;BrokerData&gt; brokerDataList = <span class="keyword">new</span> LinkedList&lt;BrokerData&gt;();</span><br><span class="line">     topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">     HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">     topicRouteData.setFilterServerTable(filterServerMap);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.lock.readLock().lockInterruptibly();</span><br><span class="line">             <span class="comment">//从topicQueueTable获取的queueDataList（注册broker时候每个topic的Master的Broker对应一个QueueData）</span></span><br><span class="line">             List&lt;QueueData&gt; queueDataList = <span class="keyword">this</span>.topicQueueTable.get(topic);</span><br><span class="line">             <span class="keyword">if</span> (queueDataList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                 foundQueueData = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                 Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                 <span class="comment">//遍历queuData，生成brokerNameSet</span></span><br><span class="line">                 <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                     QueueData qd = it.next();</span><br><span class="line">                     brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//遍历 组装brokerDataList</span></span><br><span class="line">                 <span class="keyword">for</span> (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                     BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line">                     <span class="keyword">if</span> (<span class="keyword">null</span> != brokerData) &#123;</span><br><span class="line">                         BrokerData brokerDataClone = <span class="keyword">new</span> BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData</span><br><span class="line">                                 .getBrokerAddrs().clone());</span><br><span class="line">                         brokerDataList.add(brokerDataClone);</span><br><span class="line">                         foundBrokerData = <span class="keyword">true</span>;</span><br><span class="line">                         <span class="keyword">for</span> (<span class="keyword">final</span> String brokerAddr : brokerDataClone.getBrokerAddrs().values()) &#123;</span><br><span class="line">                             List&lt;String&gt; filterServerList = <span class="keyword">this</span>.filterServerTable.get(brokerAddr);</span><br><span class="line">                             filterServerMap.put(brokerAddr, filterServerList);</span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">this</span>.lock.readLock().unlock();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">"pickupTopicRouteData Exception"</span>, e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     log.debug(<span class="string">"pickupTopicRouteData &#123;&#125; &#123;&#125;"</span>, topic, topicRouteData);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">         <span class="keyword">return</span> topicRouteData;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><p>todo</p><h2 id="TopicPublishInfo和TopicRouteData"><a href="#TopicPublishInfo和TopicRouteData" class="headerlink" title="TopicPublishInfo和TopicRouteData"></a>TopicPublishInfo和TopicRouteData</h2><p>todo 补充consumer</p><p>TopicRouteData保存整个broker的路由信息，通过TopicRouteData转换成TopicPublishInfo。重要属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * topic排序的配置</span></span><br><span class="line"><span class="comment"> * 和"ORDER_TOPIC_CONFIG"这个NameSpace有关</span></span><br><span class="line"><span class="comment"> * 参照DefaultRequestProcessor#getRouteInfoByTopic</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String orderTopicConf;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个topic对应存储的位置,可参照RouteInfoManager.topicQueueTable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个topic对应的brokerDatas集合(可以根据queueDatas得到，参照RouteInfoManager#pickupTopicRouteData)</span></span><br><span class="line"><span class="comment"> * brokerDatas来源于queueDatas</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个brokerAddr对应的过滤Server地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><p>TopicPublishInfo保存了Producer的队列信息，用于发送消息的负载均衡即选择MessageQueue。重要属性如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//messageQueues</span></span><br><span class="line"><span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"><span class="comment">//用于选择队列用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();</span><br><span class="line"></span><br><span class="line"><span class="comment">//nameserver中的topicRouteData</span></span><br><span class="line"><span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-拓扑排序</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="初始化以及原理"><a href="#初始化以及原理" class="headerlink" title="初始化以及原理"></a>初始化以及原理</h2><p>拓扑排序基于一个有向无环图构成，当B依赖A，A先B执行的时候，我们画一条A–&gt;B的边。如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt;[] adj;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        adj[s].add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>有俩种排序算法Kahn算法</p><h3 id="Kahn排序"><a href="#Kahn排序" class="headerlink" title="Kahn排序"></a>Kahn排序</h3><p>采用贪心算法思想。</p><ul><li>因为图的关系A–&gt;B，A先执行，所以我们统计每个顶点的入度，凡是入度为0的说明没有依赖应该他先执行;</li><li>将顶点放到结果执行序列后。将该顶点从图中删除，即该顶点所到达的顶点的入度都-1，如果到0放到执行结果集中;</li><li>重复上一步直到所有的顶点都在执行序列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计入度</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); j++) &#123;</span><br><span class="line"><span class="comment">//              i先执行于j,j依赖i，统计j的入度w，等于统计j有多少前置依赖</span></span><br><span class="line">                <span class="keyword">int</span> w = adj[i].get(j);</span><br><span class="line">                indegree[w]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列，先执行的先放入队列中</span></span><br><span class="line">        Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; queueMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行结果序列</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queueMap.put(i, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">                queueMap.get(i).add(i);</span><br><span class="line">                result.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历队列</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; queue : queueMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//循环放入执行队列</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.getValue().isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//入度为0的顶点出队，放入到结果执行序列中</span></span><br><span class="line">                <span class="keyword">int</span> v = queue.getValue().remove();</span><br><span class="line">                result.get(queue.getKey()).add(v);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[v].size(); j++) &#123;</span><br><span class="line">                    <span class="comment">//将当前顶点到达的顶点入度--,等价于删除顶点。</span></span><br><span class="line">                    <span class="keyword">int</span> k = adj[v].get(j);</span><br><span class="line">                    indegree[k]--;</span><br><span class="line">                    <span class="comment">//如果这个顶点的入度为0将其放到到执行序列中重复知道队列为空</span></span><br><span class="line">                    <span class="keyword">if</span> (indegree[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        queue.getValue().add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; ret : result.values()) &#123;</span><br><span class="line">            System.out.print(ret);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>采用图的深度遍历法</p><ul><li>制造逆邻接表</li><li>遍历所有的顶点，如果遇到</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造逆邻接表</span></span><br><span class="line">    LinkedList&lt;Integer&gt;[] inverseAdj = <span class="keyword">new</span> LinkedList[adj.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">        inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j);</span><br><span class="line">            inverseAdj[w].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度遍历，遍历所有的顶点，从第一个顶点开始处理</span></span><br><span class="line">    Map&lt;Integer, Boolean&gt; visted = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visted.get(i) == <span class="keyword">null</span> || !visted.get(i)) &#123;</span><br><span class="line">            visted.put(i, <span class="keyword">true</span>);</span><br><span class="line">            dfs(i, inverseAdj, visted);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归深度遍历图</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v, LinkedList&lt;Integer&gt;[] inverseAdj, Map&lt;Integer, Boolean&gt; visted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inverseAdj[v].size(); j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = inverseAdj[v].get(j);</span><br><span class="line">        <span class="keyword">if</span> (visted.get(w) != <span class="keyword">null</span> &amp;&amp; visted.get(w)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visted.put(w, <span class="keyword">true</span>);</span><br><span class="line">        dfs(w, inverseAdj, visted);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后da</span></span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>kahn复杂度是O(v+e),所有的顶点和边都访问了一次<br>dfs复杂度是O(v+e),所有的顶点和边都访问了一次</p><h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>  如果A先于B执行我们的边是 A–&gt;B，反过来A&lt;–B，代码是否能正常执行？<br>  答：不能，结果相反的结果，kahn：在算法中A–&gt;B所以A的入度为0，这个入度为0很类似哨兵一样的机制，可以很方便的计入到执行结果中，并且可以一次减少入度。反之，我们入度为0的就变成了最后的数组，如果修改，需要统计出度凡是从出度为0的就是没有依赖的最先执行的，同时简历逆邻接表，在打印完出度为0的数据后在逆邻接表中循环递减出度同时输出,见下方代码。DFS:这个很简单，接别用逆邻接表了。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计出度</span></span><br><span class="line">    <span class="keyword">int</span>[] outdegree = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    LinkedList&lt;Integer&gt;[] inverseList = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; i++) &#123;</span><br><span class="line">        inverseList[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj.length; i++) &#123;</span><br><span class="line">        outdegree[i] = adj[i].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j : adj[i]) &#123;</span><br><span class="line">                inverseList[j].addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列，先执行的先放入队列中</span></span><br><span class="line">    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; queueMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行结果序列</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outdegree.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (outdegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queueMap.put(i, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            queueMap.get(i).add(i);</span><br><span class="line">            result.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历队列</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; queue : queueMap.entrySet()) &#123;</span><br><span class="line">        <span class="comment">//循环放入执行队列</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.getValue().isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//入度为0的顶点出队，放入到结果执行序列中</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.getValue().remove();</span><br><span class="line">            result.get(queue.getKey()).add(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; inverseList[v].size(); j++) &#123;</span><br><span class="line">                <span class="comment">//将当前顶点到达的顶点入度--,等价于删除顶点。</span></span><br><span class="line">                <span class="keyword">int</span> k = inverseList[v].get(j);</span><br><span class="line">                outdegree[k]--;</span><br><span class="line">                <span class="comment">//如果这个顶点的入度为0将其放到到执行序列中重复知道队列为空</span></span><br><span class="line">                <span class="keyword">if</span> (outdegree[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.getValue().add(k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; ret : result.values()) &#123;</span><br><span class="line">        System.out.print(ret);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
          <category> 高级篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RoketMq源码学习-可用性研究</title>
      <link href="RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E7%94%A8%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
      <url>RoketMq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-%E5%8F%AF%E7%94%A8%E6%80%A7%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>消息发送中用到了MQFaultStrategy来保证系统的稳定性，代码在包org.apache.rocketmq.client.latency中，其主要是通过LatencyFaultToleranceImpl来保证Broker的可用性的</p><h2 id="MQFaultStrategy"><a href="#MQFaultStrategy" class="headerlink" title="MQFaultStrategy"></a>MQFaultStrategy</h2><p>主要成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟容错对象，维护延迟Brokers的信息</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class="keyword">new</span> LatencyFaultToleranceImpl();</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟容错开关</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> sendLatencyFaultEnable = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟级别数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可用时长数组 对应latencyMax如果花费时间大于latencyMax[i],则不可用时间为notAvailableDuration[i]</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="selectOneMessageQueue"><a href="#selectOneMessageQueue" class="headerlink" title="selectOneMessageQueue"></a>selectOneMessageQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逻辑如下：</span></span><br><span class="line"><span class="comment"> * 如果时延开关打开</span></span><br><span class="line"><span class="comment"> * 1.选择一个队列，该mq的broker没在时延对列中返回</span></span><br><span class="line"><span class="comment"> * 2.如果在时延对列中，找一个相对较好的不考虑可用性返回</span></span><br><span class="line"><span class="comment"> * 3.不考虑可用性，选择一个返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> TopicPublishInfo tpInfo, <span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//启用延迟策略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取模选一个messageQueue,符合条件返回</span></span><br><span class="line">            <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                ......</span><br><span class="line">                MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                <span class="comment">//没在延迟队列中，lastBrokerName为空或者mq和lastBrokerName俩个相等直接返回，考虑可用性</span></span><br><span class="line">                <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                        <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择一个相对较好的直接返回</span></span><br><span class="line">            <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">            <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">            <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">                <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq.setBrokerName(notBestBroker);</span><br><span class="line">                    mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//writeQueueNums为0了删除notBestBroker</span></span><br><span class="line">                latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不考虑可用性</span></span><br><span class="line">        <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不考虑可用性</span></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updateFaultItem"><a href="#updateFaultItem" class="headerlink" title="updateFaultItem"></a>updateFaultItem</h3><p>发送完Message通过计算花费的时间来计算broker的不可用时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计不可用时长，根据brokerName和花费时间，计算出不可用时间，从而调整时延策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brokerName     brokername</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency 当前的延时（花费时间）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> isolation      和时延等级最大的比</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">        <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">        <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应latencyMax如果花费时间大于latencyMax[i],则不可用时间为notAvailableDuration[i]</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LatencyFaultToleranceImpl"><a href="#LatencyFaultToleranceImpl" class="headerlink" title="LatencyFaultToleranceImpl"></a>LatencyFaultToleranceImpl</h2><p>重要方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新对象的时延级别</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name                 brokername</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> currentLatency       当前操作花费时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> notAvailableDuration 不可用时长</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为空或者不可用时间已经过期</span></span><br><span class="line">    <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (faultItem != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> faultItem.isAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pickOneAtLeast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Enumeration&lt;FaultItem&gt; elements = <span class="keyword">this</span>.faultItemTable.elements();</span><br><span class="line">    List&lt;FaultItem&gt; tmpList = <span class="keyword">new</span> LinkedList&lt;FaultItem&gt;();</span><br><span class="line">    <span class="keyword">while</span> (elements.hasMoreElements()) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = elements.nextElement();</span><br><span class="line">        tmpList.add(faultItem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!tmpList.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        Collections.shuffle(tmpList);</span><br><span class="line"></span><br><span class="line">        Collections.sort(tmpList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> half = tmpList.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (half &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpList.get(<span class="number">0</span>).getName();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="keyword">this</span>.whichItemWorst.getAndIncrement() % half;</span><br><span class="line">            <span class="keyword">return</span> tmpList.get(i).getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者的负载均衡"><a href="#消费者的负载均衡" class="headerlink" title="消费者的负载均衡"></a>消费者的负载均衡</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"> * contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"> * this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"> * The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"> * (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"> * the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> org.apache.rocketmq.client.consumer.rebalance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.AllocateMessageQueueStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.log.ClientLogger;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.logging.InternalLogger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Average Hashing queue algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllocateMessageQueueAveragely</span> <span class="keyword">implements</span> <span class="title">AllocateMessageQueueStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLogger log = ClientLogger.getLog();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(String consumerGroup, String currentCID, List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;String&gt; cidAll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentCID == <span class="keyword">null</span> || currentCID.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"currentCID is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mqAll == <span class="keyword">null</span> || mqAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"mqAll is null or mqAll empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cidAll == <span class="keyword">null</span> || cidAll.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"cidAll is null or cidAll empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;MessageQueue&gt; result = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">        <span class="keyword">if</span> (!cidAll.contains(currentCID)) &#123;</span><br><span class="line">            log.info(<span class="string">"[BUG] ConsumerGroup: &#123;&#125; The consumerId: &#123;&#125; not in cidAll: &#123;&#125;"</span>,</span><br><span class="line">                consumerGroup,</span><br><span class="line">                currentCID,</span><br><span class="line">                cidAll);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前队列的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line">        <span class="comment">//mod代表多出来的队列数</span></span><br><span class="line">        <span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line">        <span class="comment">//averageSize 每个消费者对应的队列数</span></span><br><span class="line">        <span class="comment">// mqAll.size() &lt;= cidAll.size() 消费者数量超过了mq队列，每个消费者消费1个队列</span></span><br><span class="line">        <span class="comment">// mod&gt;0 &amp;&amp; index &lt; mod，说明：不能整除而且该消费者对应的队列数量是mqSize/cosumerSize+1即多出来一个，否则的是花是mqSize/cosumerSize</span></span><br><span class="line">        <span class="keyword">int</span> averageSize =</span><br><span class="line">            mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">                + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//startIndex，该消费者对应的队列下标</span></span><br><span class="line">        <span class="comment">//mod &gt; 0 &amp;&amp; index &lt; mod，不能整除，而且消费者对应的队列数量是多余出来的，则开始的下标是index*avarageSize</span></span><br><span class="line">        <span class="comment">//反之，消费者对应的队列数量不能多余出一个，index*avarageSize+mod ,这里注意avarageSize是比上面-1的（超过mod的下标，index*averageSize）</span></span><br><span class="line">        <span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列的数量是averageSize，和注意如果消费者大于mq且index&gt;mode，这里会出现负数，也就是说多的消费者没有数据</span></span><br><span class="line">        <span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">            result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AVG"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> rocketmq </category>
          
          <category> 源码学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-算法思想-动态规划</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个模型：多阶段决策最优解模型，三个特征：最优解子结构，无后效性，重复子为题。</p><ul><li>多阶段决策最优解模型：即一个问题分为多个阶段，每个阶段的决策对应一组状态，我们根据这些状态寻找一组决策序列，最中获取决策序列的最优解。</li><li>三个特征：<ul><li>最优解子结构：问题的最优解，包含子问题的最优解。也就是能通过子问题最优解找到问题的最优解</li><li>无后效性：后续的问题解决方案只依赖于前一个问题的状态，而不关心他是如何推导出来的。</li><li>重复子问题：不同的决策序列到达相同阶段会产生重复的状态。</li></ul></li></ul><h3 id="空间、时间复杂度"><a href="#空间、时间复杂度" class="headerlink" title="空间、时间复杂度"></a>空间、时间复杂度</h3><p>  能用动态规划解决的问题往往都是能通过回溯算法解决的，只是回溯算法的时间复杂度往往很高是指数级的O(2^n)。用动态规划这种算法往往能很大的降低是复杂度具体会变为O(n<em>w)<br>  空间复杂度：冬天规划因为借住了一个2维数组states[n][w+1]，所以空间复杂度是O(n</em>w)。实际上动态规划是拿时间换空间的一个思想。</p><h3 id="几种算法模型的区别"><a href="#几种算法模型的区别" class="headerlink" title="几种算法模型的区别"></a>几种算法模型的区别</h3><ul><li>分治：不能抽象成多阶段决策模型，而是将一个模型分成不同的部分一次解决。</li><li>贪心：是动态规划的一个特殊方法，通过局部最优解推导出全局最优解，解决问题更加高效，但是也更加受限，最优子结构，无后效性，贪心选择。</li><li>回溯：能用贪心、动态规划算法解决的问题几乎都能用回溯算法解决，主要是用递归方法解决问题，通过穷举所有的可能，在经过对比获取最优解，由于复杂度是指数级，试用于小数据量</li><li>动态规划：上述所属多阶段决策最优解模型，有重复的子问题，无后效性，有重复子问题。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>  一般我们会采用二维数组来保存每一步决策的状态，如果状态较多可以采用三维四维数组，因为状态太多所以不太适合用这个方法。</p><p>  方法如下：（代码和题目在下面，纪念下根据方法手撕出来的呦~）</p><p>  <img src="/数据结构与算法-算法思想-动态规划/dp_2_timu.jpg" alt="avator"></p><ol><li>先用回溯方法实现算法</li><li>画出递归树，找到重复子问题</li><li>画一个状态表，往往是一个二维数组，这个二维数组分为行、列、数值。</li><li><p>我们根据题目要求，模拟递推我们的决策过程，来填写状态表表，这个递推的过程翻译成代码就是动态规划的过程，即状态转移表法。</p><p>思考过程：<br><img src="/数据结构与算法-算法思想-动态规划/dp_2_jiefa.jpg" alt="avator"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDist</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] metrix = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 示例中的动态表法：</span></span><br><span class="line"><span class="comment">     * 1.我们先初始化第一行和第一列的值</span></span><br><span class="line"><span class="comment">     * 2.根据stats[i-1][j]向下走和stats[i][j-1]向右走，找到最短距离，其他的值丢弃</span></span><br><span class="line"><span class="comment">     * 3.遍历stats[n-1],即最后一行找到最短距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> metrix 是矩阵，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span>[][] metrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = metrix.length;</span><br><span class="line">        <span class="keyword">int</span> h = metrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] stats = <span class="keyword">new</span> <span class="keyword">int</span>[w][h];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化第一行和第一列</span></span><br><span class="line">        <span class="comment">//第一行1，1+3，1+3+5，1+3+5+9</span></span><br><span class="line">        <span class="comment">//第一列1，1+2，1+2+5，1+2+5+6</span></span><br><span class="line">        stats[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w; i++) &#123;</span><br><span class="line">            stats[i][<span class="number">0</span>] += stats[i - <span class="number">1</span>][<span class="number">0</span>] + metrix[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; h; j++) &#123;</span><br><span class="line">            stats[<span class="number">0</span>][j] += stats[<span class="number">0</span>][j - <span class="number">1</span>] + metrix[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//推导状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; w; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; metrix[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">//stats[i-1][j]向下走--&gt;stats[i - 1][j]+ metrix[i][j]</span></span><br><span class="line">                <span class="keyword">int</span> down = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (stats[i - <span class="number">1</span>][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    down = stats[i - <span class="number">1</span>][j] + metrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//stats[i][j-1]向右走--&gt;stats[i][j - 1]+ metrix[i][j]</span></span><br><span class="line">                <span class="keyword">int</span> right = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (stats[i][j - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right = stats[i][j - <span class="number">1</span>] + metrix[i][j];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//找最小值</span></span><br><span class="line">                <span class="keyword">int</span> min = right &lt; down ? right : down;</span><br><span class="line">                <span class="keyword">if</span> (min != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    stats[i][j] = min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stats[w - <span class="number">1</span>].length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stats[w - <span class="number">1</span>][i] &gt; <span class="number">0</span> &amp;&amp; stats[w - <span class="number">1</span>][i] &lt; min) &#123;</span><br><span class="line">                min = stats[w - <span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MinDist.minDist(metrix));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>完成状态转移方程，然后将状态转移方程翻译成代码。例如上面例子，状态转移方程是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="number">1</span>), min_dist(i-<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">背包0-1问题升级版，</span></span><br><span class="line"><span class="comment">求解一组物体，pkg代表重量，它的价值是value，装n个物体，在w的限制下，如何使价值最大</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Knapsack</span><span class="params">(pkg []<span class="keyword">int</span>, value []<span class="keyword">int</span>, n <span class="keyword">int</span>, w <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化state数组长队[n][w+1]</span></span><br><span class="line">    state := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        state[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, w+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> state[i] &#123;</span><br><span class="line">            state[i][j] = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0元素特殊处理</span></span><br><span class="line">    state[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> pkg[<span class="number">0</span>] &lt;= w &#123;</span><br><span class="line">        state[<span class="number">0</span>][pkg[<span class="number">0</span>]] = value[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从第一个物体开始考察，开始状态转移</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="comment">//不放进背包中，i个物体是i-1个物体的重量j,value是state[i][j]值</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; w; j++ &#123;</span><br><span class="line">            <span class="comment">//如果上一个物体有值</span></span><br><span class="line">            <span class="keyword">if</span> state[i<span class="number">-1</span>][j] &gt; <span class="number">-1</span> &#123;</span><br><span class="line">                state[i][j] = state[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放进背包中，i个物体是i-1个物体的重量j+pkg[i],value是state[i-1][j] + value[i]</span></span><br><span class="line">        <span class="comment">//这里求解的是最优解，所以d当v大于当前重量的时候保留v。</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; w-pkg[i]; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> state[i<span class="number">-1</span>][j] &gt; <span class="number">-1</span> &#123;</span><br><span class="line">                v := state[i<span class="number">-1</span>][j] + value[i]</span><br><span class="line">                cw := j + pkg[i]</span><br><span class="line">                <span class="keyword">if</span> v &gt; state[i][cw] &#123;</span><br><span class="line">                    state[i][cw] = v</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历获取最大值</span></span><br><span class="line">    max := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= w; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> state[n<span class="number">-1</span>][j] &gt; max &#123;</span><br><span class="line">            max = state[n<span class="number">-1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p>如图：</p><p><img src="/数据结构与算法-算法思想-动态规划/dp_1.jpg" alt="avator"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dp</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Triangle = [][]<span class="keyword">int</span>&#123;&#123;<span class="number">5</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">坐标，只能往做或者往右走，左[i-1][j]--&gt;[i][j],右[i-1][j]--&gt;[i][j+1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShortDir</span><span class="params">(arr [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    state := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        state[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> state[i] &#123;</span><br><span class="line">            state[i][j] = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n := <span class="built_in">len</span>(arr)</span><br><span class="line">    state[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr[i])<span class="number">-1</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> state[i<span class="number">-1</span>][j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">//左走</span></span><br><span class="line">                state[i][j] = arr[i][j] + state[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="comment">//右走</span></span><br><span class="line">                state[i][j+<span class="number">1</span>] = arr[i][j+<span class="number">1</span>] + state[i<span class="number">-1</span>][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min := <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(arr); j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> state[n<span class="number">-1</span>][j] != <span class="number">-1</span> &amp;&amp; state[n<span class="number">-1</span>][j] &lt; min &#123;</span><br><span class="line">            min = state[n<span class="number">-1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> min == <span class="keyword">int</span>(^<span class="keyword">uint</span>(<span class="number">0</span>)&gt;&gt;<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找零问题"><a href="#找零问题" class="headerlink" title="找零问题"></a>找零问题</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//纸币找零动态规划求解</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ChargeDP</span><span class="params">(money []<span class="keyword">int</span>, sum <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//初始化状态数组 state[i][j]，纸币数，最多是sum，j是当前状态的金额</span></span><br><span class="line">    state := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, sum)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> state &#123;</span><br><span class="line">        state[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, sum+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="keyword">range</span> state[i] &#123;</span><br><span class="line">            state[i][j] = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    state[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">    <span class="comment">//min_charge(i,j)=state[i][j+max(money[0] money[1],mongey[2]])==sum--&gt;i</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; sum; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; sum; j++ &#123;</span><br><span class="line">            <span class="comment">//从上一次状态开始推导，当前这次最大的面额然后给纸币数+1</span></span><br><span class="line">            <span class="keyword">if</span> state[i<span class="number">-1</span>][j] &#123;</span><br><span class="line">                max := <span class="number">-100</span></span><br><span class="line">                <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(money); k++ &#123;</span><br><span class="line">                    <span class="comment">//小于等于总和，然后取最大值</span></span><br><span class="line">                    <span class="keyword">if</span> j+money[k] &lt;= sum &amp;&amp; max &lt; j+money[k] &#123;</span><br><span class="line">                        max = j + money[k]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//state[i][max]最大值获取最优解</span></span><br><span class="line">                state[i][max] = state[i<span class="number">-1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> max == sum &#123;</span><br><span class="line">                    <span class="keyword">return</span> i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找莱温斯坦距离和最大共有子串长度"><a href="#查找莱温斯坦距离和最大共有子串长度" class="headerlink" title="查找莱温斯坦距离和最大共有子串长度"></a>查找莱温斯坦距离和最大共有子串长度</h3><p>todo</p><h3 id="查找数组递增子序列"><a href="#查找数组递增子序列" class="headerlink" title="查找数组递增子序列"></a>查找数组递增子序列</h3><p>  动态转移公式：<br>  如果：array[i] &lt; array[j]==&gt;state[i][j] = state[i - 1][j - 1] + 1;<br>  state[i][j] =Math.max(state[i][j - 1],state[i-1][j - 1]);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAscDP</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state[][] = <span class="keyword">new</span> <span class="keyword">int</span>[array.length][array.length];</span><br><span class="line">    state[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;array.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>]&lt;array[j])&#123;</span><br><span class="line">            state[<span class="number">0</span>][j]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;array[<span class="number">0</span>])&#123;</span><br><span class="line">            state[i][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        state[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt; array[j]) &#123;</span><br><span class="line">                state[i][j] = state[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state[i][j] =Math.max(state[i][j - <span class="number">1</span>],state[i-<span class="number">1</span>][j - <span class="number">1</span>]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> state[array.length-<span class="number">1</span>][array.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-分治算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>todo</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReversedCount <span class="keyword">struct</span> &#123;</span><br><span class="line">    Num <span class="keyword">int</span></span><br><span class="line">    A   []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ReversedCount)</span> <span class="title">Count</span><span class="params">(p <span class="keyword">int</span>, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p &gt;= r &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := (r + p) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">this.Count(p, m)</span><br><span class="line">this.Count(m+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">this.merge(p, m, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *ReversedCount)</span> <span class="title">merge</span><span class="params">(p <span class="keyword">int</span>, m <span class="keyword">int</span>, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">j := p</span><br><span class="line">k := m + <span class="number">1</span></span><br><span class="line">tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, r-p+<span class="number">1</span>)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &lt;= m &amp;&amp; k &lt;= r &#123;</span><br><span class="line"><span class="keyword">if</span> this.A[j] &lt;= this.A[k] &#123;</span><br><span class="line">tmp[i] = this.A[j]</span><br><span class="line">j++</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp[i] = this.A[k]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1.数组分为俩部分分别为前半部分a[p,m]，以及后版部分a[m+1,r]</span></span><br><span class="line"><span class="comment">            2.这时候因为A[K]&lt;A[J]，又因为前半部分的数组是有序的，所以前半部分的数组的剩余部分都是逆序的，统计这部分元素个数即可</span></span><br><span class="line"><span class="comment">3.计算方法m-j+1,解释：</span></span><br><span class="line"><span class="comment">j是之前已经有了j个比A[k]小的元素，由于前半数组是有序的，所以从m-j+1个之后都是比a[j]大的元素了。</span></span><br><span class="line"><span class="comment">+1是因为结果药品包含当前元素（这个地方当时写错了）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">this.Num += m - j + <span class="number">1</span></span><br><span class="line">k++</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j &lt;= m &#123;</span><br><span class="line">tmp[i] = this.A[j]</span><br><span class="line">i++</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k &lt;= r &#123;</span><br><span class="line">tmp[i] = this.A[k]</span><br><span class="line">i++</span><br><span class="line">k++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, i := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">this.A[p+idx] = i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-算法思想-贪心算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>贪心算法的使用场景</p><ol><li>给定一组数据，定义了限制值和期望值，在限定的条件下，期望值最大。</li><li>在对限制值同等贡献量条件下，选择对期望值贡献最大的数据</li><li>举几个例子验证弹性算法的正确性</li></ol><h2 id="几个经典的场景"><a href="#几个经典的场景" class="headerlink" title="几个经典的场景"></a>几个经典的场景</h2><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><p>  有N个大小不同的糖果，分给M个孩子，N&gt;M，每个孩子对于糖果大小的需求不同,并且每个孩子得到一个糖果就能满足，请问如何分：<br>  答：按照贪心算法，限制值是M，每个孩子一颗糖即相同期望值是一颗糖，我们想尽量满足更多的孩子，所以我们要先将最小的糖果分给对糖果的大小需求小的孩子</p><h3 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h3><p>  钱币有10，20，50，100的零钱，我们如何找零<br>  答：由于找零所需的金额一定，即限制值是金额。我们希望相同纸币数的情况下多贡献金额，相同期望值是纸币数。所以我们先将大的找出去，在用零钱填补空缺。</p><h3 id="空间覆盖"><a href="#空间覆盖" class="headerlink" title="空间覆盖"></a>空间覆盖</h3><p>  从N个空间选出尽量多不相交的区间见下图</p><p>  <img src="/数据结构与算法-贪心算法/greedy_1.jpg" alt="avator"></p><p>  答：我们选择尽量靠近左端且不与前面覆盖的端点，然后右边选择离左边尽量近的点给右边尽可能大的空间</p><h3 id="huffman编码"><a href="#huffman编码" class="headerlink" title="huffman编码"></a>huffman编码</h3><p>  用于压缩一段数据往往压缩的量在20~90%之间，原理在：<a href="https://time.geekbang.org/column/article/73188" target="_blank" rel="noopener">https://time.geekbang.org/column/article/73188</a><br>  后期完善</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-字符串匹配-KMP算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E7%AE%97%E6%B3%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度是O(m+n),n是模式串长度、m是主串长度。空间复杂度O(n)，因为失效函数借助了一个数组长度为n</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>比较的移动借鉴了BM算法，采用好前缀规则如图，遇到坏字符时候，假设好前缀的最长可匹配前缀子串长度为v,则模式串一次性移动j-v个距离，相当于将j变为v</li><li>求解失效数组</li></ol><p><img src="/数据结构与算法-字符串匹配-KMP算法/kmp_1.jpg" alt="avator"></p><h3 id="匹配代码"><a href="#匹配代码" class="headerlink" title="匹配代码"></a>匹配代码</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">KMP</span><span class="params">(str <span class="keyword">string</span>, ptr <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">next := getNext(ptr)</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(str) &amp;&amp; j &lt; <span class="built_in">len</span>(ptr) &#123;</span><br><span class="line"><span class="comment">//如果匹配继续</span></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="number">0</span> || str[i] == ptr[j] &#123;</span><br><span class="line">j++</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//发现badecode，滑动模式串，next[j]个位置，如果是0发现不等，会到-1,然后i移动，j移动</span></span><br><span class="line">j = next[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j == <span class="built_in">len</span>(ptr) &#123;</span><br><span class="line"><span class="keyword">return</span> i - j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求解next数组代码"><a href="#求解next数组代码" class="headerlink" title="求解next数组代码"></a>求解next数组代码</h3><p>规律如下，假设模式串为a,那么遵循如下俩条规律</p><ol><li>当a[0,i-1]的最长可匹配前子串是a[0,k-1]，的下一个字符a[i]等于a[k]，那么a[0,i]的最长匹配前缀就是a[0,k]</li><li>当a[i]不等于a[k]，我们要找到a[0,i-1]的次长匹配子串a[0,k’]，当a[k’+1]等于a[i]，那么a[0,k’]就是a[0,i]的最长匹配前缀<ol><li>其中，a[0,k’]一定包含a[0,k-1]中，即next数组中，如图</li></ol></li></ol><p><img src="/数据结构与算法-字符串匹配-KMP算法/kmp_2.jpg" alt="avator"></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//失效函数,求解ptr的next数组，我们可以看做是ptr字符串和自己的最长前缀的匹配</span></span><br><span class="line"><span class="comment">//重点：</span></span><br><span class="line"><span class="comment">// 1、公式1：如果p[i]的最长匹配前缀子串是j,如果p[i+1]==p[j+1]，那么p[i+1]的最长匹配子串是j+1，next[i+1]=j+1</span></span><br><span class="line"><span class="comment">// 2、公式2：上述情况下如果p[i+1]!=p[j+1],我们认为j+1是坏字符串，应该将最长前缀字符串(在这里是模式串)挪动next[j+1]个距离假设是y，在继续查找，如果这时候p[i+1]==p[y],那么p[i+1]的最长匹配子串就是next[i+1]=y</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getNext</span><span class="params">(ptr <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">next := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(ptr))</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span> <span class="comment">//如果前缀只有一个字符是没有好前缀的</span></span><br><span class="line"></span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">j := <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历模式串ptr</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(ptr)<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">//j==-1时候，匹配失效，复位j=0说明没有匹配得上的最长前缀子串；</span></span><br><span class="line"><span class="comment">// 如果ptr[i]==ptr[j],说明next[i]=j，然后俩个都++如果继续相等next[i+1]=j+1，</span></span><br><span class="line"><span class="keyword">if</span> j == <span class="number">-1</span> || ptr[i] == ptr[j] &#123;</span><br><span class="line">j++</span><br><span class="line">i++</span><br><span class="line">next[i] = j</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果ptr[i] != ptr[j]并且j!=-1，相当于模式串的最长后缀和模式串的最长前缀无法匹配</span></span><br><span class="line"><span class="comment">//这时候要移动j,移动的方案是假设j是坏字符，那么查找ptr[0,j]的最长前缀子串一定在next数组中（上面的分支已经匹配过了）</span></span><br><span class="line"><span class="comment">//所以移动j，距离是next[j]（刚才匹配的最长前缀的长度）</span></span><br><span class="line">j = next[j] <span class="comment">//****不会空指针的原因在上面的分支，上一次循环next[i++]=j++，i本身就&gt;j，所以next[j]之前已经计算过了。一定是有值的</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(next)</span><br><span class="line"><span class="keyword">return</span> next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-字符串匹配-BM算法</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-BM%E7%AE%97%E6%B3%95/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-BM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>原理：BM算法是在暴力破解算法的基础上利用一定规律都移动模式串已达到快速匹配的效果。（俩个规律好后缀和坏字符），直接上代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> stringsearch</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BM</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//初始化好后缀</span></span><br><span class="line">suffix, prefix := initGS(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化坏字符</span></span><br><span class="line">bc := initBC(p)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s)-<span class="built_in">len</span>(p); &#123;</span><br><span class="line">j := <span class="built_in">len</span>(p) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从后往前匹配</span></span><br><span class="line"><span class="keyword">for</span> ; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line"><span class="keyword">if</span> s[i+j] != p[j] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整个模式串都符合直接返回</span></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//坏字符规则</span></span><br><span class="line">x := j - bc[s[i+j]]</span><br><span class="line"></span><br><span class="line"><span class="comment">//好后缀</span></span><br><span class="line">y := <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="built_in">len</span>(p)<span class="number">-1</span> &#123;</span><br><span class="line">y = moveGS(j, <span class="built_in">len</span>(p), suffix, prefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动i相当于按照规则移动模式串</span></span><br><span class="line">ret := x</span><br><span class="line"><span class="keyword">if</span> y &gt; x &#123;</span><br><span class="line">ret = y</span><br><span class="line">&#125;</span><br><span class="line">i = i + ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initBC</span><span class="params">(pattern <span class="keyword">string</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">bc := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">256</span>)</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="number">255</span>; r++ &#123;</span><br><span class="line">bc[r] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx, v := <span class="keyword">range</span> []<span class="keyword">byte</span>(pattern) &#123;</span><br><span class="line">bc[v] = idx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initGS</span><span class="params">(pattern <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">int</span>, []<span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">suffix := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(pattern))</span><br><span class="line">prefix := <span class="built_in">make</span>([]<span class="keyword">bool</span>, <span class="built_in">len</span>(pattern))</span><br><span class="line"><span class="keyword">for</span> r := <span class="number">0</span>; r &lt; <span class="built_in">len</span>(pattern); r++ &#123;</span><br><span class="line">suffix[r] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(pattern)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">j := i</span><br><span class="line">k := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>-k] &#123;</span><br><span class="line">k++</span><br><span class="line">suffix[k] = j</span><br><span class="line">j--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line">prefix[k] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> suffix, prefix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveGS</span><span class="params">(j <span class="keyword">int</span>, m <span class="keyword">int</span>, suffix []<span class="keyword">int</span>, prefix []<span class="keyword">bool</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">k := m - <span class="number">1</span> - j</span><br><span class="line"><span class="keyword">if</span> suffix[k] != <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> j - suffix[k] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> r := j + <span class="number">2</span>; r &lt;= m<span class="number">-1</span>; r++ &#123;</span><br><span class="line"><span class="keyword">if</span> prefix[m-r] &#123;</span><br><span class="line"><span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-字符串的匹配</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="BF算法（buter-force）"><a href="#BF算法（buter-force）" class="headerlink" title="BF算法（buter force）"></a>BF算法（buter force）</h2><p>  原理：分为主串和模串，在主串m中匹配模串n，所以主串有从0,1,2,3….到m-n个m-n+1个子字符串</p><p>  时间复杂度：理论上是O(m*n),m是主串长度，n是子串长度。但是因为匹配到模串第一个不符合的就会返回进行下一次匹配所以实际效果会好不上。加上比较简单、易于排错所以一般工业会采用这种方法</p><p>  代码示例：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BruteForce</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] main;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] pattern;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BruteForce</span><span class="params">(String main, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.main = main.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern.toCharArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力搜索的方法，总共有起始位置0，1，2，...n,m-n+1个子串，每个子串和摩串匹配时间复杂度是O(m-n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (main.length &lt; pattern.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> eq = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= main.length - pattern.length + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pattern.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (main[i + j] != pattern[j]) &#123;</span><br><span class="line">                    eq = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                eq = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eq) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RK算法-RobinKrap"><a href="#RK算法-RobinKrap" class="headerlink" title="RK算法-RobinKrap"></a>RK算法-RobinKrap</h2><p> BF算法的优化，由于BF算法需要一个个比较子串，复杂度是O(m*n),所以KR对BF算法做了优化，预先将所有的子串的hash值计算出来然后吧子串的位置记录下来，计算模串的hash，然后在hash中查找，这样复杂度就是计算模串的O(n)+hash获取的O(1)。</p><p> 代码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RobinKrap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] main;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] pattern;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer patternHash;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本质和bf的方法一样，只是预先将0~m-n个n-m+1个子串的hash和位置预先计算出来保存起来，然后在查询时候用模的hash去匹配看是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RobinKrap</span><span class="params">(String main, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.main = main.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern.toCharArray();</span><br><span class="line"></span><br><span class="line">        patternHash = <span class="keyword">this</span>.pattern.hashCode();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; main.length() - pattern.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            hashMap.put(Arrays.copyOfRange(<span class="keyword">this</span>.main, i, pattern.length()).hashCode(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hashMap.containsKey(patternHash)?hashMap.get(patternHash):-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdefghijklmnklmn"</span>;</span><br><span class="line">        String p = <span class="string">"klmn"</span>;</span><br><span class="line">        BruteForce bf = <span class="keyword">new</span> BruteForce(s, p);</span><br><span class="line">        <span class="keyword">int</span> i = bf.indexOf();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> idx = i; idx &lt; i + p.length(); idx++) &#123;</span><br><span class="line">            System.out.print(s.charAt(idx));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-图的广度和深度搜索</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>  问题：接上一篇文章我们用<a href="./数据结构与算法-图-graph">图</a>这种数据结构存储好友之间的关系，那么我们如何获取2度、3度关系，或者说在迷宫中如何获取出口呢？</p><p>  针对上述问题介绍俩种图的搜索算法广度搜索发（bfs）、深度搜索发(dfs)</p><h2 id="BFS-广度搜索法–2、3度人脉"><a href="#BFS-广度搜索法–2、3度人脉" class="headerlink" title="BFS-广度搜索法–2、3度人脉"></a>BFS-广度搜索法–2、3度人脉</h2><p>  如图：<br>  <img src="/数据结构与算法-图的广度和深度搜索/bfs_1.jpg" alt="avator"></p><p>  原理：我们先从起点找到最近的点，然后逐层扩大直到找到终点或者找到我们需要的层级。代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(Vertex end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//借用队列，将下一个要查找的点入队列</span></span><br><span class="line">    LinkedList&lt;Vertex&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录搜索过的点，找到值后跳过</span></span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录路径key是当前的点的下标，value是来源，打印时候通过递归层层找到最开始的起点</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; path = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加起点坐标</span></span><br><span class="line">    queue.add(list.get(<span class="number">0</span>));</span><br><span class="line">    visited.add(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//初始化路径</span></span><br><span class="line">    list.forEach(v -&gt; &#123;</span><br><span class="line">        path.put(v.getVal(), -<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一层结束后才开始第二层</span></span><br><span class="line">    <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//队列出列</span></span><br><span class="line">        Vertex v = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (Vertex adjV : v.getAdj()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjV)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//修改path和visited</span></span><br><span class="line">            visited.add(adjV);</span><br><span class="line">            path.put(adjV.getVal(), v.getVal());</span><br><span class="line">            <span class="keyword">if</span> (adjV.equals(end)) &#123;</span><br><span class="line">                <span class="comment">//找到终点打印</span></span><br><span class="line">                GraphUtil.printPath(path, list.get(<span class="number">0</span>), end.getVal());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(adjV);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  时间复杂度：E代表边，V代表点，最坏情况下访问所有的边和点，即O(V+E),可以简写为O(E)。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上述找到N度关系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Vertex&gt; <span class="title">searchByDegree</span><span class="params">(List&lt;Vertex&gt; list, <span class="keyword">int</span> degree)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//记录当前是第几度关系的容器</span></span><br><span class="line">      LinkedList&lt;DegreeVertex&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">      Set&lt;Vertex&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      queue.add(<span class="keyword">new</span> DegreeVertex(i, list.get(<span class="number">0</span>)));</span><br><span class="line">      visited.add(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">      List&lt;Vertex&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          DegreeVertex degreeVertex = queue.poll();</span><br><span class="line">          <span class="comment">//超过度直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (degreeVertex.getDegree() &gt; degree) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          i = degreeVertex.getDegree() + <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span> (Vertex adjV : degreeVertex.vertex.getAdj()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (visited.contains(adjV)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              visited.add(adjV);</span><br><span class="line">              <span class="keyword">if</span> (i == degree) &#123;</span><br><span class="line">                  ret.add(adjV);</span><br><span class="line">              &#125;</span><br><span class="line">              queue.add(<span class="keyword">new</span> DegreeVertex(i, adjV));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先算法"><a href="#深度优先算法" class="headerlink" title="深度优先算法"></a>深度优先算法</h2><p>  原理：类似走迷宫的场景，主要采用回溯的思想，当一条道路走不通，往回退一步选择别的道路</p><p>  如图：<br>  <img src="/数据结构与算法-图的广度和深度搜索/dfs_1.jpg" alt="avator"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DFS</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Vertex&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用visited和path</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Vertex&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; path = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//用于结束递归的标记位发现后置为true停止递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DFS</span><span class="params">(List&lt;Vertex&gt; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.graph = graph;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(Vertex end)</span> </span>&#123;</span><br><span class="line">        graph.forEach(vertex -&gt; &#123;</span><br><span class="line">            path.put(vertex.getVal(), -<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        search(graph.get(<span class="number">0</span>), end);</span><br><span class="line">        GraphUtil.printPath(path, graph.get(<span class="number">0</span>), end.getVal());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(Vertex start, Vertex end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.add(start);</span><br><span class="line">        <span class="keyword">if</span> (start.equals(end)) &#123;</span><br><span class="line">            found = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Vertex adjV : start.getAdj()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(adjV)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.put(adjV.getVal(), start.getVal());</span><br><span class="line">            visited.add(adjV);</span><br><span class="line">            search(adjV, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度，最坏情况下每个边访问俩遍所以是O(E)</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-图(graph)</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-graph/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE-graph/</url>
      
        <content type="html"><![CDATA[<p>引言：我们如果存储、如何存储微博、微信等社交网络中的好友关系呢</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一种非线性数据结构。图中数据我们成为定点（vertex），图中数据的关系我们成为边（edge）。没个定点有多少条边我们成为度（dregee），有向图中，因为关系是有方向的，指向定点的边的数量我们称为入度（in-dregee），指向其他定点的边的数量称为初度（out-degree）如图：</p><p><img src="/数据结构与算法-图-graph/graph_1.jpg" alt="avator"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>针对图是否有方向我们可分为无向图，和有向图，另外在无向图中我们如果加入类似亲密度的概念还分为带权图</p><h2 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h2><h3 id="临接矩阵存储法"><a href="#临接矩阵存储法" class="headerlink" title="临接矩阵存储法"></a>临接矩阵存储法</h3><p>底层用2维数组来表示：</p><ol><li>无向图：i到j的距离a[i][j]设置为1，a[j][i]也设置为1</li><li>有向图：i指向j的距离a[i][j]设置为1。如果j指向[i]的距离也设置为1</li><li>带权图：同无向图是双向关系，只是存储的是权重</li></ol><p>如图：<br><img src="/数据结构与算法-图-graph/graph_2.jpg" alt="avator"></p><h3 id="邻接表储存法"><a href="#邻接表储存法" class="headerlink" title="邻接表储存法"></a>邻接表储存法</h3><p>  上面的方法用来表示关系优点是比较直接，缺点是浪费空间，无向图和带权图下办部分空间几乎都浪费了。我们可以采用之前散列类似的方式来保存图的关系。</p><p>  key为定点，那么到其他地方的关系我们可以在这个顶点后，他说有的边的关系用一个利于查找的数据结构保存（数组、链表、跳表、红黑树），因为链表的查询复杂度是O(N),我们可以考虑用红黑树查找、删除、添加，O(Log2N),跳表（log2N)来优化他。如图</p><p><img src="/数据结构与算法-图-graph/graph_3.jpg" alt="avator"></p><h3 id="如何保存用户的关系"><a href="#如何保存用户的关系" class="headerlink" title="如何保存用户的关系"></a>如何保存用户的关系</h3><p>对于大量的而用户我们可以用mysql表来存储</p><ol><li>a关注b,写入一条记录a-&gt;b状态1，0</li><li>b成为a的粉丝，写入一条记录b-&gt;a状态1，1</li><li>这时候只需要以a或者b把数据加载到内存中，用邻接表方式存储起来即可</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `social_relation` (</span><br><span class="line">  `id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;pk&apos;,</span><br><span class="line">  `u_id` char(32) DEFAULT NULL COMMENT &apos;关注u_id&apos;,</span><br><span class="line">  `follow_u_id` char(32) DEFAULT NULL COMMENT &apos;被关注u_id&apos;,</span><br><span class="line">  `follow_status` smallint(6) DEFAULT NULL COMMENT &apos;关注状态位&apos;,</span><br><span class="line">  `followed_status` smallint(11) DEFAULT NULL COMMENT &apos;被关注状态位&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uniq_uid_follow_u_id` (`u_id`,`follow_u_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title> 数据结构与算法-堆以及堆排序</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%A0%86%E4%BB%A5%E5%8F%8A%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="堆的特点以及实现"><a href="#堆的特点以及实现" class="headerlink" title="堆的特点以及实现"></a>堆的特点以及实现</h2><p>  堆的定义：任意一个节点都大于（小于）他们的子节点，堆顶是最大（小）的元素，如果堆顶是最大的元素成为大顶堆，如果堆顶是最小的元素成为小顶堆</p><p>  堆是完全二叉树，底层实现是通过数组实现。他们之间的关系如下：</p><ul><li>下标为i的节点leftNode的下标是2<em>i+1，rightNode是2</em>(i+1)</li><li>下标为i的节点他的父节点是(i-1)/2</li></ul><h2 id="堆的几种操作原理"><a href="#堆的几种操作原理" class="headerlink" title="堆的几种操作原理"></a>堆的几种操作原理</h2><h3 id="插入–自下而上的堆化"><a href="#插入–自下而上的堆化" class="headerlink" title="插入–自下而上的堆化"></a>插入–自下而上的堆化</h3><p>时间复杂度O(logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == capacity) &#123;</span><br><span class="line">        System.out.println(<span class="string">"堆已经满了"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[count] = value;</span><br><span class="line">    <span class="keyword">int</span> i = count;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//插入到堆最后一个节点，然后开始迭代，判断如果节点如果大于父节点交换俩个节点，这时候堆顶就是最大的数据</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pIdx=(i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; array[pIdx]) &#123;</span><br><span class="line">          swap(array,i,pIdx);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=pIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除–自上而下的堆化"><a href="#删除–自上而下的堆化" class="headerlink" title="删除–自上而下的堆化"></a>删除–自上而下的堆化</h3><p>时间复杂度是O(logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除堆顶</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delTop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删空了</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了防止空洞直接，将最后一位数据和堆顶交换，删除最后一位数据，然后将新的堆顶自上而下的堆化</span></span><br><span class="line">    array[<span class="number">0</span>] = array[count - <span class="number">1</span>];</span><br><span class="line">    array[count - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    heapify(array, count - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//自上而下的堆化操作。遍历在自己的子节点中发现有比自己大的值，就和自己替换比较</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapCapicity, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = i;</span><br><span class="line">        <span class="comment">//如果当前元素小于左子节点，将左子节点和当前节点值交换。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= heapCapicity &amp;&amp; a[top] &lt; a[<span class="number">2</span> * i + <span class="number">1</span>]) &#123;</span><br><span class="line">            top = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前元素小于右子节点，将右子节点和当前节点值交换。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * (i + <span class="number">1</span>) &lt;= heapCapicity &amp;&amp; a[top] &lt; a[<span class="number">2</span> * (i + <span class="number">1</span>)]) &#123;</span><br><span class="line">            top = <span class="number">2</span> * (i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没变说明不需要交换直接跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (top == i) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, top, i);</span><br><span class="line">        i=top;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序的原理"><a href="#堆排序的原理" class="headerlink" title="堆排序的原理"></a>堆排序的原理</h2><p>  大致分俩个步骤，升序为例建大顶堆，降序建小顶堆</p><ol><li>建堆：整个数组的[0，n/2]是非叶子节点，对所有的非叶子节点进行自上而下的堆化操作。时间复杂度O(NlogN)</li><li>排序：因为堆顶元素是最大的，所以将堆顶和堆尾的元素交换，然后堆范围缩小1，再次交换堆顶，直到最后一位。时间复杂度O(NlogN)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从非叶子节点开始建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length / <span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(a, a.length , i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> a[]) &#123;</span><br><span class="line">    buildHeap(a);</span><br><span class="line">    System.out.println(<span class="string">"buildHeap:"</span>+Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始交换，直到剩下最后一个元素为止</span></span><br><span class="line">    <span class="keyword">int</span> swapIdx = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (swapIdx &gt; <span class="number">1</span>) &#123;<span class="comment">//注意剩下2个元素时候交换完后跳出循环</span></span><br><span class="line">        swap(a, <span class="number">0</span>, swapIdx);<span class="comment">//堆顶（Max）和交换区的元素交换</span></span><br><span class="line">        swapIdx--;<span class="comment">//缩小交换区</span></span><br><span class="line">        heapify(a,swapIdx,<span class="number">0</span>);<span class="comment">//找第二大的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  时间复杂度o(nlogn)</p><h3 id="堆排序的缺点"><a href="#堆排序的缺点" class="headerlink" title="堆排序的缺点"></a>堆排序的缺点</h3><ol><li>堆是个完全二叉树无法想数组顺序访问那样很好的利用cpucache</li><li>堆排序数据的逆序度高。</li></ol><h2 id="堆的使用"><a href="#堆的使用" class="headerlink" title="堆的使用"></a>堆的使用</h2><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>  java的优先级队列PriorityQueue实际上底层的实现就是堆，维护一个小（大）顶堆，堆顶就是队列的第一个元素。</p><p>  类似的实现还有高性能定时器：我们定时任务都在一个队列中，通常的做法是每隔一段时间轮询队列，这样如果任务列表很长或者计算资源不足时候不是很精确同时也会浪费计算资源。我们如果用堆来实现的话，维护一个小顶堆，堆顶是最先执行的任务，我们定时器取堆顶的任务计算和现在的时间差T如果T&gt;0,线程就睡眠T时间，这样节省了资源，当小于等于0时候开始执行任务，同时从堆中移除。</p><h3 id="topn问题"><a href="#topn问题" class="headerlink" title="topn问题"></a>topn问题</h3><p>  N个文件中取topN，比较坏的做法是，每个文件取一个放在数组中，然后从第一个文件中取出来循环和数组中的数据比较，如果发现大于数组中的值就放入数组。这样时间复杂度很高；用堆的思想，我们可以我们可以维护一个元素为N的小顶堆，依次取文件如果发现比小顶堆小就插入到小顶堆中。</p><p>  一个静态的大文件中取topn，静态文件我们可以维护一个元素为N的小顶堆，方式同上；动态数据我们可以始终维护一个小顶堆。</p><h3 id="求中位数"><a href="#求中位数" class="headerlink" title="求中位数"></a>求中位数</h3><p>  场景：比如运维中求中位数，90分位等的要求，即100份，前0份或者90份的样本数的大小。如：1，2，3，4，5，6。中的3，4都可以做中位数，一般取3</p><p>  方法：我们可以把样本数分为俩部分，用俩个堆来维护，前n/2的数据放在大顶堆中，后面的数据放在小顶堆中，大顶堆的堆顶就是中位数。当有新的样本数据插入时候判断如果小于大顶堆就插入到大顶堆中，否则就插入小顶堆中。这时候可能破坏了平衡，那么我们可以将新插入的那个堆的堆顶元素置换到另一个堆中来保持平衡</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-红黑树</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>  二叉搜索树在极限情况下会退化成链表，为了保证查找的稳定性，引入了平衡二叉搜索树，其中最有名的就是红黑树。</p><h2 id="平衡二叉树定义"><a href="#平衡二叉树定义" class="headerlink" title="平衡二叉树定义"></a>平衡二叉树定义</h2><p>  整棵树里左子树和右子树的高度不能相差1。类似的数据结构有：AVL树、伸展树、树堆、红黑树。</p><p>  红黑树将节点标记为红节点或者黑节点，它的特点：</p><ol><li>所有根节点都是黑节点;</li><li>子节点都是黑节点，且值为nil;</li><li>红节点不能相邻</li><li>每个节点到其叶子节点的所有路径经历的黑节点数都一样。</li></ol><h2 id="如何实现平衡"><a href="#如何实现平衡" class="headerlink" title="如何实现平衡"></a>如何实现平衡</h2><p>  红黑树将所有红色节点去掉会变成四叉树，如图，在将四叉树的节点挂在子节点下，会变成完全二叉树。</p><p>  <img src="./红黑树.jpg" alt="avtor"></p><h2 id="红黑树的复杂度"><a href="#红黑树的复杂度" class="headerlink" title="红黑树的复杂度"></a>红黑树的复杂度</h2><p>  如上所说,完全二叉树的事件复杂度【log2(N-1)~~log2N】,在把红色家进度复杂度不会超过2log2N。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树</title>
      <link href="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<!--二茬搜索树的find insert delete 建值冲突里解决方案(右子树)，找最大，最小后继节点，前驱节点。中序遍历输出有序数组。时间复杂度logn和散列比优势 --><h2 id="二叉查找树的定义（Binary-Search-Tree）"><a href="#二叉查找树的定义（Binary-Search-Tree）" class="headerlink" title="二叉查找树的定义（Binary Search Tree）"></a>二叉查找树的定义（Binary Search Tree）</h2><p>左子树每个节点的值要小于节点值，右子树每个节点的值都要大于该节点的值。对于大小相等的节点，两种做法，链表或者数组的方式保存，一种是当做大于该节点放在右子树，本文取第二种方法</p><h2 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h2><p>遍历或者递归查找树，如果该值小于节点的值从左子树查找，如果大于大于根节点从有子树查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">find</span><span class="params">(TreeNode tree, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    TreeNode p = tree;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt;= p.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) &#123;</span><br><span class="line">                treeNodes.add(p);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> treeNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">find</span><span class="params">(TreeNode tree, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    TreeNode p = tree;</span><br><span class="line">    List&lt;TreeNode&gt; treeNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (value &lt; p.value &amp;&amp; p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        findNodeByValue(p.left, value, treeNodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= p.value &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">       findNodeByValue(p.right, value, treeNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNodeByValue</span><span class="params">(TreeNode tree, <span class="keyword">int</span> value, List&lt;TreeNode&gt; treeNodes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; tree.value) &#123;</span><br><span class="line">        findNodeByValue(tree.left, value, treeNodes);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// if (value &gt;= tree.value)</span></span><br><span class="line">        <span class="keyword">if</span> (value == tree.value) &#123;</span><br><span class="line">            treeNodes.add(tree);</span><br><span class="line">        &#125;</span><br><span class="line">        findNodeByValue(tree.right, value, treeNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的添加操作"><a href="#二叉查找树的添加操作" class="headerlink" title="二叉查找树的添加操作"></a>二叉查找树的添加操作</h2><p>新插入的值一般在叶子节点，所以遍历树，如果小于节点值，并且做节点是空就插入到左子树，如果大于节点的值并且节点为空插入有子树，否则继续遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TreeNode p = treeNode;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v&lt;p.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode treeNode, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    TreeNode p = treeNode;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; p.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.left = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(p.left, v);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt;= p.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            p.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        insertNode(p.right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h2><ol><li>找到该节点， 如果遇到冲突，放在数组中</li><li>如果查找的节点叶子节点直接将父节点指向null<ol><li>如果只有左（右）子树，将该节点指向改节点中的左（右）子树</li><li>如果既有左子树，又有右子树，找第一个大于该节点的节点a，将a的值复制到该节点，然后删除a。</li></ol></li><li>从数组逆向遍历一个个删除。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">delNode</span><span class="params">(TreeNode tree, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历树，找到相等节点放在eqNodes父节点放在pNodes</span></span><br><span class="line">    TreeNode node = tree;</span><br><span class="line">    List&lt;TreeNode&gt; eqNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;TreeNode&gt; pNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; node.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left!=<span class="keyword">null</span> &amp;&amp; node.left.value == v) &#123;</span><br><span class="line">                eqNodes.add(node.left);</span><br><span class="line">                pNodes.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right!=<span class="keyword">null</span> &amp;&amp; node.right.value == v) &#123;</span><br><span class="line">                eqNodes.add(node.right);</span><br><span class="line">                pNodes.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有相等的</span></span><br><span class="line">    <span class="keyword">if</span> (eqNodes.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历相等的节点一次删除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = eqNodes.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        node = eqNodes.get(i);</span><br><span class="line">        TreeNode parent = pNodes.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时有左右子树，找到右子树里最小的节点和父节点，将右子树最小的节点的值复制给之前要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode minNode = node.right;</span><br><span class="line">            TreeNode minPNode = node;</span><br><span class="line">            <span class="keyword">while</span> (minNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                minPNode = minNode;</span><br><span class="line">                minNode = minPNode.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//复制</span></span><br><span class="line">            node.value = minNode.value;</span><br><span class="line">            <span class="comment">//删除右子树最小的节点</span></span><br><span class="line">            node = minNode;</span><br><span class="line">            parent = minPNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到child树，不会出现左右子树同时存在的情况：P</span></span><br><span class="line">        TreeNode child = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child = node.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            child = node.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始删除如果parent是空，删的是根节点，如果node&lt;parent删除的是左子树，反之是右子树</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tree = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; parent.value) &#123;</span><br><span class="line">            parent.left = child;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent.right = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>查找、删除、添加的逻辑都是类似的时间复杂度和树的高度相关。节点和高度的关系如下:<br>  以完全二叉树为例，假设树的层级是H，非叶子节点是：1+2+4+8+…+(2的H-1次方)，叶子节点是【1~2的H次方】。H就是log(n-1)+1~Logn之间，所以时间复杂度是logN</p><h2 id="最坏情况"><a href="#最坏情况" class="headerlink" title="最坏情况"></a>最坏情况</h2><p>破坏平衡退化成链表。</p><h2 id="搜索树和散列比的其他功能"><a href="#搜索树和散列比的其他功能" class="headerlink" title="搜索树和散列比的其他功能"></a>搜索树和散列比的其他功能</h2><p>搜索数能很方便的找到最小节点、最大节点、找到前驱节点和后置节点代码如下。</p><p>搜索数如果想按从小到大打印可以通过中序遍历2Logn比散列要快。</p><p>和散列对比其他的优势：</p><ol><li>散列虽然查找是o(1)，但是考虑到hash函数以及hash冲突要遍历链表以及开发寻址，所以不一定效率高</li><li>hash冲突导致性能不稳定，搜索树通过平衡性能很稳定</li><li>散列需要扩容和缩容额外需要资源</li><li>负载因子不能太大容易造成内存浪费</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="树定义"><a href="#树定义" class="headerlink" title="树定义"></a>树定义</h2><p>非线性的数据结构，线性数据结构（数组、链表等数据结构）。<br>  树节点的关系：同级的节点叫做兄弟节点、下级节点叫做子节点、上级节点叫父节点、如果父节点为空叫做做根节点、最下层节点叫叶子节点。<br>  常用的名词：<br>    高度：从叶子节点到跟节点的距离<br>    深度：从根节点到叶子节点的距离<br>    层：深度-1</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul><li>满二叉树：所有叶子节点均在最后一层，除叶子节点以外的节点都是满节点状态。</li><li>完全二叉树：所有叶子节点均在最后俩层，最后一层的叶子节点都在左边，并且非叶子节点都是满节点状态。</li></ul><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>见代码，都会用到递归算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历：自己--&gt;left--&gt;right</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontForeach</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        frontForeach(node.left);</span><br><span class="line">        frontForeach(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历：left--&gt;自己--&gt;right</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midForeach</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        midForeach(node.left);</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">        midForeach(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后续遍历：left--&gt;right--&gt;自己</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backForeach</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        backForeach(node.left);</span><br><span class="line">        backForeach(node.right);</span><br><span class="line">        System.out.println(node.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么样的二叉树适合用数组表示"><a href="#什么样的二叉树适合用数组表示" class="headerlink" title="什么样的二叉树适合用数组表示"></a>什么样的二叉树适合用数组表示</h2><p>满二叉树以及完全二叉树适合用数组标识因为节点的公式是,根节点是数组下标为1的元素开始，他的子节点节点依次是2<em>(arrayIndx)，2</em>(arrayIndx)+1。因为普通的二叉树会浪费很多空间。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hash算法的应用</title>
      <link href="hash%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>hash%E7%AE%97%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="hash算法的标准"><a href="#hash算法的标准" class="headerlink" title="hash算法的标准"></a>hash算法的标准</h2><ol><li>不能逆向推导出原数据</li><li>对输入数据很敏感，改了一bit，最后得到的hash值也不相同</li><li>散列冲突概率很小</li><li>算法执行效率高</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="安全加密"><a href="#安全加密" class="headerlink" title="安全加密"></a>安全加密</h3><p>  我们在保存数据时候可以对数据用hash函数进行加密比如：MD5、SHA、DES、AES</p><p>  hash算法做安全加密应该尽量避免hash冲突，但是也不可能完全避免，但是概率很低比如MD5的范围如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">128</span>=<span class="number">340282366920938463463374607431768211456</span></span><br></pre></td></tr></table></figure><p>  加密算法越高级效果越好，但是相应的性能会越差</p><h3 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h3><p>  我们可以通过hash函数作为数据的唯一标识，比如对一个图片的搜索我们如果一个个比对他们的2进制码会很耗时，我们可以抽样踩点进行hash计算，然后hash相同的在去比较是否。</p><h3 id="数据校验"><a href="#数据校验" class="headerlink" title="数据校验"></a>数据校验</h3><p>  大数据可能会被分块保存，我们只需要记录每一块的hash值，当文件块下载完成后进行hash值的校验，校验文件是否完整</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>  因为hash函数冲突的概率很低，所以我们可以利用hash作为散列函数</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>  session-sticky模式的访问，对于客户端请求hash之后和服务器个数取模，这样保证每个请求都打到同一个后端</p><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><p>  对于海量数据我们可以将数据hash之后分散到各服务器节点中，这样在计算的时候根据数据hash取模到某个服务器节点计算（map-reduce思想）</p><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><p>  海量数据根据数据的hash分片落到某一个节点上，理论上可以存储无数的数据，常用于nosql的存储，不过要注意一致性hash，防止节点变更大量的数据进行rehash。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Hash </tag>
            
            <tag> 散列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx--常用参数</title>
      <link href="Nginx-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/"/>
      <url>Nginx-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="proxy-redirect"><a href="#proxy-redirect" class="headerlink" title="proxy_redirect"></a>proxy_redirect</h2><p>语法：proxy_redirect [ default|off|redirect replacement ]<br>默认值：proxy_redirect default<br>上下文：http, server, location<br>作用：修改从被代理服务器传来的应答头中的”Location”和”Refresh”字段</p><p>比如：Nginx监听的端口是80，请求<a href="http://www.a.com:8080/" target="_blank" rel="noopener">http://www.a.com:8080/</a> 就会报错，这时候如果设置了【proxy_redirect：<a href="http://www.a.com:8080/" target="_blank" rel="noopener">http://www.a.com:8080/</a> /】即可定位到这里</p><h2 id="client-max-body-size"><a href="#client-max-body-size" class="headerlink" title="client_max_body_size"></a>client_max_body_size</h2><p>语法：client_max_body_size [ 8m ]<br>默认值：1m;<br>默认值：proxy_redirect default<br>上下文：http, server, location<br>作用：request的body大小的限制，如果reqeustBody体较大记得设置入上传图片，否则request会413.</p><h2 id="client-body-buffer-size"><a href="#client-body-buffer-size" class="headerlink" title="client_body_buffer_size"></a>client_body_buffer_size</h2><p>语法：client_body_buffer_size[ 512k ]<br>默认值：proxy_redirect 8k<br>上下文：http, server, location<br>作用：requestbody的buffer限制，如果requestbody小于buffer，requestBody会写入到内存中，如果大于这个值会写入到临时文件中，临时文件默认在/tmp,可以通过client_body_temp设置目录，注意读写权限。</p><h2 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a>proxy_connect_timeout</h2><p>语法：proxy_connect_timeout [ 60s ];<br>默认值：proxy_connect_timeout 60s;<br>上下文：http, server, location<br>作用：nginx与upstream server的连接超时时间</p><h2 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h2><p>语法：proxy_send_timeout [ 60s ];<br>默认值：proxy_send_timeout 60s;<br>上下文：http, server, location<br>作用：nginx发送数据至upstream server超时, 默认60s, 如果连续的60s内没有发送1个字节, 连接关闭</p><h2 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h2><p>语法：proxy_read_timeout [ 60s ];<br>默认值：proxy_read_timeout 60s;<br>上下文：http, server, location<br>作用：nginx接收upstream server数据超时, 默认60s, 如果连续的60s内没有收到1个字节, 连接关闭</p><h2 id="proxy-buffering"><a href="#proxy-buffering" class="headerlink" title="proxy_buffering"></a>proxy_buffering</h2><p>语法：proxy_buffering on|off<br>默认值：proxy_buffering 0n<br>上下文：http,server,location<br>作用：开启从后端被代理服务器的响应内容缓冲，upstream服务器会将响应保存在proxy_buffer_size和proxy_buffers指定的缓冲器内</p><h2 id="proxy-buffer-size"><a href="#proxy-buffer-size" class="headerlink" title="proxy_buffer_size"></a>proxy_buffer_size</h2><p>语法：proxy_buffer_size  the size<br>默认值：proxy_buffer_size 4k/8k<br>上下文：http,server,location<br>作用：该指令设置缓冲区大小,从代理后端服务器取得的第一部分的响应内容,会放到这里.小的响应header通常位于这部分响应内容里边.默认来说,该缓冲区大小等于指令 proxy_buffers所设置的;但是,你可以把它设置得更小。</p><h2 id="proxy-buffers"><a href="#proxy-buffers" class="headerlink" title="proxy_buffers"></a>proxy_buffers</h2><p>语法：proxy_buffers  数量  大小<br>默认值：proxy_buffers 8  4k/8k<br>上下文：http,server,location<br>作用：设置缓冲区的大小和数量,从被代理的后端服务器取得的响应内容,会放置到这里. 默认情况下,一个缓冲区的大小等于内存页面大小,可能是4K也可能是8K,这取决于平台。(getconf PAGE_SIZE 查看)</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate的优化</title>
      <link href="RestTemplate%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>RestTemplate%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>用RestTemplate上传图片发现请求经常超时，修改了下ClientHttpRequestFactory明显有所改善。mark下，具体见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpLogInterceptor httpLogInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">        restTemplate.setRequestFactory(clientHttpRequestFactory());</span><br><span class="line">        restTemplate.setInterceptors(Collections.singletonList(httpLogInterceptor));</span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpClientConnectionManager <span class="title">poolingConnectionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PoolingHttpClientConnectionManager poolingConnectionManager = <span class="keyword">new</span> PoolingHttpClientConnectionManager();</span><br><span class="line">        <span class="comment">// 连接池最大连接数</span></span><br><span class="line">        poolingConnectionManager.setMaxTotal(Runtime.getRuntime().availableProcessors()*<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 每个路由的最大连接数</span></span><br><span class="line">        poolingConnectionManager.setDefaultMaxPerRoute(Runtime.getRuntime().availableProcessors()*<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> poolingConnectionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpClientBuilder <span class="title">httpClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpClientBuilder httpClientBuilder = HttpClientBuilder.create();</span><br><span class="line">        <span class="comment">//设置HTTP连接管理器</span></span><br><span class="line">        httpClientBuilder.setConnectionManager(poolingConnectionManager());</span><br><span class="line">        <span class="keyword">return</span> httpClientBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">clientHttpRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//比 HttpComponentsClientHttpRequestFactory 性能好上传一个10MB文件从10s--&gt;400ms</span></span><br><span class="line">        OkHttp3ClientHttpRequestFactory clientHttpRequestFactory = <span class="keyword">new</span> OkHttp3ClientHttpRequestFactory();</span><br><span class="line">        <span class="comment">// 链接超时，毫秒</span></span><br><span class="line">        clientHttpRequestFactory.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 读写超时，毫秒</span></span><br><span class="line">        clientHttpRequestFactory.setWriteTimeout(<span class="number">10000</span>);</span><br><span class="line">        clientHttpRequestFactory.setReadTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> clientHttpRequestFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-散列表</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="散列表的原理"><a href="#散列表的原理" class="headerlink" title="散列表的原理"></a>散列表的原理</h2><p>底层基于数组实现，数据通过hash函数计算出数组下标写入到数组中，查找通过hash函数找到数据。理论上删除、查找的效率O(1)。</p><h2 id="散列表解决hash冲突"><a href="#散列表解决hash冲突" class="headerlink" title="散列表解决hash冲突"></a>散列表解决hash冲突</h2><p>当key1不等于key2，但是hash(key1)==hash(key2)出现散列的冲突，一般有如下的方式解决。散列冲突可以用loadFactor表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">locafactor = 元素个数/数组长度</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>将散列的hash方法的结果对应成一个bucket或者slot，每个bucket是一个链表。</p><ul><li>写入：当hash冲突后在链表后面追加一个元素。时间复杂度O(1)</li><li>读取：hash找到bucket，遍历链表，时间复杂度O(1)</li><li>删除：hash找到bucket，遍历链表，删除，时间复杂度O(1)</li></ul><p>比较理想的情况下是元素个数=槽数，如果hash冲突比较大会退化成链表</p><p>  优点：对内存要求低，只有写入数据才会在链表中加1；hash冲突代价小，增删改几本上是O(1)<br>  缺点：不是连续空间无法很好利用cpu缓存；链表包含下一个数据的指针序列化成本高<br>  场景：数据量大，负载因子高，频繁修改的场景。HashMap</p><h3 id="开放寻址"><a href="#开放寻址" class="headerlink" title="开放寻址"></a>开放寻址</h3><ul><li>写入：比如key1和key2冲突，key2写入时候发现这个数组下标对应的元素有key1了这时候继续想后遍历知道有一个为空的字段，写入</li><li>读取：找到下标元素后比对如果不相等向后遍历直到找到相等的元素或者第一个为空的元素为止</li><li><p>删除：由于上面说的查找需要遍历到为空的元素，所以需要用到标记删除法。</p><p>优点：内存是连续地址很好的用到cpu的缓存；不包含指针序列化成本低<br>缺点：内存要求高；hash冲突成本高，查找、删除、修改可能要遍历数组<br>场景：数据量小，负载因子不高的场景。ThreadLocalMap</p></li></ul><h2 id="构建一个hash散列应该注意的问题"><a href="#构建一个hash散列应该注意的问题" class="headerlink" title="构建一个hash散列应该注意的问题"></a>构建一个hash散列应该注意的问题</h2><h3 id="hash算法高效"><a href="#hash算法高效" class="headerlink" title="hash算法高效"></a>hash算法高效</h3><ul><li>自身算法效率要高，否则资源会大量浪费在hashkey的计算上。</li><li>算法要均匀尽量避免hash冲突，防止退化成链表</li></ul><p>具体算法有：直接寻址法、平方取中法、折叠法、随机数法</p><h3 id="如何避免装载因子多大"><a href="#如何避免装载因子多大" class="headerlink" title="如何避免装载因子多大"></a>如何避免装载因子多大</h3><p>由于装载因子都大会导致hash冲突几率变高，链表过长，这时候如果是动态的散列表我们要进行”动态扩容“。</p><ul><li>一般会设定一个负载因子的阈值打到阈值后开始扩容，扩容到原来的两倍，负载因子值会下降一半。动态扩容的事件复杂度是O(n)</li><li>如果系统对于内存的使用不敏感，对于响应敏感，为了防止hash冲突可以把负载因子值调低</li><li>如果系统对于内存的使用敏感，对于响应速度不敏感，可以将这个负载因子阈值调高，甚至可以大于1。</li></ul><h3 id="如何避免低效扩容"><a href="#如何避免低效扩容" class="headerlink" title="如何避免低效扩容"></a>如何避免低效扩容</h3><p>在散列表很大时候扩容有可能阻塞正常的读写操作，比如：1G的数据扩容到2G。这时候我们可以采用如下方案：</p><ul><li>在额外申请一块2G的空间，新的写入操作往新的散列表写，同时将一个老的数据写过来，几次之后老的数据就会完成迁移</li><li>读的时候先从新的里面读取如果没有值在从老的数据里面读取</li></ul><h2 id="hash表和其他数据结构共用的案例"><a href="#hash表和其他数据结构共用的案例" class="headerlink" title="hash表和其他数据结构共用的案例"></a>hash表和其他数据结构共用的案例</h2><h2 id="实现高效的lru算法"><a href="#实现高效的lru算法" class="headerlink" title="实现高效的lru算法"></a>实现高效的lru算法</h2><p>如果实现LRU算法用双向链表，访问、更新一个元素需要遍历链表，时间复杂度是O(n),如果想提高效率需要用到散列表配合</p><p>散列表+双向链表</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> LRUNode <span class="keyword">struct</span> &#123;</span><br><span class="line">  Prev *LRUNode <span class="comment">//Lru双向链表</span></span><br><span class="line">  Next *LRUNode <span class="comment">//Lru双向链表</span></span><br><span class="line">  Data <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">  Hnext *LRUNode  <span class="comment">//散列值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  访问：其中prev+next是双向链表用来实现LRU功能，每次访问节点先从hashTable中获取数据，然后将数据移到链表尾部。时间复杂度O(1)<br>  写入：插入到散列中Hnext是用来维护散列的拉链，这里用的是链表来解决hash冲突，同时插入链表的尾部。时间复杂度O(1)<br>  删除：找到数据从散列中删除，然后在从链表中删除。时间复杂度O(1)</p><p>java的LinkedHashMap也是用这个思想实现的。</p><h2 id="redis的sortset"><a href="#redis的sortset" class="headerlink" title="redis的sortset"></a>redis的sortset</h2><p>  用跳表来实现，用score查找、排序、按照sorce范围查找。<br>  用散列来实现，用key查找、删除、插入。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Hash </tag>
            
            <tag> 散列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-跳表</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><ul><li>数组的特点是支持随机访问，随机访问方便，但是插入、删除、修改比较麻烦【时间复杂度是O(N)】</li><li>链表的特点是不支持随机访问【时间复杂度是O(N)】，但是插入、删除、修改比较方便【时间复杂度是O(1)】</li></ul><p>如果业务在效率上要兼顾随机访问和修改，是否有好的方案呢，就是我们今天的主角–跳表（skiplist），甚至在某些方便可以取代红黑叔</p><h2 id="跳表的原理以及事件复杂度"><a href="#跳表的原理以及事件复杂度" class="headerlink" title="跳表的原理以及事件复杂度"></a>跳表的原理以及事件复杂度</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>跳表的底层依赖是链表，但是在链表上层加了索引层。每个节点都包含一个down指针，索引层的节点的down指针指向下一层的节点,如图:<br><img src="skiplist-1.jpg" alt="avator"><br>查找时候先从上遍历索引层确定范围，然后通过down指针逐层在缩小的数据范围内找到数据。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度<br>  查询：O(mlogN),m是每层遍历都少个节点<br>  修改：O(logN)<br>空间复杂度<br>  O(n):由于链表增加了索引层，索引层一般是一个等比数列，比如说：没2个节点建立一个索引，所以空间复杂度是n/2+n/4+n/8+n+4+2=n-2。</p><h2 id="跳表最坏情况"><a href="#跳表最坏情况" class="headerlink" title="跳表最坏情况"></a>跳表最坏情况</h2><p>动态更新如果增修改数据层，或者添加不平很会导致跳表退化成链表如图，所以需要一个随机函数，随机的将节点添加到任意一层索引层，比如随机函数生成了k，要讲节点添加到1~k层<br><img src="skiplist-2.jpg" alt="avator"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>数据有序、能利用到2分发对数据进行查找、同时兼顾修改的效率（redsi的sortSet）。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 跳表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发案例分析-高性能队列Disruptor的设计</title>
      <link href="JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
      <url>JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97Disruptor%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Disruptor的使用方法"><a href="#Disruptor的使用方法" class="headerlink" title="Disruptor的使用方法"></a>Disruptor的使用方法</h2><ol><li>生产消费针对对象event,定义Event</li><li>构造Disruptor时候需要实现一个EventFactory，这里是LongEvent::new</li><li>消费者要注册是一个handleEvent</li><li>生产者要通过publishEvent</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 Event</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定 RingBuffer 大小,</span></span><br><span class="line"><span class="comment">// 必须是 2 的 N 次方</span></span><br><span class="line"><span class="keyword">int</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Disruptor</span></span><br><span class="line">Disruptor&lt;LongEvent&gt; disruptor</span><br><span class="line">  = <span class="keyword">new</span> Disruptor&lt;&gt;(</span><br><span class="line">    LongEvent::<span class="keyword">new</span>,</span><br><span class="line">    bufferSize,</span><br><span class="line">    DaemonThreadFactory.INSTANCE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件处理器</span></span><br><span class="line">disruptor.handleEventsWith(</span><br><span class="line">  (event, sequence, endOfBatch) -&gt;</span><br><span class="line">    System.out.println(<span class="string">"E: "</span>+event));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 Disruptor</span></span><br><span class="line">disruptor.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 RingBuffer</span></span><br><span class="line">RingBuffer&lt;LongEvent&gt; ringBuffer</span><br><span class="line">  = disruptor.getRingBuffer();</span><br><span class="line"><span class="comment">// 生产 Event</span></span><br><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">0</span>; <span class="keyword">true</span>; l++)&#123;</span><br><span class="line">  bb.putLong(<span class="number">0</span>, l);</span><br><span class="line">  <span class="comment">// 生产者生产消息</span></span><br><span class="line">  ringBuffer.publishEvent(</span><br><span class="line">    (event, sequence, buffer) -&gt; event.set(buffer.getLong(<span class="number">0</span>)), bb);</span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Disruptor高效的要点"><a href="#Disruptor高效的要点" class="headerlink" title="Disruptor高效的要点"></a>Disruptor高效的要点</h2><ol><li>数据结构采用RingBuffer并且针对RingBuffer做了如下的优化，初始化时候利用EventFactory的newInstance方法创建所有的元素，<ol><li>由于一起创建所以这些元素在内存地址上是连续的，在消费元素时候有效的理由了CPU缓存（程序的局部性）当消费元素a的时候，a+1会加载到CPU的cashe中。</li><li>在生产元素时候，利用setEvent这种方式重用对象，避免重新创建对象频繁的gc</li></ol></li><li>解决伪缓存的方式：利用内存填充的方式防止变量共享一个缓存行，在无锁的并发情况下导致缓存行重复失效。</li><li>CAS的无锁设计高效生产消费队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者获取 n 个写入位置</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//cursor 类似于入队索引，指的是上次生产到这里</span></span><br><span class="line">  current = cursor.get();</span><br><span class="line">  <span class="comment">// 目标是在生产 n 个</span></span><br><span class="line">  next = current + n;</span><br><span class="line">  <span class="comment">// 减掉一个循环</span></span><br><span class="line">  <span class="keyword">long</span> wrapPoint = next - bufferSize;</span><br><span class="line">  <span class="comment">// 获取上一次的最小消费位置</span></span><br><span class="line">  <span class="keyword">long</span> cachedGatingSequence = gatingSequenceCache.get();</span><br><span class="line">  <span class="comment">// 没有足够的空余位置</span></span><br><span class="line">  <span class="keyword">if</span> (wrapPoint&gt;cachedGatingSequence || cachedGatingSequence&gt;current)&#123;</span><br><span class="line">    <span class="comment">// 重新计算所有消费者里面的最小值位置</span></span><br><span class="line">    <span class="keyword">long</span> gatingSequence = Util.getMinimumSequence(</span><br><span class="line">        gatingSequences, current);</span><br><span class="line">    <span class="comment">// 仍然没有足够的空余位置，出让 CPU 使用权，重新执行下一循环</span></span><br><span class="line">    <span class="keyword">if</span> (wrapPoint &gt; gatingSequence)&#123;</span><br><span class="line">      LockSupport.parkNanos(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从新设置上一次的最小消费位置</span></span><br><span class="line">    gatingSequenceCache.set(gatingSequence);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cursor.compareAndSet(current, next))&#123;</span><br><span class="line">    <span class="comment">// 获取写入位置成功，跳出循环</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 案例分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发案例分析-Netty于Reactor模式</title>
      <link href="JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-Netty%E4%BA%8EReactor%E6%A8%A1%E5%BC%8F/"/>
      <url>JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-Netty%E4%BA%8EReactor%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="BIO的问题"><a href="#BIO的问题" class="headerlink" title="BIO的问题"></a>BIO的问题</h2><p> 痛点：因为JAVA和操作系统的BIO操作是阻塞的，也就是说在读操作的时候线程会被阻塞住。<br> 解决方案：</p><ul><li>利用Thread-Per-Message模式每个IO操作都用一个线程。</li><li>问题：在java中由于线程对象较重，在链接不多的时候还可以一旦链接很多的场景很块就会出现问题。</li></ul><h2 id="Nio和WorkThread模式"><a href="#Nio和WorkThread模式" class="headerlink" title="Nio和WorkThread模式"></a>Nio和WorkThread模式</h2><p>  我们可以利用WorkThread模式采用线程池来处理这种情况么？答案是BIO不可以因为BIO的IO操作会阻塞线程。这时候就要用到NIO。<br>  NIO的IO操作是不会阻塞线程的：<br>  以select模型为例子，简单来说：当一个IO请求发出后，不会阻塞当前线程，用户态的selecter会一直轮询FD检查是否IO请求的数据是否准备好，内核态会去准备数据，一旦内核态的数据准备好，会通知FD已经准备好<br>  这时候我们的WorkThread可以对这些准备好的FD去处理。</p><p>  上述这种模式我们叫它Reactor模式</p><h2 id="Reactor模式的示例"><a href="#Reactor模式的示例" class="headerlink" title="Reactor模式的示例"></a>Reactor模式的示例</h2><p><img src="./reactor01.png" alt="avator"></p><ul><li>Reactor：模式中最重要的类：<ul><li>负责调用操作系统的Selecter.select()函数，获取准备好的io-handlers</li><li>遍历io-handlers交给EventHandler</li><li>注册、移除EventHandler</li></ul></li><li>EventHandler:io请求的逻辑处理类</li><li>Selecter：封装操作系统IO模型的选择器epoll、select</li><li>io-heandler：封装操作系统io请求类</li></ul><h2 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h2><p><img src="./reactor02.png" alt="avator"></p><p>  如图：netty中的Reactor类就是EventLoop，Soekcet和Eventloop是稳定的多对1关系，而线程和EventLoop是稳定的1对1关系。绑定关系见源码的register<br>  而eventloop是封装在一个EventLoopGroup中的并且在其中实现了负载均衡。<br>  注意：netty的服务端往往需要俩个EventLoopGroup</p><ul><li>boosGroup用于处理io的链接请求，如果监听一个端口值需要分配一个eventloop否则会浪费</li><li>workGroup处理具体io的操作。</li></ul><p>原因是，操作系统的io决定的创建链接后会生成一个新的socker，为了性能我们会将这个socket放在其他的group中。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 案例分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发案例分析-Guava中的限流与高效令牌桶算法</title>
      <link href="JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/"/>
      <url>JAVA%E5%B9%B6%E5%8F%91%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90-%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="令牌桶算法的作用"><a href="#令牌桶算法的作用" class="headerlink" title="令牌桶算法的作用"></a>令牌桶算法的作用</h2><p>  主要使用场景–限流。服务器在处理上游的请求时候为了防止资深被打垮往往需要限流这种保护机制，其中有一种算法是令牌桶算法。<br>  即：在指定的时间内允许一定的请求通过。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li>方案1：生产者模式，消费者模式。用一个阻塞队列初始好令牌，请求来了从队列里消费，然后另外的线程按照一定速度往队列里增加令牌。缺点：在高并发场景下，线程调度的误差会变大，同时本身会创建线程调度会影响到线上的服务</li><li>方案2：因为令牌是按照事件产生的，我们可以利用时间关系来创建”令牌“<ul><li>我们在桶中初始化令牌数，并且设置下一个产生令牌的时间next</li><li>如果当前请求时间now大于next，则计算产生的令牌，同时更新next的值为now。</li><li>取令牌，如果是令牌桶中取的不更新next，如果令牌桶没有了更新next时间</li><li>计算现在时间和next的差值，进行限流策略（阻塞或者返回错误）</li></ul></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleLimit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> next = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> intrval = <span class="number">1_000_000_000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> permitSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleLimit</span><span class="params">(<span class="keyword">long</span> permitSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.permitSize = permitSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算产生了多少令牌</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rsync</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; next) &#123;</span><br><span class="line">            <span class="keyword">long</span> permits = (now - next) / intrval;</span><br><span class="line"></span><br><span class="line">            permitSize = Math.min(permitSize, permitSize + permits);</span><br><span class="line"></span><br><span class="line">            next = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        rsync(now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> at = next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果从桶里取的next不更新，如果桶里没有了next更新</span></span><br><span class="line">        <span class="keyword">long</span> pf = Math.min(<span class="number">1</span>, permitSize);</span><br><span class="line">        <span class="keyword">long</span> nr = <span class="number">1</span> - pf;</span><br><span class="line">        next = next + nr * intrval;</span><br><span class="line"></span><br><span class="line">        permitSize -= pf;</span><br><span class="line">        <span class="keyword">return</span> at;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> at = reserve(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否应该限流，因为桶没了next更新所以at&gt;now这时候休眠</span></span><br><span class="line">        <span class="keyword">long</span> waitTime = Math.max(at - now, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.NANOSECONDS.sleep(waitTime);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 案例分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产者消费者模式--解耦整个业务</title>
      <link href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="生产者消费者模式的使用场景和作用"><a href="#生产者消费者模式的使用场景和作用" class="headerlink" title="生产者消费者模式的使用场景和作用"></a>生产者消费者模式的使用场景和作用</h1><ol><li>业务解耦：产者负责生产任务丢给队列，消费者负责从队列中获取任务做逻辑</li><li>削峰：串行的业务往往会导致服务夯住，如果采用生产者消费者，消费者负责将业务丢给队列即可返回，消费者可独立扩容多个来负责消费任务</li></ol><h2 id="消费者模式的几种实现"><a href="#消费者模式的几种实现" class="headerlink" title="消费者模式的几种实现"></a>消费者模式的几种实现</h2><h3 id="批量消费"><a href="#批量消费" class="headerlink" title="批量消费"></a>批量消费</h3><p>我们可以从队列中一个个的消费任务，但是在某些场景下我们其实批量的执行任务会更提高效率，比如异步写入数据的逻辑，一条条会建很多链接，我们可以一次拉取N个任务一次执行，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> batchSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BatchJob&lt;T&gt; job;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService pool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BatchQueue</span><span class="params">(BatchJob&lt;T&gt; job, <span class="keyword">int</span> batchSize, <span class="keyword">int</span> consumerSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = batchSize;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">        pool = Executors.newFixedThreadPool(consumerSize);</span><br><span class="line">        pool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//异步消费</span></span><br><span class="line">                List&lt;T&gt; tasks = pollTask();</span><br><span class="line">                job.run(tasks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">        queue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;T&gt; <span class="title">pollTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        T task = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task = queue.take();<span class="comment">//减少循环第一次先等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> &amp;&amp; list.size() &lt; batchSize) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环里用poll，满足batchSize或者为空返回</span></span><br><span class="line">            list.add(task);</span><br><span class="line">            task = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchJob</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(List&lt;T&gt; task)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BatchQueue&lt;Object&gt; queue = <span class="keyword">new</span> BatchQueue&lt;&gt;(<span class="keyword">new</span> BatchJob&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(List&lt;Object&gt; task)</span> </span>&#123;</span><br><span class="line">                System.out.println(task.size());</span><br><span class="line">                System.out.println(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            queue.addTask(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="俩阶段提交"><a href="#俩阶段提交" class="headerlink" title="俩阶段提交"></a>俩阶段提交</h3><p>之前讨论Mysql的时候，我们提到过Mysql脏页的俩阶段提交，我们也可以使用消费者模式来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LinkedBlockingQueue&lt;T&gt; queue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> ptf = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(T task)</span> </span>&#123;</span><br><span class="line">    queue.add(task);</span><br><span class="line">    </span><br><span class="line">    ExecutorService executorService=Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    executorService.execute(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumer();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object obj = queue.poll(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"write"</span>);</span><br><span class="line">            <span class="comment">//write to</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//级别等于Error or 500条 or &gt;=5秒</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">500</span> || System.currentTimeMillis() - ptf &gt;= <span class="number">5000L</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"flush"</span>);</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">            ptf = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅的终止线程--俩阶段终止</title>
      <link href="%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B-%E4%BF%A9%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2/"/>
      <url>%E4%BC%98%E9%9B%85%E7%9A%84%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B-%E4%BF%A9%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="如何正确的终止线程"><a href="#如何正确的终止线程" class="headerlink" title="如何正确的终止线程"></a>如何正确的终止线程</h1><p>  线程终止的方法往往是运行完成、或者异常终止。但是如何正确的让线程T1优雅终止线程T2呢？<br>  我们的JAVA提供线程的interrupt方法用来通知如何停掉线程，但是在实现上要注意以下问题</p><ol><li>interrupt会导致线程的wait和sleep抛出InterruptedException，在处理完该异常时候interrupt会被重置为false</li><li>第三方包有可能未正确处理interrupt，所以最佳实践是我们要自己处理线程停止标记位也就是下面的stop</li><li><p>也不能只依赖标记位，因为很可能这时候线程处于wait或者block状态，所以应该标记位+interrupt方法一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread work;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean lock = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.get()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        work = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">                System.out.println(<span class="string">"======job run!!!===="</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//重置中断标记位</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.compareAndSet(<span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">"======job stop===="</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        work.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方式单纯的interrupt没有被正确处理，所以标志位置为终止</span></span><br><span class="line">        stop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//防止线程睡眠</span></span><br><span class="line">        work.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程分工模式--Thread-Per-Message模式</title>
      <link href="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E5%B7%A5%E6%A8%A1%E5%BC%8F-Thread-Per-Message%E6%A8%A1%E5%BC%8F/"/>
      <url>%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%86%E5%B7%A5%E6%A8%A1%E5%BC%8F-Thread-Per-Message%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>从名字可以看出，为每一个任务或者消息分配一个线程，适用于类似httpServer的场景，为每一个请求分配一个线程去执行。但是在java中创建线程的成本比较高（线程创建耗时且线程占用的内存较大）有俩种取代方案</p><ol><li>用线程池取代，利用线程的复用思想</li><li>用更轻量的线程方案取代，golang中的协程，java中loom中的Fiber</li></ol><p>注：多线程分工模式下这个应该是最简单的方案了</p><h2 id="java中的另一个模式WorkThread模式"><a href="#java中的另一个模式WorkThread模式" class="headerlink" title="java中的另一个模式WorkThread模式"></a>java中的另一个模式WorkThread模式</h2><p>java创建线程、以及线程切换的开销很重，所以我们可以采用workThread模式即用线程池，来复用线程。</p><h3 id="workthrea的“坑”"><a href="#workthrea的“坑”" class="headerlink" title="workthrea的“坑”"></a>workthrea的“坑”</h3><p>由于线程池中的任务有相互依赖关系，导致线程池因为没有资源被死锁，见下面：</p><ol><li>开辟线程池</li><li>避免线程池的共享</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//L1、L2 阶段共用的线程池</span></span><br><span class="line">ExecutorService es = Executors.</span><br><span class="line">  newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//L1 阶段的闭锁    </span></span><br><span class="line">CountDownLatch l1=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">  System.out.println(<span class="string">"L1"</span>);</span><br><span class="line">  <span class="comment">// 执行 L1 阶段任务</span></span><br><span class="line">  es.execute(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//L2 阶段的闭锁 </span></span><br><span class="line">    CountDownLatch l2=<span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 执行 L2 阶段子任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++)&#123;</span><br><span class="line">      es.execute(()-&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"L2"</span>);</span><br><span class="line">        l2.countDown();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待 L2 阶段任务执行完</span></span><br><span class="line">    <span class="comment">// for循环俩个线程都会在l2.await()时候阻塞住,因为线程池只有2个l1 l2共享线程池且有关联，所以没有资源了</span></span><br><span class="line">    l2.await();</span><br><span class="line">    l1.countDown();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等着 L1 阶段任务执行完</span></span><br><span class="line">l1.await();</span><br><span class="line">System.out.println(<span class="string">"end"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balking模式：再谈线程安全的单例模式</title>
      <link href="Balking%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%86%8D%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>Balking%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%86%8D%E8%B0%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>我们在双重检查模式的单例中最外层的if就是Balking模式的一种体现，即快速返回错误。这样不用每次都进入到synchronized加锁</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guarded Suspension模式：等待唤醒机制的规范实现</title>
      <link href="Guarded-Suspension%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0/"/>
      <url>Guarded-Suspension%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6%E7%9A%84%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>  前面提到了在RPC调用中的同步转异步的过程，见Dubbo的DefaultFeture。<br>  我们把这种模式成为Guarded Suspension（守护挂起），又称多线程的if，有一下几个特点</p><ol><li>创建一个GuardedObject包含ID和Response对象，并且在get是否判断Response对象是否为空，如果为空该线程wait住</li><li>在其他的线程对GuardedObject的Response赋值，并且notify。</li><li>主要get和setResponse的要加锁。</li></ol><p>具体实现见下面</p><ol><li>通过GuardObject.create创建一个实例</li><li>通过get()方法获取并且阻塞住</li><li>返回时候其他线程通过通过GuardObject.objArraived赋值</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, GuardObject&gt; container = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">   private Lock lock = new ReentrantLock();</span><br><span class="line">   private Condition wait = lock.newCondition();</span><br><span class="line"></span><br><span class="line">   private String id;</span><br><span class="line">   private T obj;</span><br><span class="line"></span><br><span class="line">   private GuardObject(String id) &#123;</span><br><span class="line">       this.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 创建并且放在容器中</span><br><span class="line">    * @param id</span><br><span class="line">    * @param &lt;T&gt;</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public static &lt;T&gt; GuardObject&lt;T&gt; create(String id) &#123;</span><br><span class="line">       GuardObject&lt;T&gt; guardObject = new GuardObject&lt;&gt;(id);</span><br><span class="line">       container.put(id, guardObject);</span><br><span class="line">       return guardObject;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //判断条件</span><br><span class="line">   private boolean isArrived() &#123;</span><br><span class="line">       return obj != null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //为response赋值</span><br><span class="line">   public static &lt;T&gt; void objArraived(String id, T obj) &#123;</span><br><span class="line">       GuardObject&lt;T&gt; guardObject = container.get(id);</span><br><span class="line">       if (guardObject == null) &#123;</span><br><span class="line">           throw new RuntimeException(&quot;not exists&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       guardObject.arrived(obj);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //等待通知机制</span><br><span class="line">   private void arrived(T obj)&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           this.obj = obj;</span><br><span class="line">           wait.signalAll();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   public T get() &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           //最佳实现，没有response等待</span><br><span class="line">           while (!isArrived()) &#123;</span><br><span class="line">               //等待，增加超时机制</span><br><span class="line">               try &#123;</span><br><span class="line">                   wait.await(10L, TimeUnit.SECONDS);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (!isArrived()) &#123;</span><br><span class="line">                   throw new RuntimeException(&quot;timeout&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       return obj;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public String getId() &#123;</span><br><span class="line">       return id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public T getObj() &#123;</span><br><span class="line">       return obj;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal:减少线程之间的共享</title>
      <link href="ThreadLocal-%E5%87%8F%E5%B0%91%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB/"/>
      <url>ThreadLocal-%E5%87%8F%E5%B0%91%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>解决并发问题最简单的方案就是减少共享，JAVA提供了一个简单的工具类即ThreadLocal，我们会用他来保存线程之间独立存在的变量，比如springmvc中，我们每个请求特有的一些属性。</p><h2 id="ThreadLocal的设计"><a href="#ThreadLocal的设计" class="headerlink" title="ThreadLocal的设计"></a>ThreadLocal的设计</h2><p>在设计上JAVA的Thread内部类会持有一个ThreadLocalMap的对象threadLocals,Map的结构（ThreadLocal,Value），其中ThreadLocal是弱引用。<br>这么做的设计有俩点：</p><ol><li>因为ThreadLocal对象和线程的声明周期息息相关，从数据的亲原性来讲，由Thread对象管理更为合适</li><li>防止内存泄露，因为ThreadLocal内部持有线程和Value的对应关系，当线程声明结束后，ThreadLocal中的Thread对象不会主动释放。从而造成内存泄露</li></ol><h2 id="ThreadLocal的内存泄露"><a href="#ThreadLocal的内存泄露" class="headerlink" title="ThreadLocal的内存泄露"></a>ThreadLocal的内存泄露</h2><p>  在线程池中，Thread的生命周期往往很长，而因为ThreadLocalMap对于ThreadLocal是软引用，所以当ThreadLocal没有引用时候会被释放掉，但是Value确是强引用，所以会造成ThreadLocal释放掉了，但是Value没法释放导致内存泄露</p><p>  解决方法：手动释放</p><h2 id="InheritableThreadLocal继承性"><a href="#InheritableThreadLocal继承性" class="headerlink" title="InheritableThreadLocal继承性"></a>InheritableThreadLocal继承性</h2><p>因为ThreadLocal是线程不共享的，所以如果线程在创建一个子线程是看不到主线程ThreadLocal对象的值的，为了让子线程能看到父类线程提供InheritableThreadLocal，但是不建议使用，因为往往会导致子线程修改了值引起主线程的逻辑混乱。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Copy-on-Write模式Copy-on-Write模式：不是延时策略的COW</title>
      <link href="Copy-on-Write%E6%A8%A1%E5%BC%8FCopy-on-Write%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%8D%E6%98%AF%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5%E7%9A%84COW/"/>
      <url>Copy-on-Write%E6%A8%A1%E5%BC%8FCopy-on-Write%E6%A8%A1%E5%BC%8F%EF%BC%9A%E4%B8%8D%E6%98%AF%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5%E7%9A%84COW/</url>
      
        <content type="html"><![CDATA[<p>在操作系统和编程领域中充斥这大量的CoW。linux的进程fork,redis扩容时候的cow策略，以及java中的CopyOnWriteArrayList和CopyOnWriteArraySet等。</p><h2 id="JAVA中的CoW"><a href="#JAVA中的CoW" class="headerlink" title="JAVA中的CoW"></a>JAVA中的CoW</h2><p>我们在面试会经常问List或者Set的线程安全的替代方案是什么？Vector但是Vector性能不高，性能高的替代方案是什么呢？就是CopyOnWriteArrayList和CopyOnWriteArraySet。</p><p>Cow容器的缺点：</p><ol><li>因为在修改时候会复制整个容器，所以是以牺牲内存为代价的</li><li>因为复制容器所以在访问时候会有一定的时延。</li></ol><h2 id="Cow的原理和使用场景"><a href="#Cow的原理和使用场景" class="headerlink" title="Cow的原理和使用场景"></a>Cow的原理和使用场景</h2><p>在读取数据的时候共享，在修改的时候会开始复制，并且为了保证线程安全可能会在复制时候采取阻塞策略。使用场景读多写少。</p><h2 id="额外的思考"><a href="#额外的思考" class="headerlink" title="额外的思考"></a>额外的思考</h2><p>redis的cow的扩容机制</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Immutability模式：如何利用不变性解决并发问题？</title>
      <link href="Immutability%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>Immutability%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%8D%E5%8F%98%E6%80%A7%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>并发情况下如果对一个共享变量进行读写就会有并发问题，如果只有读是没有并发问题的，所以解决并发问题的一个重要思路就是不提供变量的写的功能</p><h2 id="如何快速实现不可变类"><a href="#如何快速实现不可变类" class="headerlink" title="如何快速实现不可变类"></a>如何快速实现不可变类</h2><ol><li>类的声明以及属性都要声明成final对象（类的声明是为了防止子类继承父类修改父类的属性）</li><li>只提供只读的方法，如果要修改对象，去创建一个新的不可变对象。</li></ol><p>例如String，是典型的一个不可变对象，String中的replace对象在修改时候我们是创建了一个新的不可变对象</p><h2 id="利用flyweight模式减少重复对象的创建"><a href="#利用flyweight模式减少重复对象的创建" class="headerlink" title="利用flyweight模式减少重复对象的创建"></a>利用flyweight模式减少重复对象的创建</h2><p>由于不可变对象不能修改，如果遇到修改话可能会产生大量的对象占用系统内存,为了避免这种情况发生JAVA采用了flyweight模式来减少对象的产生，用一句话概述</p><p>  提前缓存好一部分对象，如果没有在去创建，如果有就直接取用，因为这些对象是不可变的共享完全没问题。<br>  比较特殊的是Long，因为对象范围比较大，所以Long只保存了-128-127的对象。具体见代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">  <span class="comment">// [-128,127] 直接的数字做了缓存</span></span><br><span class="line">  <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> LongCache</span><br><span class="line">      .cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 缓存，等价于对象池</span></span><br><span class="line"><span class="comment">// 仅缓存 [-128,127] 直接的数字</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LongCache</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Long cache[]= <span class="keyword">new</span> Long[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cache.length; i++)</span><br><span class="line">      cache[i] = <span class="keyword">new</span> Long(i-<span class="number">128</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不可变对象的属性即时声明了不可变，但是他的属性也有可能改变如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Foo 线程安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">    String name = <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Foo foo=<span class="keyword">new</span> Foo();<span class="comment">//可改变foo里的属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] i=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//可改变数组元素</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        foo.age=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可变类作为属性本身不具备不可见性并且是线程不安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Foo 线程安全</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> age=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> name=<span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Bar 线程不安全</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  Foo foo;<span class="comment">//并发时候会有问题</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setFoo</span><span class="params">(Foo f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.foo=f;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Future：如何用多线程实现最优的“烧水泡茶”程序？</title>
      <link href="Future%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%80%E4%BC%98%E7%9A%84%E2%80%9C%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6%E2%80%9D%E7%A8%8B%E5%BA%8F%EF%BC%9F/"/>
      <url>Future%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%9C%80%E4%BC%98%E7%9A%84%E2%80%9C%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6%E2%80%9D%E7%A8%8B%E5%BA%8F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>线程池中可以通过Future模式实现对异步任务的状态的监控和获取异步任务的结果，具体见ExecutorService下的3个方法</p><h2 id="获取异步任务的结果"><a href="#获取异步任务的结果" class="headerlink" title="获取异步任务的结果"></a>获取异步任务的结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交 Runnable 任务</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task)</span><br><span class="line"><span class="comment">// 提交 Callable 任务</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"><span class="comment">// 提交 Runnable 任务及结果引用  </span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个方法是无返回值很类似join方法<br>第二个方法是可以获取task的返回值<br>第三个方法是可以通过T result来实现俩个线程之间的交互。如下</p><h2 id="FutreTask"><a href="#FutreTask" class="headerlink" title="FutreTask"></a>FutreTask</h2><p>和Furtre很类似但是它继承自Furture和Runable可以作为对象传递给线程池或者线程。然后通过get来获取执行结果。如下代码，开水泡茶问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"洗茶杯"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"找茶叶"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"龙井"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; ft1 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"洗茶壶"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"烧水"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">            System.out.println(<span class="string">"水开了"</span>);</span><br><span class="line">            String ret = ft2.get();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"上茶"</span>+ret;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        executor.submit(ft1);</span><br><span class="line">        executor.submit(ft2);</span><br><span class="line">        System.out.println(ft1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>近期的使用场景：<br>  比如一个很大的列表查询，你可以拆分成10个线程同时查询然后在查询完后合并成一个结果集。</p><h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>简化Future的线程调度难度。构造函数是4个静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认线程池</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 可以指定线程池  对于IO这种消耗线程的方式强烈推荐</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br></pre></td></tr></table></figure><p>ft1完成后执行的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Function对象有参数有返回值</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenApply</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenApplyAsync</span><span class="params">(fn)</span></span>;</span><br><span class="line"></span><br><span class="line"># Consumer对象有参数无返回值</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(consumer)</span></span>;</span><br><span class="line"></span><br><span class="line"># Runnable对象无参数无返回值</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRun</span><span class="params">(action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(action)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCompose</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenComposeAsync</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="And合并关系"><a href="#And合并关系" class="headerlink" title="And合并关系"></a>And合并关系</h3><p>ft1、ft2都结束后做一些操作，类似join。方法区别如上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombine</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">thenCombineAsync</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(other, action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="OR或者关系"><a href="#OR或者关系" class="headerlink" title="OR或者关系"></a>OR或者关系</h3><p>ft1、ft2有一个完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage <span class="title">applyToEither</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">applyToEitherAsync</span><span class="params">(other, fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">acceptEither</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">acceptEitherAsync</span><span class="params">(other, consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">runAfterEither</span><span class="params">(other, action)</span></span>;</span><br><span class="line"><span class="function">CompletionStage <span class="title">runAfterEitherAsync</span><span class="params">(other, action)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CompletionStage <span class="title">exceptionally</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenComplete</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">whenCompleteAsync</span><span class="params">(consumer)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handle</span><span class="params">(fn)</span></span>;</span><br><span class="line"><span class="function">CompletionStage&lt;R&gt; <span class="title">handleAsync</span><span class="params">(fn)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h2><p>我们用ThreadPool和Future优化了步编程中协作的部分，取代了线程的join。但是我们在实际使用中往往会碰到下面的问题，具体见代码</p><ol><li>运行了3个异步任务，分别用了15s,10s,5s。</li><li>之后会在另一个线程池对这些任务的结果进行计算。这时候在计算的线程池中会变成串行，由于1任务过久，所以任务2，3即便先完成了前面的步骤也要等1完成后在执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; ft1 = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">        System.out.println(<span class="string">"ft1 sleep 15s return 1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; ft2 = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">"ft2 sleep 10s return 2"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Future&lt;Integer&gt; ft3 = threadPool.submit(() -&gt; &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">"ft3 sleep 5s return 3"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ExecutorService calT=Executors.newSingleThreadExecutor();</span><br><span class="line">    Future ftRes=calT.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"save:"</span>+ft1.get());</span><br><span class="line">            System.out.println(<span class="string">"save:"</span>+ft2.get());</span><br><span class="line">            System.out.println(<span class="string">"save:"</span>+ft3.get());</span><br><span class="line">            <span class="comment">//todo 比较大小</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ftRes.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对这段代码进一步优化呢我们可以采用增加阻塞队列的方式。许多人加个阻塞队列就好了。异步执行的结果加入到阻塞队列中，最终通过阻塞队列后去方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Integer&gt; queue=<span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">3</span>);</span><br><span class="line">ExecutorService calT=Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">calT.execute(()-&gt; &#123;</span><br><span class="line">        queue.put(ft1.get());</span><br><span class="line">&#125;);</span><br><span class="line">calT.execute(()-&gt; &#123;</span><br><span class="line">    queue.put(ft2.get());</span><br><span class="line">&#125;);</span><br><span class="line">calT.execute(()-&gt; &#123;</span><br><span class="line">    queue.put(ft3.get());</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"save:"</span>+  queue.take());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"all finish"</span>);</span><br></pre></td></tr></table></figure><p>确实能解决上述的问题，JAVA8之后为我们提供了更方便的写法（实现原理相同）,即：CompletionService,有另种狗仔方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExecutorCompletionService(Executor executor); <span class="comment">//LinkedBlockingQueue 默认使用</span></span><br><span class="line"><span class="keyword">new</span> ExecutorCompletionService(Executor executor,BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span><br></pre></td></tr></table></figure><p>上面的程序可以简写为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ExecutorCompletionService&lt;Integer&gt; ecs=<span class="keyword">new</span> ExecutorCompletionService(threadPool,queue);</span><br><span class="line">       ecs.submit(callable1);</span><br><span class="line">       ecs.submit(callable2);</span><br><span class="line">       ecs.submit(callable3);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">"save:"</span>+   ecs.take().get());</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>关于take()和pool()区别。take()在队列为空会阻塞线程，poll如果队列为空会返回null，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Callable&lt;V&gt; task)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">submit</span><span class="params">(Runnable task, V result)</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Future&lt;V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;<span class="comment">//会等待一段时间。</span></span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Dubbo的Forking Cluster模式,对于实时性较高的操作，consumer端会同时并行调用俩个请求，哪个现有结果优先返回，代码如下，不过缺点是比较浪费资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> fork 并行度是2</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> timeOutMills 超时时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> callable 逻辑方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> &lt;T&gt; 返回值，多个方法返回第一个返回的</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">forkCluster</span><span class="params">(<span class="keyword">int</span> fork, <span class="keyword">int</span> timeOutMills, Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">     ExecutorCompletionService&lt;T&gt; forkService = <span class="keyword">new</span> ExecutorCompletionService(Executors.newFixedThreadPool(fork), <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(fork));</span><br><span class="line">     List&lt;Future&lt;T&gt;&gt; ftContainer=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">         ftContainer.add(forkService.submit(callable));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         T result = forkService.poll(timeOutMills, TimeUnit.MILLISECONDS).get();</span><br><span class="line">         <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回结果为空抛异常"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回结果为空抛异常"</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回结果为空抛异常"</span>);</span><br><span class="line">     &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         ftContainer.forEach(ft-&gt;&#123;</span><br><span class="line">             ft.cancel(<span class="keyword">true</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="Fork-join用分治思想加速我们的递归"><a href="#Fork-join用分治思想加速我们的递归" class="headerlink" title="Fork/join用分治思想加速我们的递归"></a>Fork/join用分治思想加速我们的递归</h2><p>待完善</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原子类:无锁工具类的典范</title>
      <link href="%E5%8E%9F%E5%AD%90%E7%B1%BB-%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/"/>
      <url>%E5%8E%9F%E5%AD%90%E7%B1%BB-%E6%97%A0%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E5%85%B8%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>无锁方案，在竞争冲突不大的情况下比锁性能会高不少。对应JAVA中各种的Atmoic类。实现原理是硬件的支持，CPU提供了原子化的支持即CAS(Compare And Swap)指令。CAS包含3个字段：共享变量的内存地址A；用于比较值B和共享变量的新值C。只有A的值等于B才允许更新成C。作为一条CPU指令其本身就是原子性的。很类似乐观锁的原理。JAVA在实现是是通过自旋来解决的如下伪代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newVal = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cur = ai.get();<span class="comment">//get 单前值 </span></span><br><span class="line">        newVal = cur + <span class="number">10000</span>; <span class="comment">//得到新值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ai.compareAndSet(cur, newVal)); <span class="comment">//失败后自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java中是通过sun.misc.Unsafe来实现的</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch和CyclicBarrier：如何让多线程步调一致?</title>
      <link href="CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4-1/"/>
      <url>CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4-1/</url>
      
        <content type="html"><![CDATA[<p>CountDownLatch和CyclicBarrier主要解决线程的调度问题。例如如下场景:订单的对账，订单系统完成的订单和已经派发的订单的对账，对于有异常的订单要修复。这里是3个操作，见下面伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Order order=getOrder();</span><br><span class="line"></span><br><span class="line">POrder porder=getPOder();</span><br><span class="line"></span><br><span class="line">checkAndFix(order,porder);</span><br></pre></td></tr></table></figure><p>如果每天的订单量很大这就会很耗时，我们可以考虑串行的方法，可以用线程池的方法同时去查询俩个订单，然后在check这时候我们要解决线程调度的问题，CountDownLatch就排上了用场,代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">AtomicReference&lt;Object&gt; order = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line">    order.set(getOrder());</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AtomicReference&lt;Object&gt; porder = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">pool.execute(() -&gt; &#123;</span><br><span class="line">    porder.set(getPOrder());</span><br><span class="line">    countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">checkAndFix(order.get(),porder.get());</span><br></pre></td></tr></table></figure><p>不过这里checkAndFix还是主线程串行的能否在进一步优化呢，答案是能这里用到CyclicBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService callBack = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        Vector&lt;Object&gt; orders=<span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        Vector&lt;Object&gt; porders=<span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>,()-&gt;&#123;</span><br><span class="line">            callBack.execute(()-&gt;&#123;</span><br><span class="line">                checkAndFix( orders.get(<span class="number">0</span>),porders.get(<span class="number">0</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                orders.add(getOrder());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            pool.execute(() -&gt; &#123;</span><br><span class="line">                porders.add(getPOrder());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier和CountDownLatch的区别是可重入的，当见到0还会从2开始。另外CyclicBarrier可以设置Callback</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch和CyclicBarrier：如何让多线程步调一致?</title>
      <link href="CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/"/>
      <url>CountDownLatch%E5%92%8CCyclicBarrier%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%AD%A5%E8%B0%83%E4%B8%80%E8%87%B4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>StampdLock:Java8中的乐观锁</title>
      <link href="StampdLock-Java8%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81/"/>
      <url>StampdLock-Java8%E4%B8%AD%E7%9A%84%E4%B9%90%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>上文中讲到了ReadWriteLock这种读写锁方法作为缓存策略那么有没有效率更高的方法</p><p>重点方法<br>long stamp = stampedLock.tryOptimisticRead();//乐观锁<br>long stamp = stampedLock.readLock(); //悲观读锁<br>long stamp = stampedLock.writeLock();//主观读锁<br>boolean hasWriteLock = stampedLock.validate();//如果有写锁返回false如果没有返回true</p><p>如下面的代码先通过tryOptimisticRead获取一个stamp这个操作是没有锁的，这中间可以读取变量，然后在调用validate方法校验是否有写锁，如果有，将锁升级成读锁。如果没有直接返回。因为没有写锁时候是不加锁的所以效率很高。这点很类似咱们mysql的乐观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead();</span><br><span class="line">        <span class="comment">//无锁操作</span></span><br><span class="line">        <span class="comment">//如果有写锁返回false，升级成悲观读</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123;</span><br><span class="line">            stamp = stampedLock.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//读模板</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写模板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">long</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//todo 写</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReadWriteLock:如何快速实现一个完备的缓存</title>
      <link href="ReadWriteLock-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%BA%8B%E5%85%88%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/"/>
      <url>ReadWriteLock-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%BA%8B%E5%85%88%E4%B8%80%E4%B8%AA%E5%AE%8C%E5%A4%87%E7%9A%84%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="ReadWirteLock的作用和说明"><a href="#ReadWirteLock的作用和说明" class="headerlink" title="ReadWirteLock的作用和说明"></a>ReadWirteLock的作用和说明</h2><p>ReadWriteLock是锁的一种，他适合哪种读多写少的场景，做有名的就是缓存场景。因为他们的读锁是不互斥的，但是读锁和写锁、写锁之间是互斥的。具体使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl =</span><br><span class="line">    <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="comment">// 读锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="comment">// 写锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  <span class="comment">// 读缓存</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 写缓存</span></span><br><span class="line">  <span class="function">V <span class="title">put</span><span class="params">(String key, Data v)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, v); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步的实现懒加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Map&lt;K, V&gt; m =</span><br><span class="line">    <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    V v = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 读缓存</span></span><br><span class="line">    r.lock();         ①</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      v = m.get(key); ②</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      r.unlock();     ③</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中存在，返回</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="keyword">null</span>) &#123;   ④</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 缓存中不存在，查询数据库</span></span><br><span class="line">    w.lock();         ⑤</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 再次验证</span></span><br><span class="line">      <span class="comment">// 其他线程可能已经查询过数据库</span></span><br><span class="line">      v = m.get(key); ⑥</span><br><span class="line">      <span class="keyword">if</span>(v == <span class="keyword">null</span>)&#123;  ⑦</span><br><span class="line">        <span class="comment">// 查询数据库</span></span><br><span class="line">        v= 省略代码无数</span><br><span class="line">        m.put(key, v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">      w.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁的升级和降级"><a href="#读写锁的升级和降级" class="headerlink" title="读写锁的升级和降级"></a>读写锁的升级和降级</h2><p>注意，读写锁是不支持锁的升级的即，在读锁中升级到写锁，因为读锁和写锁互斥，因为读锁升级到写锁的时候，读写锁互斥、写锁需要等待读锁释放，而读锁被写锁阻塞住会造成死锁,但是反过来写锁降级是可以的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReadWriteLock rwl =</span><br><span class="line">    <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="comment">// 读锁  </span></span><br><span class="line">  <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="comment">// 写锁</span></span><br><span class="line">  <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// 释放读锁，因为不允许读锁的升级</span></span><br><span class="line">      r.unlock();</span><br><span class="line">      <span class="comment">// 获取写锁</span></span><br><span class="line">      w.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 再次检查状态  </span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放写锁前，降级为读锁</span></span><br><span class="line">        <span class="comment">// 降级是可以的</span></span><br><span class="line">        r.lock(); ①</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放写锁</span></span><br><span class="line">        w.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处仍然持有读锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;use(data);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;r.unlock();&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semaphore:如何构建限流器</title>
      <link href="Semaphore-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%99%90%E6%B5%81%E5%99%A8/"/>
      <url>Semaphore-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%99%90%E6%B5%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量模型"><a href="#信号量模型" class="headerlink" title="信号量模型"></a>信号量模型</h1><p>如图：</p><p><img src="./信号量模型.png" alt="avatar"></p><p>简单来说就是一个队列，一个计数器，三个方法</p><p> init()–初始化队列和信号量<br> down()–信号量-1如果&lt;0,当前线程阻塞，并且进入队列等待。<br> up()–信号量+1如果&gt;=0,则唤醒一个线程别且把它从当前队列中剔除。</p><h1 id="在java当中的Semaphore的使用"><a href="#在java当中的Semaphore的使用" class="headerlink" title="在java当中的Semaphore的使用"></a>在java当中的Semaphore的使用</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Semaphore s </span><br><span class="line">    = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 用信号量保证互斥    </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  s.acquire();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    count+=<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    s.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量是如何保证原子性的呢？<br>俩个线程都执行s.acquire()是原子性的会修改计数器，假设线程1先执行，所以计数器是0，线程2为-1，因为线程2小于0所以线程2阻塞，并且将当前线程加入到队列中线程1大于等于0所以线程1执行count+=1;这时候线程1执行s.release();计数器为0，大于等于0，所以唤醒队列中的一个线程。</p><h1 id="Semaphore的作用"><a href="#Semaphore的作用" class="headerlink" title="Semaphore的作用"></a>Semaphore的作用</h1><p>和Lock相比可以同时允许多个线程同时访问临界区。下面的代码是事先了一个队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjPool</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">  <span class="comment">// 用信号量实现限流器</span></span><br><span class="line">  <span class="keyword">final</span> Semaphore sem;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  ObjPool(<span class="keyword">int</span> size, T t)&#123;</span><br><span class="line">    pool = <span class="keyword">new</span> Vector&lt;T&gt;()&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sem = <span class="keyword">new</span> Semaphore(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 利用对象池的对象，调用 func</span></span><br><span class="line">  <span class="function">R <span class="title">exec</span><span class="params">(Function&lt;T,R&gt; func)</span> </span>&#123;</span><br><span class="line">    T t = <span class="keyword">null</span>;</span><br><span class="line">    sem.acquire();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      t = pool.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> func.apply(t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      pool.add(t);</span><br><span class="line">      sem.release();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">ObjPool&lt;Long, String&gt; pool = </span><br><span class="line">  <span class="keyword">new</span> ObjPool&lt;Long, String&gt;(<span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过对象池获取 t，之后执行  </span></span><br><span class="line">pool.exec(t -&gt; &#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    <span class="keyword">return</span> t.toString();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-俩分法查找</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="俩分法的时间复杂度"><a href="#俩分法的时间复杂度" class="headerlink" title="俩分法的时间复杂度"></a>俩分法的时间复杂度</h1><p>效率很高，时间复杂度是O(logN)。但是条件也比较苛刻</p><ol><li>必须是有序数组的，支持通过下表随机访问。如果用链表会退化成时间复杂度O(n)</li><li>数组必须有序，所以在查找前需要对数组进行排序，</li><li>数量太小不适合二分查找法。因为在数据量小的时候LogN不见得比遍历数组要快</li><li>数量太大不适合二分查找法，因为数组要申请一片连续空间的内存如果太大，可能内存会不够用。</li></ol><h1 id="二分查找法的俩种实现方式"><a href="#二分查找法的俩种实现方式" class="headerlink" title="二分查找法的俩种实现方式"></a>二分查找法的俩种实现方式</h1><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[l] == dest ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始查找每次取出一半</span></span><br><span class="line">    <span class="keyword">return</span> search(a, l, h, dest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> h, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[l] == dest ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取中点，如果==跳出递归，如果a[mid]&gt;dest 下一次就是l--mid-1，反之下一次是mid+1,high</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid]==dest)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&gt;dest)&#123;</span><br><span class="line">        <span class="keyword">return</span> search(a,l,mid-<span class="number">1</span>,dest);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//a[mid]&lt;dest</span></span><br><span class="line">        <span class="keyword">return</span> search(a,mid+<span class="number">1</span>,h,dest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == h) &#123;</span><br><span class="line">        <span class="keyword">return</span> a[l] == dest ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环查找</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == dest) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; dest) &#123;</span><br><span class="line">            l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           h=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：算一个数的平方跟</p><p>这到例子主要是讲解，二分法的解决思路，先确认查找范围x比1大1–x,如果x在0和1之间0–1,然后用二分法求解mid最接近结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">squart</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速返回</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> h = x;</span><br><span class="line">    <span class="comment">//如果x在0-&gt;1之间</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        h = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        base = base * <span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归调用</span></span><br><span class="line">    <span class="keyword">double</span> ret = squart(x, l, h, <span class="number">1.00f</span> / base);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(ret).setScale(n, BigDecimal.ROUND_HALF_UP).doubleValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">squart</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> l, <span class="keyword">double</span> h, <span class="keyword">float</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= h) &#123;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> mid = l + (h - l) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> squart(x, l, mid, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mid * mid &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> squart(x, mid, h, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分法变形查找"><a href="#二分法变形查找" class="headerlink" title="二分法变形查找"></a>二分法变形查找</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchLastEq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[m] &gt; d) &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; d) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//注意找最后一个eq所以如果相等就判断后一位是否相等如果不相等返回，如果相等，说明要取的值在右边，l=m+1</span></span><br><span class="line">            <span class="keyword">if</span> (m == a.length - <span class="number">1</span> || a[m + <span class="number">1</span>] != d) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"最后个相等%s的Index=%s,v=%s\n"</span>, d, m, a[m]);</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"最后一个相等的没找到"</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchFirstEq</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[m] &gt; d) &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[m] &lt; d) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//注意找第一个eq所以如果相等就判断前一位是否相等如果不相等返回，如果相等，说明要取的值在左边，h=m-1</span></span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span> || a[m - <span class="number">1</span>] != d) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"第一个相等%s的Index=%s,v=%s\n"</span>, d, m, a[m]);</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"第一个相等的没找到"</span>);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ..a[m]...6,7,d,9.....--&gt;7</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> d</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchRecentLte</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如题，找d左边的第一值，当a[m]&lt;=d的时候说明m在左边，然后一直往右边找，直到找到后面大于d的返回，</span></span><br><span class="line">        <span class="comment">// 如果右边依然&lt;=d，说明要找的值还在右边，二分法l=m+1</span></span><br><span class="line">        <span class="comment">// 如果a[m]&gt;d，不符合条件说明要找的值在m的左边，需要h=m-1</span></span><br><span class="line">        <span class="keyword">if</span> (a[m] &lt;= d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span> || a[m + <span class="number">1</span>] &gt; d) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"最后(最近的小于等于)小于等于%s的数的(Index=%s,v=%s)\n"</span>, d, m, a[m]);</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * .....6,7,d,9..a[m]...--&gt;9</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> d</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchRecentGte</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如题：找d右边的第一个值，如果a[m]&gt;=d，要一直向左找，找到m==0或者m的左边小于d的数，返回m</span></span><br><span class="line">        <span class="comment">// 如果a[m-1]依然大于d，说明要照的数在左边，h=m-1</span></span><br><span class="line">        <span class="comment">// 如果a[m]&lt;d，说明要照的数在右边，l=m+1</span></span><br><span class="line">        <span class="keyword">if</span>(a[m]&gt;=d)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">0</span>|| a[m-<span class="number">1</span>]&lt;d)&#123;</span><br><span class="line">                System.out.printf(<span class="string">"第一个(最近的大于等于)大于等于%s的数的(Index=%s,v=%s)\n"</span>, d, m, a[m]);</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            h=m-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//a[m]&lt;d</span></span><br><span class="line">            l=m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课后作业-leetcode33</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">5</span>;</span><br><span class="line">        System.out.println(search(a, target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = a.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l] == d) &#123;</span><br><span class="line">                <span class="keyword">return</span> l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[h] == d) &#123;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> m = l + ((h - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[m] == d) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[m] &gt; a[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[m] &gt; d) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[l] &lt; d) &#123;</span><br><span class="line">                        h = m - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        l = m + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                    a[m]&lt;d</span></span><br><span class="line">                    l = m + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//a[m]&lt;a[l]</span></span><br><span class="line">                <span class="keyword">if</span> (a[m] &gt; d) &#123;</span><br><span class="line">                    h = m - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//a[m]&lt;d</span></span><br><span class="line">                    <span class="keyword">if</span> (a[h] &gt; d) &#123;</span><br><span class="line">                        l = m + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        h = m - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 俩分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-线性排序</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h2><p>因为下面几种排序的事件复杂度接近O(n)，所以我们称其为线性排序</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>将数据有小到达分成m个桶，每个桶内n个元素，然后分别对每个桶进行快速排序，由于桶是有序的，所以在排序完成后不用在排序了。</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>最好时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个桶元素是n/m=&gt;O(m * n/m * logn/m)=&gt;O(n*logn/m)，假设到m和n接近时候，时间复杂度是O(n)</span><br></pre></td></tr></table></figure><p>最坏时间复杂度：当几乎所有数据都几种在一个桶内时候，复杂度会退化为O(nlogn)</p><h4 id="桶排序的试用场景：外部排序"><a href="#桶排序的试用场景：外部排序" class="headerlink" title="桶排序的试用场景：外部排序"></a>桶排序的试用场景：外部排序</h4><p>比如有一个10G的用户数据的文件，对某一项属性排序，内存只有几百MB，我们无法将数据都加载到内存中，我们可以利用桶排序，先扫描文件确认属性的范围，将属性分为m个范围，并且分为m个文件，分别将数据插入到这些文件中，之后对这些文件分别排序。当然如果遇到分布不均匀的情况还要继续划分。</p><p>  如：比如用户10个GB的订单文件，按照金额排序。</p><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">    <span class="comment">//查找最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = getMax(a);</span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分桶（申请一个数组），从0---max每个值一个桶，并且做累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        countArray[a[i]] = countArray[a[i]] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历桶给桶做累加，记录从min--&gt;max，每个值包含他之前的值总共有多少个，用于后面的排序</span></span><br><span class="line">    <span class="keyword">int</span> sum = countArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; countArray.length; i++) &#123;</span><br><span class="line">        sum += countArray[i];</span><br><span class="line">        countArray[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请额外空间</span></span><br><span class="line">    <span class="keyword">int</span>[] ret=<span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">    <span class="comment">//轮询要排序数组a,a的值就是桶的下标。</span></span><br><span class="line">    <span class="comment">// 1.找到a[i]在countArray中对应的count值；</span></span><br><span class="line">    <span class="comment">// 2.这个(count-1)值对应的是排序之后数组的该值的index，将a[i]插入到新数组的ret[count-1]</span></span><br><span class="line">    <span class="comment">// 3.count--;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = a[i];</span><br><span class="line">        <span class="keyword">int</span> count = countArray[v]-<span class="number">1</span>;</span><br><span class="line">        ret[count] = v;</span><br><span class="line">        countArray[v] =count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= a[i]) &#123;</span><br><span class="line">            ret = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路如图：<br><img src="./计数排序过程.jpg" alt="avator"></p><ol><li>找到原数组最大值，申请一个countArray[max+1]</li><li>记录countArray中记录原数组a的每个值的个数，并且对countArray数组每一项求和。这个值就是排序之后的每个元素的下标最大值+1。（意思是这个元素在排序之后的数组中包含他的位置）</li><li>遍历数组a,取v=a[i]的值，取countArray中的count，然后v插入到排序后的数组r的count-1中。</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>只能给正整数排序</li><li>只能给范围不大的数组排序，比如范围k比数组n大很多那就不合适了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用面向对象的思想写好并发程序</title>
      <link href="%E5%A6%82%E4%BD%95%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3%E5%86%99%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F/"/>
      <url>%E5%A6%82%E4%BD%95%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%80%9D%E6%83%B3%E5%86%99%E5%A5%BD%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="防止变量的共享"><a href="#防止变量的共享" class="headerlink" title="防止变量的共享"></a>防止变量的共享</h1><p>在声明一个变量时候要通过方法的封装暴露对象的修改和查询操作，以此为入口来控制变量的并发，对于不变的对象尽量声明成final类型，告诉别人这个便利不会被改变。</p><h1 id="识别共享变量的条件"><a href="#识别共享变量的条件" class="headerlink" title="识别共享变量的条件"></a>识别共享变量的条件</h1><p>防止变量之间的竞态问题，比如下面的代码：设置了上限和下限，这里有个隐含的条件上限一定要&gt;=下限,虽然变量声明成了AtomicLong，但是在并发的时候需改时候遇到if条件可能会造成下限高于上限的问题。原因在于条件判断和修改结果不是原子操作，这是个典型的竞态问题。修改方案是set方法加synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeWM</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 库存上限</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong upper =</span><br><span class="line">        <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 库存下限</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong lower =</span><br><span class="line">        <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 设置库存上限</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setUpper</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数合法性</span></span><br><span class="line">    <span class="keyword">if</span> (v &lt; lower.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    upper.set(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置库存下限</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setLower</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数合法性</span></span><br><span class="line">    <span class="keyword">if</span> (v &gt; upper.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    lower.set(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略其他业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="制定并发访问策略"><a href="#制定并发访问策略" class="headerlink" title="制定并发访问策略"></a>制定并发访问策略</h1><ol><li>防止共享</li><li>采取不变模式。这样修改一个对象就是创建了一个新对象</li><li>利用管程和其他并发工具来</li></ol><h2 id="要注意几点"><a href="#要注意几点" class="headerlink" title="要注意几点"></a>要注意几点</h2><ol><li>采用成熟的工具类避免重复开发轮子</li><li>尽量避免使用低级原语入synchronized、lock等方式，而是采用并罚保</li><li>尽量以并发安全为主，尽量避免过早优化代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-排序(上)</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="如何选择一种排序算法"><a href="#如何选择一种排序算法" class="headerlink" title="如何选择一种排序算法"></a>如何选择一种排序算法</h1><h2 id="算法的执行效率"><a href="#算法的执行效率" class="headerlink" title="算法的执行效率"></a>算法的执行效率</h2><ul><li>最好、最坏、平均时间复杂度：需要根据要排序数据的大小、以及是否接近有序来考虑时间复杂度。</li><li>考虑时间复杂度的系数、常量、低阶：对于通一时间复杂度的数据要考虑这些。</li><li>比较次数和交换次数：基于比较的排序涉及到数据的交换所以要考虑比较次数和交换次数。</li></ul><h2 id="算法的内存消耗"><a href="#算法的内存消耗" class="headerlink" title="算法的内存消耗"></a>算法的内存消耗</h2><p>原地排序指空间复杂度是O(1)的排序，我们在选择的时候也要针对硬件考虑算法的空间复杂度</p><h2 id="算法的稳定性"><a href="#算法的稳定性" class="headerlink" title="算法的稳定性"></a>算法的稳定性</h2><p>指如果数据有俩个相等的元素，当排序后者俩个相等元素之间的顺序没发生改变，我们管他叫稳定的排序。相反则是不稳定的排序。</p><p>  算法稳定性的意义以及用法，对于一个对象按照俩个属性维度排序。如：对于一个账户的金额排序，金额相等的按照时间倒序。</p><ol><li>我们可以先按照时间倒叙排序，得到时间倒叙排序的列表；</li><li><p>用稳定性排序算法按照金额大小进行排序，由于是稳定性的排序算法所以金额相等的数据原有顺序不变依然是时间倒叙。</p><p>规律：先按照第二个属性排序（即xx相等，按照xx排序），在按照第一个属性排序。</p></li></ol><h2 id="算法的有序度和逆序度"><a href="#算法的有序度和逆序度" class="headerlink" title="算法的有序度和逆序度"></a>算法的有序度和逆序度</h2><p>一个数组中，有顺序的元素个数较为有序度。相反，则成为逆序度。一个完全有序的数据我们称他为满有序度。公式是：逆序度=满有序度-有序度。<br>排序实际上是减少逆序度最终达到满有序度的过程</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="comment">//第一层循环没循环一次冒泡一次，如果某一次没有发生位置变化说明数组已经完全有序，停止冒泡needBuuble</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> needBuuble=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length-i; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = array[j];</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; array[j]) &#123;</span><br><span class="line">                    array[j] = array[i];</span><br><span class="line">                    array[i] = tmp;</span><br><span class="line">                    needBuuble=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!needBuuble)&#123;</span><br><span class="line">                <span class="keyword">return</span> array;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>  时间复杂度：最好的情况是数组完全有序，只做一次循环就退出。最坏的时间复杂度是O(n*n),完全倒序需要都交换一次。</p><p>  空间复杂度：相邻俩个元素比较交换，没有用到额外的空间属于O(1)</p><p>  算法稳定性：俩个元素相同，不交换位置所以是算法稳定。</p><p>注：如果不优化，时间复杂度就是O(n*n).</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序，循环数组，每次都找到数组最小值，然后和当前元素互换位置，知道结束，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSorts</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序，循环数组，每次都找到数组最小值，然后和当前元素互换位置，知道结束，</span></span><br><span class="line"><span class="comment">     * 时间负责度最好O(n*n)，最坏O(n*n)，平均都是O(n*n)，且不稳定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录最小值和索引</span></span><br><span class="line">            <span class="keyword">int</span> min=a[i];</span><br><span class="line">            <span class="keyword">int</span> minIdx=i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环查找最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]&lt;min)&#123;</span><br><span class="line">                    min=a[j];</span><br><span class="line">                    minIdx=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前值不是最小值，最小值和当前值互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(i!=minIdx)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp=a[minIdx];</span><br><span class="line">                a[minIdx]=a[i];</span><br><span class="line">                a[i]=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序-算法分析"><a href="#选择排序-算法分析" class="headerlink" title="选择排序-算法分析"></a>选择排序-算法分析</h2><p>  时间复杂度：时间负责度最好O(n<em>n)，最坏O(n</em>n)，平均都是O(n*n)</p><p>  空间复杂度：没有用到额外的空间属于O(1)</p><p>  算法稳定性：不稳定每次都要交换位置，如果值相等也可能在交换后改变顺序</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//利用分治思想递归</span></span><br><span class="line">       <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">       sort(a, start, mid);</span><br><span class="line">       sort(a, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">       merge(a, start, mid, end);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//临时数组等于a里start--&gt;end</span></span><br><span class="line">       <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];<span class="comment">//注意：一定是end-start+1，因为这是Index,长度要+1（0--2长度是3）</span></span><br><span class="line">       <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//给tmp赋值，逻辑是i从start--&gt;mid，j从mid+1--&gt;end</span></span><br><span class="line">       <span class="keyword">int</span> i = start;</span><br><span class="line">       <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">           tmp[k++] = a[i] &lt; a[j] ? a[i++] : a[j++];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//剩余补进临时数组</span></span><br><span class="line">       <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">           tmp[k++] = a[i++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">           tmp[k++] = a[j++];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将临时数据写入到a中</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; tmp.length; x++) &#123;</span><br><span class="line">           a[start + x] = tmp[x];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序-算法分析"><a href="#归并排序-算法分析" class="headerlink" title="归并排序 算法分析"></a>归并排序 算法分析</h2><p>  时间复杂度：时间负责度最好O(nlogn)，最坏O(nnlogn)，平均都是O(nnlogn)</p><p>  空间复杂度：每次merge都需要开辟一块空间但是每次都释放掉，空间复杂度就是O(n)</p><p>  算法稳定性：稳定</p><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取数组的一个标志位（交换区点一般是数组最后一位，小于这个点的在左边，大于的在右边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= e) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> poivt = poivt(a, s, e);</span><br><span class="line">    sort(a, s, poivt - <span class="number">1</span>);<span class="comment">//排序取到分区点后，分区点-1，参与排序</span></span><br><span class="line">    sort(a, poivt, e);<span class="comment">//从分区点到终点排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">poivt</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> swapIdx = s;<span class="comment">//交换区为s，随着数组循环移动</span></span><br><span class="line">    <span class="keyword">int</span> flag = a[e];<span class="comment">//设置flag即最后交换区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s--&gt;e-1,循环到交换区前</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= e - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//即时小于也要交换，让swpIdx后移</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = a[i];</span><br><span class="line">            a[i] = a[swapIdx];</span><br><span class="line">            a[swapIdx] = tmp;</span><br><span class="line">            swapIdx++;<span class="comment">//扩大前半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后将flag移动到此次poivt点并且返回交换区点</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[swapIdx];</span><br><span class="line">    a[swapIdx] = flag;</span><br><span class="line">    a[e] = tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> swapIdx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排复杂度分析"><a href="#快排复杂度分析" class="headerlink" title="快排复杂度分析"></a>快排复杂度分析</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-队列(未完)</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p> 队列的作用和实际使用场景</p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>特点：</p><ul><li>没有数组队列在扩容时候O(n)的数据迁移工作</li><li>当(tail+1)%n=head时候队列满,当head==tail的时候队列空</li><li>因为是环状，所以被enqueue一个元素，tail=(tail+1)%n,每dequeue一个元素，head=(head+1)%n</li><li>缺点：tail不能存数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleQueuqe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueuqe</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        array = <span class="keyword">new</span> String[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enque</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//尾指针下一个指向head队列满</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % size == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"CircleQueuqe has full"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array[tail] = s;</span><br><span class="line">        <span class="comment">//环状的下一个位置是 tail+1取模</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deques</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"CircleQueuqe has empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String ret=array[head];</span><br><span class="line">        head=(head+<span class="number">1</span>)%size;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CircleQueuqe&#123;"</span> +</span><br><span class="line">                <span class="string">"array="</span> + Arrays.toString(array) +</span><br><span class="line">                <span class="string">", head="</span> + head +</span><br><span class="line">                <span class="string">", tail="</span> + tail +</span><br><span class="line">                <span class="string">", size="</span> + size +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-递归</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="什么样的问题可以用递归解决"><a href="#什么样的问题可以用递归解决" class="headerlink" title="什么样的问题可以用递归解决"></a>什么样的问题可以用递归解决</h1><ol><li>可以将一个问题分解成若干子问题</li><li>主要问题和子问题之间的处理过程是一样的。</li><li>存在递归终止条件</li></ol><h1 id="如何写一个递归程序"><a href="#如何写一个递归程序" class="headerlink" title="如何写一个递归程序"></a>如何写一个递归程序</h1><ol><li>分解问题，推导出递推公式</li><li>找到程序的出口，即递归结果</li></ol><h1 id="递归程序的注意事项"><a href="#递归程序的注意事项" class="headerlink" title="递归程序的注意事项"></a>递归程序的注意事项</h1><ol><li>防止堆栈溢出–增加深度的参数</li><li>防止重复计算–增加散列表等方式记录计算结果如果有计算结果直接返回</li></ol><p>例子：斐波那契数列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;Integer, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递推公式f(n)=f(n-1)+f(n-2)，结果：n==1 return 1 n==2 return 1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归结果</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录结果避免重复计算,如果没有这个会特别的满</span></span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算</span></span><br><span class="line">    <span class="keyword">long</span> ret = cal(n - <span class="number">1</span>) + cal(n - <span class="number">2</span>);</span><br><span class="line">    map.put(n, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法-链表</title>
      <link href="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/"/>
      <url>%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表特点，内存不连续，包含后置或者前置节点的指针，修改的时间复杂度O(1),查找的时间复杂度O(n)；</p><h1 id="链表的注意"><a href="#链表的注意" class="headerlink" title="链表的注意"></a>链表的注意</h1><ul><li>建议增加哨兵节点减少难度（head tail，这样在修改链表时候不用判断头结点和最后一个节点）</li><li>防止指针丢失和溢出</li><li>注意边界处理（Null,只有一个节点，只有俩个节点）</li></ul><h1 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: liuhaoeric</span></span><br><span class="line"><span class="comment"> * Create time: 2019/03/23</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer val;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">    <span class="keyword">public</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getVal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getPrev</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"node="</span> + val +</span><br><span class="line">                <span class="string">", next="</span> + next +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找中间节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findMid</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span> || node.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node slow = node;</span><br><span class="line">        Node fast = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可用快慢指针找是否有环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkNodeLoop</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Node cur = node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur.val)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有序俩表合并</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">merge</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">        Node ret = head;</span><br><span class="line"></span><br><span class="line">        Node cura = a;</span><br><span class="line">        Node curb = b;</span><br><span class="line">        <span class="keyword">while</span> (cura != <span class="keyword">null</span> &amp;&amp; curb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cura.val &lt; curb.val) &#123;</span><br><span class="line">                ret.next = cura;</span><br><span class="line">                cura = cura.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ret.next = curb;</span><br><span class="line">                curb = curb.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = ret.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cura != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret.next = cura;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ret.next = curb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除倒数第几个节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">removeNodeByDescPosition</span><span class="params">(Node a, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Node head = <span class="keyword">new</span> Node(<span class="keyword">null</span>);</span><br><span class="line">        head.next = a;</span><br><span class="line">        Node tmp = head;</span><br><span class="line">        <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">            tmp = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超过限制</span></span><br><span class="line">        <span class="keyword">if</span> (position &gt;= list.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到要删的节点的前置节点</span></span><br><span class="line">        Node n;</span><br><span class="line">        <span class="keyword">int</span> nodeidx = list.size() - position;</span><br><span class="line">        n = list.get(nodeidx - <span class="number">1</span>);</span><br><span class="line">        n.next = n.next.next;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Node a = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node b = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node c = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node d = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node e = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        Node f = <span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        Node g = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        a.next = b;</span><br><span class="line">        b.next = c;</span><br><span class="line">        c.next = d;</span><br><span class="line">        d.next = e;</span><br><span class="line">        e.next = f;</span><br><span class="line">        f.next = g;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Node.findMid(a));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(Node.checkNodeLoop(a));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Node a1 = new Node(0);</span></span><br><span class="line"><span class="comment">//        Node b1 = new Node(2);</span></span><br><span class="line"><span class="comment">//        Node c1 = new Node(4);</span></span><br><span class="line"><span class="comment">//        Node d1 = new Node(6);</span></span><br><span class="line"><span class="comment">//        Node e1 = new Node(8);</span></span><br><span class="line"><span class="comment">//        Node f1 = new Node(10);</span></span><br><span class="line"><span class="comment">//        Node g1 = new Node(11);</span></span><br><span class="line"><span class="comment">//        a1.next = b1;</span></span><br><span class="line"><span class="comment">//        b1.next = c1;</span></span><br><span class="line"><span class="comment">//        c1.next = d1;</span></span><br><span class="line"><span class="comment">//        d1.next = e1;</span></span><br><span class="line"><span class="comment">//        e1.next = f1;</span></span><br><span class="line"><span class="comment">//        f1.next = g1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(Node.merge(a, a1));</span></span><br><span class="line"></span><br><span class="line">        System.out.println(Node.removeNodeByDescPosition(<span class="keyword">new</span> Node(<span class="number">10</span>), <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA线程-为什么局部变量是线程安全的</title>
      <link href="JAVA%E7%BA%BF%E7%A8%8B-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88/"/>
      <url>JAVA%E7%BA%BF%E7%A8%8B-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="方法是如何被执行"><a href="#方法是如何被执行" class="headerlink" title="方法是如何被执行"></a>方法是如何被执行</h1><p>例如下面的程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">7</span>；</span><br><span class="line"><span class="keyword">int</span>[] b = fibonacci(a);</span><br><span class="line"><span class="keyword">int</span>[] c = b;</span><br></pre></td></tr></table></figure><p>当jvm调用fibonacci(a)时，通过cpu的寄存器找到方法的地址。cpu支持一种栈结构，他和方法息息相关，所以一般叫做调用栈。<br>栈这种数据结构的特点是后进先出，所以当一个遇到方法嵌套时候比如a–&gt;b–&gt;c，那么入栈的时候就是c–&gt;b–&gt;a，执行顺序也是c–&gt;b–&gt;a。</p><h1 id="方法中的局部变量"><a href="#方法中的局部变量" class="headerlink" title="方法中的局部变量"></a>方法中的局部变量</h1><p>  方法实际上是以栈帧为单位入栈的，一个方法从入口到返回都在一个栈帧中，栈帧和方法的生命周期是一样的，当方法结束，栈帧也就失效了，而方法中的局部变量都是保存在栈帧中的，他的生命周期也是在方法内部。且为了线程之间不相互干扰，每个线程都有一个独立的栈帧。综上，栈帧是线程安全的。</p><p>  这种方式有个名词叫线程封闭，即仅在单线程内访问数据，不共享就没有线程安全的问题。例如：我们常用的数据库连接池，connection的方法并没有声明线程安全，我们在使用中都是在一个方法内获取conenection，查询数据，关闭connecton，这这种线程封闭方式来解决线程安全的问题。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA线程-开启多少线程合适</title>
      <link href="JAVA%E7%BA%BF%E7%A8%8B-%E5%BC%80%E5%90%AF%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82/"/>
      <url>JAVA%E7%BA%BF%E7%A8%8B-%E5%BC%80%E5%90%AF%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B%E5%90%88%E9%80%82/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程"></a>为什么要使用多线程</h1><p>  我们评价一个操作系统性能好的系统往往是俩点低延迟、高吞吐。做到这俩点，往往需要一优化算法，二有效利用硬件。对于一不在此讨论的范畴，而硬件利用率大致往往分俩类，即cpu的利用率，和i/o的利用。<br>  单线程时代：我们的程序往往是cpu和io设备相互配合执行，所以一个单线程的程序执行cpu操作时候io就要停下来等待cpu完成，为了提高io和cpu的利用率，操作系统为我们提供了多线程技术。<br>  线程1处理cpu的计算，线程2处理io请求。处理玩io请求后在切换回来，这样利用率就得到了提高</p><h1 id="线程多了就一定快么"><a href="#线程多了就一定快么" class="headerlink" title="线程多了就一定快么"></a>线程多了就一定快么</h1><p>  针对我们程序的特点分为，io密集型和计算密集型俩种。如果io操作执行的比例比较大就是io密集型，如果cpu计算的比例比较大就是计算密集型。<br>  在单核时代，对于计算密集型的业务增加线程反而会拖慢程序执行效率，因为只有一个核，所以同时只能有一个线程在运行，增加线程反而加大了线程切换的损耗。<br>  在多核时代，对于计算密集型的业务是可以通过增加线程提高性能的，但是设置应该是cpu的核数+1，充分利用起cpu。<br>  对于io密集型的业务，由于一般io的耗时比cpu要多的多，那么线程往往是cpu的核数*io耗时/cpu耗时+1。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA线程的生命周期</title>
      <link href="JAVA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>JAVA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统的线程生命周期"><a href="#操作系统的线程生命周期" class="headerlink" title="操作系统的线程生命周期"></a>操作系统的线程生命周期</h1><p>初始状态，可运行状态，运行状态，终止状态，休眠状态，他们之间的转化关系如图：</p><p><img src="./thread1.png" alt="avator"></p><ul><li>初始状态:线程被创建，但是还未分配cpu执行的状态。</li><li>可运行状态:指线程可以分配cpu执行。</li><li>运行状态:有cpu空闲时候分配cpu执行，当线程被分配给cpu执行时候，变为可执行状态。</li><li>终止状态:线程执行完成或者异常终止。</li><li>休眠状态:线程调用阻塞的api或者等待某个事件执行的时候会变为休眠状态。</li></ul><p>jvm将由于将线程的调度交给操作系统，所以将可运行状态和运行状态和在了一起，因为jvm不关心这俩个状态的具体情况。</p><h1 id="java线程的生命周期"><a href="#java线程的生命周期" class="headerlink" title="java线程的生命周期"></a>java线程的生命周期</h1><p>NEW（初始装填）、RUNABLE（可运行/运行状态）、TERMINATED（终止状态）、BLOCK（阻塞）、WAIT（等待）、TIME_WAIT（有时限等待）</p><p>其中BLOCK、WAIT、TIME_WAIT都属于休眠关系</p><p><img src="./thread2.png" alt="avator"></p><ul><li>NEW:当线程对象被创建出来的时候线程处于该状态，这时候还未对其分配cpu。具体方法是集成Thread类并且实现run方法，或者狗仔一个Thread对象把一个Runnable的接口实现传进去。</li><li>NEW–&gt;RUNABLE:调用thread.start()方法线程变为RUNABLE状态。</li><li>RUNABLE–&gt;休眠状态：java的休眠状态有三种BLOCK、WAIT、TIME_WAIT，分别是<ul><li>RUNABLE–&gt;BLOCK：当遇到synchronized代码块时候，如果竞争失败当前线程进入block状态。等待进入到线程又会变为RUNABLE状态，注意在java中如调用到了阻塞的api，是不会切换到block状态的，比如调用io的api，当前线程依然是RUNABLE状态这点要注意。</li><li>RUNABLE–&gt;WAIT：如下3中情况会让当前线程进入到wait状态<ul><li>object.wait(),没有时间限制的wait，需要调用object.notify()或者object.notifyAll()</li><li>调用了其他线程的join()，没有时间限制的join，需要等待当前join的线程终止。</li><li>调用了LockSupport.park(),没有事件限制的park，对应的方法是LockSupport.unPark()</li></ul></li><li>RUNABLE–&gt;TIME_WAIT：同上就是上面3种情况或者方法的有时间版本</li></ul></li><li>RUNABLE–&gt;TERMINATED：<ul><li>线程执行结束</li><li>stop()或者interrupt()方法</li></ul></li></ul><h1 id="线程终止的方法"><a href="#线程终止的方法" class="headerlink" title="线程终止的方法"></a>线程终止的方法</h1><p>当一个线程执行一个很耗时的逻辑时候，可能会终止该线程的操作，比如并发情况下的网络超时，为了防止资源耗尽往往要终止。上面提到了stop或者interrupt方法</p><ul><li>stop方法已经不建议使用了，因为会立即杀死线程，同时不会释放synchronized的锁，所以后面的线程都会阻塞。</li><li><p>interrupt方法相对来说就会“温柔”很多，它只是对线程了interrupt标记，当调用thread.interrupt()方法有俩种方式退出线程</p><ul><li>主动退出：对于一个一直执行的线程来说可以通过判断t1.isInterrupted()来判断是否该终端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span>(!t1.isInterrupted())&#123;</span><br><span class="line">              <span class="comment">//do something</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><ul><li>异常退出：对于执行了wait sleep这种线程我们可以通过异常捕获来判断线程的终端，因为他们会抛出InterruptedException异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 lock.wait();</span><br><span class="line">             &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//do something</span></span><br><span class="line"></span><br><span class="line">             <span class="comment">//这时候会输出false因为interrupt会被清除</span></span><br><span class="line">             System.out.println(t1.isInterrupted());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></li></ul><p>注意：当抛出InterruptedException异常后线程的interrupt标记会被清楚如果这时候在判断isInterrupted()方法就又变成了false</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的管程</title>
      <link href="JAVA%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B/"/>
      <url>JAVA%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h1><p>java在1.5之前只提供了synchronized,wait,notfiy,notfiyAll3种实现并发的源语，他们实际上是管程的组成部分。</p><p>对应的英文是Monitor，他表示管理共享变量以及操作共享变量，使其支持并发的过程。</p><h1 id="java的实现–MESA模式"><a href="#java的实现–MESA模式" class="headerlink" title="java的实现–MESA模式"></a>java的实现–MESA模式</h1><p>在管程的发展史上出现过3中管程模型，Hasen、Hoare、MESA。java采用的是MESA模型</p><p>在并发变成领域，有俩大核心问题：互斥–一个共享资源同一时刻只能被一个线程访问；同步–即线程之间的通信、协作；</p><h2 id="java的管程如何解决互斥问题"><a href="#java的管程如何解决互斥问题" class="headerlink" title="java的管程如何解决互斥问题"></a>java的管程如何解决互斥问题</h2><p>如果：</p><p><img src="./管程1.png" alt="avator"></p><p>管程将资源以及方法都封装起来，只允许一个线程通过管程哦方法调用该方法。</p><h2 id="java的管程如何解决同步问题"><a href="#java的管程如何解决同步问题" class="headerlink" title="java的管程如何解决同步问题"></a>java的管程如何解决同步问题</h2><p>利用之前提到的消息-通知机制来让线程之间协作见下面的一个BlockQueue的代码，请忽略业务代码:P</p><ol><li>enq的时候while判断队列是否满了，如果满了，notFull.await()阻塞当前线程;</li><li>enq如果没满，添加对象，并且用notEmpty.single()通知deque停止阻塞；</li><li>deq可以顺利执行出队列的操作；</li><li>deq的时候while判断队列是否为空，如果为空，notEmpty.await()阻塞当前线程;</li><li>deq如果不为空，poll对象，并且用notFull.single()通知enq停止阻塞；</li><li>enq可以顺利执行队列</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span> </span>&#123;</span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition notFull = lock.newCondition();</span><br><span class="line">    Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> queSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BlockQueue</span><span class="params">(<span class="keyword">int</span> queSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queSize = queSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enq</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果为慢noFull阻塞线程</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == queSize) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.add(o);</span><br><span class="line">            <span class="comment">//添加成功通知deq停止阻塞</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        Object ret = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//如果为空notEmpty阻塞线程</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.poll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//出队列成功通知队列未满可以入队列</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="notify使用场景"><a href="#notify使用场景" class="headerlink" title="notify使用场景"></a>notify使用场景</h1><p>上面用了notify类似的逻辑，之前提到过能用notifyAll尽量用notifyAll。那么什么时候用notify呢。需要同时满足下面3个条件</p><ol><li>所有线程的等待条件一样</li><li>所有线程满足等待条件后的操作一样</li><li>只需要唤醒一个线程</li></ol><p>结合上面的场景，都是队列queue;notify之后的操作都是queue入队或者出队；只需要唤醒一个线程入/出队</p><h1 id="管程3中模型的区别"><a href="#管程3中模型的区别" class="headerlink" title="管程3中模型的区别"></a>管程3中模型的区别</h1><ol><li>Hasen:T1在wait之后，T2notify,notify必须在T2最后一条语句,执行完后T2终止,以此保证系统只有一个线程在运行。</li><li>Hoare:T1在wait之后，T2notify,notify后T2堵塞,T1开始运行,T1运行完后唤醒T2,新能略差，因为多了一次T2的唤醒。</li><li>MESA:T1在wait之后，T2notify,T1值是获取了可执行的可能，需要竞争获取锁才能执行，JAVA采用此种模型</li></ol><p>所以在MESA中wait的标准写法如下，因为被noyify通知之后线程只是可能执行，有可能在执行时候线程又会不满足条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( 条件)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(objcet)&#123;</span><br><span class="line">        object.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发编程主要面临的几个问题:安全性,活跃性,性能</title>
      <link href="java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%BB%E8%A6%81%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98-%E5%AE%89%E5%85%A8%E6%80%A7-%E6%B4%BB%E8%B7%83%E6%80%A7-%E6%80%A7%E8%83%BD/"/>
      <url>java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%BB%E8%A6%81%E9%9D%A2%E4%B8%B4%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98-%E5%AE%89%E5%85%A8%E6%80%A7-%E6%B4%BB%E8%B7%83%E6%80%A7-%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java并发编程的问题主要集中在安全性、活跃性、性能3个问题</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>主要防止竞态问题（race condition），如下代码,add10k中的set(get()+1)  是不安全的，因为他要依赖get方法的结果在set。虽然set和get加了锁但是+1这步操作不是原子性的操作。(有可能get俩个一样的值+1，在set回去，影响了预期结果)，这种后面的操作依赖前面操作的结果的操作被称为竞态操作。</p><p>解决方法</p><ol><li>加锁synchronized(lock){}解决</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count；</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> v)</span></span>&#123;</span><br><span class="line">    count = v;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add10K</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(idx++ &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">      set(get()+<span class="number">1</span>)      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><p>要注意活锁和饿死的关系。</p><ul><li>饿死只一个线程被阻塞住或者锁住，但是一直没有得到资源，导致程序一直无法执行下去</li><li>活锁：活锁是指线程一直尝试获取资源但是因为条件没法满足所以一直没法获取资源。和死锁相比，死锁是线程阻塞程序无法运行，活锁的线程的状态一直没有被锁住，一直在尝试获取资源，很快会耗光cpu的资源。</li></ul><p>解决方法：</p><ul><li>饿死可以采用公平锁，用fifo队列来解决锁争抢</li><li>活锁：可以采用不同线程阻塞一个随机时间。减少竞争。</li></ul><h2 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h2><p>因为并发变成要对数据加锁，可能会影响系统的并发度，某些操作会变为串行，可以考虑用jdk里的并发包里提供的工具类解决，里面有许多无锁的工具。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中用等待、通知机制优化循环等待</title>
      <link href="JAVA%E4%B8%AD%E7%94%A8%E7%AD%89%E5%BE%85%E3%80%81%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/"/>
      <url>JAVA%E4%B8%AD%E7%94%A8%E7%AD%89%E5%BE%85%E3%80%81%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E4%BC%98%E5%8C%96%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要采用循环等待机制"><a href="#为什么要采用循环等待机制" class="headerlink" title="为什么要采用循环等待机制"></a>为什么要采用循环等待机制</h1><p>之前的文章在解决死锁中的打破：占有且等待中的代码中，采用了死循环的方式来处理竞争失败的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回true</span></span><br><span class="line"> <span class="keyword">while</span> (!Allocator.getInstance().apply(<span class="keyword">this</span>, target)) &#123;&#125;</span><br></pre></td></tr></table></figure><p>当线程之间竞争不激烈，或者apply方法耗时较短时候这个方案还好，反之，可能有时需要循环几万次才能获取锁这种情况就会大量的浪费cpu计算资源。</p><h1 id="java中的等待通知机制的使用"><a href="#java中的等待通知机制的使用" class="headerlink" title="java中的等待通知机制的使用"></a>java中的等待通知机制的使用</h1><p>java中为我们提供了wait(),notify(),notifyAll()。方法配置synchronized完成通知等待。我们在不满足条件时候可以用lock.wait()来释放资源，进入等待状态，当满足提交过后，在调用notify()重新获取资源。</p><h2 id="wait-的说明"><a href="#wait-的说明" class="headerlink" title="wait()的说明"></a>wait()的说明</h2><p>wait是Object对象的方法，实际上是和“锁”对象对应使用的，</p><ol><li>wait必须在synchronized代码块中，否则会报异常：IllegalMonitorStateException</li><li>wait()方法必须和synchronized对应起来，即synchronized(c){},那么一定是c.wait()</li></ol><h2 id="notify-和notifyAll-方法的使用注意事项"><a href="#notify-和notifyAll-方法的使用注意事项" class="headerlink" title="notify()和notifyAll()方法的使用注意事项"></a>notify()和notifyAll()方法的使用注意事项</h2><ul><li>当我们notfiy()之后，线程重新获取被保护资源。一定要在次判断锁条件，因为notify之后到资源重新被获取，这段时间有可能再次不满足条件。</li><li>没有特殊情况尽量用notifyAll()方法。因为notify只会“唤醒”一个线程，有可能这个线程不是需要唤醒的线程导致执行效率低下。而notfiyAll会唤醒所有在等待的线程，并且同时竞争资源，保证会唤醒需要的唤醒的线程。</li></ul><p>之前的代码改造如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Allocator instance = <span class="keyword">new</span> Allocator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Allocator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Account&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Account from, Account to)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (set.contains(from) || set.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set.add(from);</span><br><span class="line">        set.add(to);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Account from, Account to)</span> </span>&#123;</span><br><span class="line">        set.remove(from);</span><br><span class="line">        set.remove(to);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Allocator.getInstance().apply(<span class="keyword">this</span>, target);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">                        balance -= amt;</span><br><span class="line">                        target.setBalance(target.getBalance() + amt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Allocator.getInstance().free(<span class="keyword">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="wait-和sleep-的区别"><a href="#wait-和sleep-的区别" class="headerlink" title="wait()和sleep()的区别"></a>wait()和sleep()的区别</h2><p>wait</p><ol><li>wait是Object中的方法，和锁对应;wait要在Synchronized代码块中执行</li><li>wait会释放被锁资源。</li></ol><p>sleep</p><ol><li>sleep是Thread中的静态方法，让当前线程休眠一段时间</li><li>sleep是让出当前线程的执行权限，让优先级低的线程执行，但是不会释放锁资源，也就是说其他线程遇到synchronized代码快会阻塞住</li></ol><h2 id="wait的原理"><a href="#wait的原理" class="headerlink" title="wait的原理"></a>wait的原理</h2><p>  wait方法被调用后，当前线程会去掉锁标记，并且会将当前线程对象放入到对象资源池，知道notify或者notifyAll被调用。<br>  当notify或者notfiyAll被调用时候，会将对象资源池中的一个线程对象或者所有线程移入到锁标记资源池，在锁标记资源池的线程对象会争抢锁，获取资源，获取到资源的开始执行</p><h2 id="wait有哪些被唤醒的方法"><a href="#wait有哪些被唤醒的方法" class="headerlink" title="wait有哪些被唤醒的方法"></a>wait有哪些被唤醒的方法</h2><p>lock.notify、lock.notifyAll</p><p>wait(1000L)，时间到后</p><p>thread.interrupt 别的线程调用线程的interrupt方法</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA中的排他锁--synchroized</title>
      <link href="JAVA%E4%B8%AD%E7%9A%84%E6%8E%92%E4%BB%96%E9%94%81--synchroized/"/>
      <url>JAVA%E4%B8%AD%E7%9A%84%E6%8E%92%E4%BB%96%E9%94%81--synchroized/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的作用，解决原子性问题"><a href="#锁的作用，解决原子性问题" class="headerlink" title="锁的作用，解决原子性问题"></a>锁的作用，解决原子性问题</h1><p>例如：32位处理器在并发修改一个long类型的数据为什么是不安全的，原因是long类型是64位的数据在32位处理器中分为高32位和低32位，当2个线程同时修改一个long类型的高32位和低32位时候可能就会引起数据不一致的情况。解决方案是，给这个数据加锁，同时只允许一个线程对他进行修改。java中就是利用synchroized关键字。锁模型如下</p><p><img src="/synchroized1.png" alt="avator"></p><h2 id="synchroized关键字的几种用法"><a href="#synchroized关键字的几种用法" class="headerlink" title="synchroized关键字的几种用法"></a>synchroized关键字的几种用法</h2><p>synchroized有3种使用方法分别是锁static方法，锁实例方法，锁方法块，如下：</p><p>分别表示：</p><ol><li>修饰静态方法锁类的class对象，当这个静态方法被调用时候，该类所有的加锁的静态方法都会被锁住。</li><li>修饰实例方法，锁当前方法实例化的对象，其他线程对该对象的所有synchronized方法都会被锁住，以及该对象涉及锁住的代码块</li><li>代码块锁对象，该对象修饰的其他的代码块、以及该对象的synchronized都会被锁住。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 修饰非静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰静态方法</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修饰代码块</span></span><br><span class="line">  Object obj = <span class="keyword">new</span> Object()；</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">      <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="锁和被锁资源的关系"><a href="#锁和被锁资源的关系" class="headerlink" title="锁和被锁资源的关系"></a>锁和被锁资源的关系</h2><p>被锁资源和锁的关系应该是N：1关系，即一个资源只能对应一个锁。如下就是错误的且实际编程会经常发生</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//锁是SafeCalc的实例</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//锁是SafeCalc.class</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//addOne和get方法对应的不是同一把锁，所以在实际中锁是无效的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意HB原则要切实锁住对象"><a href="#注意HB原则要切实锁住对象" class="headerlink" title="注意HB原则要切实锁住对象"></a>注意HB原则要切实锁住对象</h2><p>下图的方法是错误的，因为hb原则没有规定get和addOne不适用于任何一条hb原则，所以当并发开始后，有可能get会出现数据不一致情况。解决方法：</p><ol><li>get加synchronized关键字:当并发发生后，解锁hb于加锁，所以后面的方法对前面方法一定可见</li><li>将value设置为volatile：并发发生volitile写hb于读，所以addOne之后get一定可见</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalc</span> </span>&#123;</span><br><span class="line">  volitile <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    value += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何一把锁保护多个资源"><a href="#如何一把锁保护多个资源" class="headerlink" title="如何一把锁保护多个资源"></a>如何一把锁保护多个资源</h1><p>因为被锁的资源和锁之间关系是N:1的关系，那么如何用一把锁保护多个资源呢</p><h2 id="如何保护没有关联关系的锁"><a href="#如何保护没有关联关系的锁" class="headerlink" title="如何保护没有关联关系的锁"></a>如何保护没有关联关系的锁</h2><p>如下，对于账户里面的余额和密码，我们采用了俩把锁balLock和pwLock分别保护俩个资源，同时也可用一把锁同时保护俩个资源，即给所有的方法加synchroinzed关键字，但是这样锁的粒度较大性能不如前一种好，因为一个修改余额的操作可能会影响到密码相关的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 锁：保护账户余额</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object balLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户余额  </span></span><br><span class="line">  <span class="keyword">private</span> Integer balance;</span><br><span class="line">  <span class="comment">// 锁：保护账户密码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object pwLock</span><br><span class="line">    = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="comment">// 账户密码</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取款</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt)&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看余额</span></span><br><span class="line">  <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(balLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改密码</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">updatePassword</span><span class="params">(String pw)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">this</span>.password = pw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查看密码</span></span><br><span class="line">  <span class="function">String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(pwLock) &#123;</span><br><span class="line">      <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何保护有关联关系的资源"><a href="#如何保护有关联关系的资源" class="headerlink" title="如何保护有关联关系的资源"></a>如何保护有关联关系的资源</h2><p>  例如上面提到的Account对象要提供转账方法，很直观的想法是给transfer方法加锁。如下所示，但是这个方法只是看似正确。因为synchronized方法修饰的调用方法的实例即this对象，并不能锁住target对象。<br>  因为在高并发情况下。如果target也向对方转账，是无法保证taget数据的一致性的。如：a–&gt;b 100元,同时另一个线程b–&gt;c100元.如图：</p><p><img src="./synchronized2.png" alt="avator"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">      <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">      target.balance += amt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案是transfer中的代码块用同一把锁锁住，最好的方法是用Account.class，因为jvm虚拟机所有线程只会加载一个Account对象</p><h2 id="注意不能将不可变对象置为锁"><a href="#注意不能将不可变对象置为锁" class="headerlink" title="注意不能将不可变对象置为锁"></a>注意不能将不可变对象置为锁</h2><p>因为不可变对象的值一旦发生改变，锁就会失效</p><h1 id="锁的优化以及如何规避死锁问题"><a href="#锁的优化以及如何规避死锁问题" class="headerlink" title="锁的优化以及如何规避死锁问题"></a>锁的优化以及如何规避死锁问题</h1><p>如上所述，对于转账这个场景给Account.class加锁，虽然并发问题是解决了，但是系统中所有的转账都会变成串行的操作，在现实系统中该方法完全不可用。我们可以采用细粒度的方法对程序进行优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line">  <span class="comment">// 转账</span></span><br><span class="line">  <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Account target, <span class="keyword">int</span> amt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(target)&#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.balance -= amt;</span><br><span class="line">                  target.balance += amt;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个方法是同时锁住转入账户和转出账户，并发问题解决了但是引入了另一个问题，即并发编程最臭名昭著的“死锁”，为什么会发生死锁呢。设想如下场景：<br>  线程T1里a要向b转账，同时线程T2里b也要向a转账，这时候T1拿到了a的锁synchronized(this),同时T2拿到了b的锁synchronized(this)，下一步T1和T2因为synchronized(target)同时等待对方释放锁。这时候就进入死了死锁。那么死锁的条件是什么呢？</p><ol><li>互斥：即代码中的target和this俩个线程互斥。</li><li>占有且等待：即T1synchronized(this)占有资源且等待target。</li><li>不释放：T1不会主动释放锁的资源。</li><li><p>循环等待：上文中说的互相等待。</p><p>那么如何避免死锁呢打破上述的任何一个条件即可。互斥我们是无法打破的我们看下剩下3个条件如何打破。</p></li></ol><h2 id="打破：占有且等待"><a href="#打破：占有且等待" class="headerlink" title="打破：占有且等待"></a>打破：占有且等待</h2><p>我们针对“等待”俩个字，让锁一下获得所有的资源。具体方式，我们可以创建一个Allocator方法提供apply申请资源和free释放资源的方法。注意Allocator一定是单例，在锁保证全局唯一，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Allocator instance = <span class="keyword">new</span> Allocator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Allocator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Account&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Account from, Account to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(from) || set.contains(to)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(from);</span><br><span class="line">        set.add(to);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(Account from, Account to)</span> </span>&#123;</span><br><span class="line">        set.remove(from);</span><br><span class="line">        set.remove(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Allocator.getInstance().apply(<span class="keyword">this</span>, target)) &#123;&#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (target) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">                        balance -= amt;</span><br><span class="line">                        target.setBalance(target.getBalance() + amt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Allocator.getInstance().free(<span class="keyword">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打破：不释放"><a href="#打破：不释放" class="headerlink" title="打破：不释放"></a>打破：不释放</h2><p>即主动释放资源，但是java的synchronized关键字因为在出现竞争时候线程会进入阻塞状态，本身是没有这个功能可以用Lock替代</p><h2 id="打破：循环等待"><a href="#打破：循环等待" class="headerlink" title="打破：循环等待"></a>打破：循环等待</h2><p>这个其实很简单，我们给每个账号上分配一个id,对这个id排序，加锁按照id的顺序加锁，保证每个线程的加锁顺序一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account target, <span class="keyword">int</span> amt)</span> </span>&#123;</span><br><span class="line">        Account first = <span class="keyword">this</span>;</span><br><span class="line">        Account second = target;</span><br><span class="line">        <span class="comment">//按照id排序</span></span><br><span class="line">        <span class="keyword">if</span> (first.id &lt; second.id) &#123;</span><br><span class="line">            first = target;</span><br><span class="line">            second = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (first) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (balance &gt;= amt) &#123;</span><br><span class="line">                    balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicReferenceFieldUpdater</title>
      <link href="AtomicReferenceFieldUpdater/"/>
      <url>AtomicReferenceFieldUpdater/</url>
      
        <content type="html"><![CDATA[<h1 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h1><p>JAVA原子更新器，用于原子性的更新对象的字段</p><p>用newUpdater来初始化AtomicReferenceFieldUpdater对象。<br>1.有3个参数第一个参数包含该字段类<br>2.有修改字段的类<br>3.字段名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AtomicReferenceFieldUpdater updater=AtomicReferenceFieldUpdater.newUpdater(Object.class,String.class,<span class="string">"fieldName"</span>);</span><br></pre></td></tr></table></figure><p>修改方法，失败会返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> res=updater.compareAndSet(obj,<span class="string">"srcValue"</span>,<span class="string">"destValue"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unsafe-java7之后的CAS</title>
      <link href="Unsafe-java7%E4%B9%8B%E5%90%8E%E7%9A%84CAS/"/>
      <url>Unsafe-java7%E4%B9%8B%E5%90%8E%E7%9A%84CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><p>java7之后在并发中大量使用Unsafe来保证并发状态，字段修改的唯一性</p><h2 id="代码例子"><a href="#代码例子" class="headerlink" title="代码例子"></a>代码例子</h2><p>例如在AbstractQueuedSynchronizer中的CAS中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建unsafe对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字段的偏移量</span></span><br><span class="line">stateOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//CAS修改方法，第二个至是计算出的偏移量，第3个值是原有值，第4个参数是修改之后的值，success-true,faild-false</span></span><br><span class="line">unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br></pre></td></tr></table></figure><h2 id="阻塞线程park和unpark"><a href="#阻塞线程park和unpark" class="headerlink" title="阻塞线程park和unpark"></a>阻塞线程park和unpark</h2><p>park和unpark与object.wait() object.notify一样都是可以阻塞和唤醒线程但是俩这有如下区别：</p><ol><li>面向的主体不同，LockSupport的park, unpark面向的是线程，而Object.wait, nofify面向的是对象</li><li>底层实现机制不同，可以看到Object的wait, notify方法也是native方法，Unsafe的park和unpark方法也是native方法，底层实现不同，Object.notify不能唤醒Unsafe park的线程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA Nio的学习</title>
      <link href="JAVA-Nio/"/>
      <url>JAVA-Nio/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-Nio的学习"><a href="#JAVA-Nio的学习" class="headerlink" title="JAVA Nio的学习"></a>JAVA Nio的学习</h1><h2 id="Selector-的3种选择方式"><a href="#Selector-的3种选择方式" class="headerlink" title="Selector 的3种选择方式"></a>Selector 的3种选择方式</h2><p>Selector.select()</p><p>Selector.select(timeout)</p><p>Selector.selectNow()</p><h2 id="selector-wakeup"><a href="#selector-wakeup" class="headerlink" title="selector.wakeup()"></a>selector.wakeup()</h2><p>当采用Selector.select()或者select(timeout)时候，会阻塞线程，wakeup()会唤醒被select阻塞的线程。使用时候可以参考netty中的cas方式提高性能。</p><h2 id="interestOps"><a href="#interestOps" class="headerlink" title="interestOps"></a>interestOps</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> io </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 技术 </tag>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA并发基础-内存模型</title>
      <link href="JAVA%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>JAVA%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="引起并发bug的3个主因"><a href="#引起并发bug的3个主因" class="headerlink" title="引起并发bug的3个主因"></a>引起并发bug的3个主因</h1><h2 id="缓存导致的可见性"><a href="#缓存导致的可见性" class="headerlink" title="缓存导致的可见性"></a>缓存导致的可见性</h2><p>由于cpu拥有自己独立的缓存空间，多线程+多核CPU并发修改同一个变量的流程是：</p><ol><li>每个线程对应的CPU都加载内存中的变量到自己的缓存中；</li><li>修改变量，存入到CPU中缓存中；</li><li>数据从CPU的缓存输入到，内存中；</li></ol><p>由于cpu的缓存是独立的对其他线程不可见，所以就会出现在并发情况下内存中的变量相互覆盖。如图：</p><p><img src="./cpu2.png" alt="avator"></p><h2 id="线程切换的原子性"><a href="#线程切换的原子性" class="headerlink" title="线程切换的原子性"></a>线程切换的原子性</h2><p>  1个cpu可以“同时”执行多个进程，这里的“指的是，cpu在执行进程时候是通过在进程直接切换，每个进程执行一小段时候实现的。但是进程之间内存不共享，它们的切换需要修改内存地址，开销比较大。所以操作系统一般改为在一个进程替换切换线程来实现并发，因为线程共享内存，切换不需要修改内存地址。但是线程之间的切换往往会引起并发上的bug。<br>  如：我们在一个进程中的俩个线程都对一个变量做累加1000，往往结果不会等于2000，这就是在一个cpu下，俩个线程在执行上来回切换执行导致。如流程如下图下图：</p><p>  <img src="./thread1.png" alt="avator"></p><h2 id="编译优化的指令顺序"><a href="#编译优化的指令顺序" class="headerlink" title="编译优化的指令顺序"></a>编译优化的指令顺序</h2><p>  现代的编译器为了性能往往会对指令重排序，这就会导致一些奇怪的bug，如下双重检查的单例模式：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程A在执行这段代码的instance = new Singleton();在cpu的指令是3条命令，我们期望的步骤是：</p><ol><li>初始化地址&amp;M</li><li>在&amp;M地址上new Singleton()</li><li>&amp;M赋值给instance</li></ol><p>而实际上是</p><ol><li>初始化地址&amp;M</li><li>&amp;M赋值给instance</li><li>在&amp;M地址上new Singleton()</li></ol><p>这样线程B和A同时调用getInstance()的时候，有可能线程B执行第一个判断时候，由于编译器指令优化A已经instance=&amp;M，所以B判断instance不为空直接返回，但是这时候&amp;M还没有new Singleton()导致这空指针异常。</p><h1 id="java的内存模型"><a href="#java的内存模型" class="headerlink" title="java的内存模型"></a>java的内存模型</h1><p>由于java线程间通信采用的是共享内存的方式，所以遇到上述的指令重排序往往会引起一些bug，在此基础上，java采用了synchronized、volatile、final关键字以及6个Happens-Before规则来约束指令重排序。</p><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><h3 id="同一线程，前面的操作happens-before于后面的操作"><a href="#同一线程，前面的操作happens-before于后面的操作" class="headerlink" title="同一线程，前面的操作happens-before于后面的操作"></a>同一线程，前面的操作happens-before于后面的操作</h3><p>参考代码1，x=42一定happens-before v=true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码来源于【参考 1】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> v = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;</span><br><span class="line">    v = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里 x 会是多少呢？</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="volatile关键字修饰的变量，写happens-before读操作"><a href="#volatile关键字修饰的变量，写happens-before读操作" class="headerlink" title="volatile关键字修饰的变量，写happens-before读操作"></a>volatile关键字修饰的变量，写happens-before读操作</h3><p>结合代码1：如果线程a、b同时执行，线程a调用writer，线程b调用reader，那么v一定等于true</p><h3 id="happens-before传递性-a–-gt-b-b–-gt-c-则-a–-gt-c"><a href="#happens-before传递性-a–-gt-b-b–-gt-c-则-a–-gt-c" class="headerlink" title="happens-before传递性 a–&gt;b b–&gt;c 则 a–&gt;c"></a>happens-before传递性 a–&gt;b b–&gt;c 则 a–&gt;c</h3><p>结合这条规则和1、2看，x一定=42。因为x=42–&gt;v=true v=true–&gt;v==true 所以 x=42</p><h3 id="synchronized关键字，不同线程-解锁happens-before加锁"><a href="#synchronized关键字，不同线程-解锁happens-before加锁" class="headerlink" title="synchronized关键字，不同线程 解锁happens-before加锁"></a>synchronized关键字，不同线程 解锁happens-before加锁</h3><p>线程b，和线程a同时执行下面代码，线程a获取锁之后执行完成并且释放锁，这时候b执行，x的值一定是12。即线程a操作hanppens-before b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 此处自动加锁</span></span><br><span class="line">  <span class="comment">// x 是共享变量, 初始值 =10</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.x &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">12</span>;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125; <span class="comment">// 此处自动解锁</span></span><br></pre></td></tr></table></figure><h3 id="线程strat"><a href="#线程strat" class="headerlink" title="线程strat()"></a>线程strat()</h3><p>线程a调用了线程b.start()，那么a的变量和操作，线程b可见</p><h3 id="线程的join"><a href="#线程的join" class="headerlink" title="线程的join()"></a>线程的join()</h3><p>线程b在线程a中调用了b.join()，那么b里的共享变量和共享操作，a可见</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread B = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">  <span class="comment">// 此处对共享变量 var 修改</span></span><br><span class="line">  <span class="keyword">var</span> = <span class="number">66</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 例如此处对共享变量修改，</span></span><br><span class="line"><span class="comment">// 则这个修改结果对线程 B 可见</span></span><br><span class="line"><span class="comment">// 主线程启动子线程</span></span><br><span class="line">B.start();</span><br><span class="line">B.join()</span><br><span class="line"><span class="comment">// 子线程所有对共享变量的修改</span></span><br><span class="line"><span class="comment">// 在主线程调用 B.join() 之后皆可见</span></span><br><span class="line"><span class="comment">// 此例中，var==66</span></span><br></pre></td></tr></table></figure><h2 id="final的应用"><a href="#final的应用" class="headerlink" title="final的应用"></a>final的应用</h2><p>说明该变量初始化后即不变，其他线程访问时候也一定是一个完全初始化的变量，这就可以解决前面提到的双重检查单例线程不安全的问题。但是要小心溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码来源于【参考 1】</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">// 错误的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalFieldExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  x = <span class="number">3</span>;</span><br><span class="line">  y = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// 此处就是讲 this 逸出，</span></span><br><span class="line">  global.obj = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM调试的常用命令</title>
      <link href="JVM%E8%B0%83%E8%AF%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>JVM%E8%B0%83%E8%AF%95%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="java性能调优的主要几个工具"><a href="#java性能调优的主要几个工具" class="headerlink" title="java性能调优的主要几个工具"></a>java性能调优的主要几个工具</h1><p>通过jstack打印堆栈信息，得知线程的使用情况<br>通过jstat打印堆中gc以及对象的情况<br>通过jmap详细分析堆中内存的个数大小，必要时可以dump出来结合jhat查看</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p>打印JAVA的堆栈信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jstack &lt;pid&gt;</span><br></pre></td></tr></table></figure><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>统计gc、JVM的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">统计gc的情况</span><br><span class="line">jstat -gcutil &lt;pid&gt; <span class="number">2000</span> <span class="number">30</span></span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br></pre></td></tr></table></figure><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>统计jvm的内存中类的使用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">按数量排序</span><br><span class="line">jmap -histo:live &lt;pid&gt;|grep xxxx|sort -k <span class="number">2</span> -g -r|head</span><br><span class="line"></span><br><span class="line">按大小排序</span><br><span class="line">jmap -histo:live &lt;pid&gt;|grep xxxx|sort -k <span class="number">3</span> -g -r|head</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>配合jhat使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jmap -dump:live,file=xxx.log pid</span><br><span class="line">jhat xxx.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排查java异常进程的方法</title>
      <link href="%E6%8E%92%E6%9F%A5java%E5%BC%82%E5%B8%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>%E6%8E%92%E6%9F%A5java%E5%BC%82%E5%B8%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="定位JAVA进程中异常线程的方法"><a href="#定位JAVA进程中异常线程的方法" class="headerlink" title="定位JAVA进程中异常线程的方法"></a>定位JAVA进程中异常线程的方法</h1><p>日常使用中我们往往会遇到JAVA进程内存飙高，程序hang住，cpu的load过高等情况。这时候往往需要定位到JAVA的实例看下具体占用CPU、内存过高的线程都在做什么？<br>下面总结了下如何定位JAVA问题线程的方法。</p><h2 id="找到有问题的JVM进程"><a href="#找到有问题的JVM进程" class="headerlink" title="找到有问题的JVM进程"></a>找到有问题的JVM进程</h2><p>linux命令：top–找到有问题的JAVA进程<br>  shift+p 按照cpu排序<br>  shift+m按照内存排序</p><h2 id="查看有问题JAVA进程中的线程"><a href="#查看有问题JAVA进程中的线程" class="headerlink" title="查看有问题JAVA进程中的线程"></a>查看有问题JAVA进程中的线程</h2><p>linux命令：top -H -p  pid 查看pid进程下所有有问题的线程</p><ol><li>将十进制数换成16进制：printf “%x\n” tid</li><li>查看进程下的线程正在执行的方法： jstack pid |grep nid=0x【tid】 -A 30</li></ol><h2 id="jstack查看出来的线程信息梳理"><a href="#jstack查看出来的线程信息梳理" class="headerlink" title="jstack查看出来的线程信息梳理"></a>jstack查看出来的线程信息梳理</h2><p>线程的几种状态</p><ol><li>RUNNABLE，线程处于执行中</li><li>BLOCKED，线程被阻塞</li><li>WAITING，线程正在等待</li></ol><p>对于锁的竞争，可参照下面的思路排查问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程1获取到锁，处于RUNNABLE状态，线程2处于BLOCK状态；  </span><br><span class="line">1、locked &lt;0x000000076bf62208&gt;说明线程1对地址为0x000000076bf62208对象进行了加锁；  </span><br><span class="line">2、waiting to lock &lt;0x000000076bf62208&gt; 说明线程2在等待地址为0x000000076bf62208对象上的锁；  </span><br><span class="line">3、waiting for monitor entry [0x000000001e21f000]说明线程1是通过synchronized关键字进入了监视器的临界区，并处于&quot;Entry Set&quot;队列，等待monitor；</span><br></pre></td></tr></table></figure><h2 id="jmap查看JVM系统信息的命令"><a href="#jmap查看JVM系统信息的命令" class="headerlink" title="jmap查看JVM系统信息的命令"></a>jmap查看JVM系统信息的命令</h2><p>查找JVM中系统的大小和个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">按照个数统计  </span><br><span class="line">  jmap -histo:live  pid|grep keyword|sort -k 2 -g -r|head -10</span><br><span class="line"></span><br><span class="line">按照占用大小统计</span><br><span class="line">  jmap -histo:live  pid|grep keyword|sort -k 2 -g -r|head -10</span><br></pre></td></tr></table></figure><p>查看JVM中Heap的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap pid</span><br></pre></td></tr></table></figure><p>情况如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID Pid, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.65-b01</span><br><span class="line"></span><br><span class="line">using parallel threads <span class="keyword">in</span> the new generation.</span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Concurrent Mark-Sweep GC</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 40</span><br><span class="line">   MaxHeapFreeRatio         = 70</span><br><span class="line">   MaxHeapSize              = 4294967296 (4096.0MB)</span><br><span class="line">   NewSize                  = 858980352 (819.1875MB)</span><br><span class="line">   MaxNewSize               = 858980352 (819.1875MB)</span><br><span class="line">   OldSize                  = 3435986944 (3276.8125MB)</span><br><span class="line">   NewRatio                 = 4</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">New Generation (Eden + 1 Survivor Space):</span><br><span class="line">   capacity = 773128192 (737.3125MB)</span><br><span class="line">   used     = 9882512 (9.424697875976562MB)</span><br><span class="line">   free     = 763245680 (727.8878021240234MB)</span><br><span class="line">   1.2782501145683225% used</span><br><span class="line">Eden Space: (Edn区)</span><br><span class="line">   capacity = 687276032 (655.4375MB)</span><br><span class="line">   used     = 9882512 (9.424697875976562MB)</span><br><span class="line">   free     = 677393520 (646.0128021240234MB)</span><br><span class="line">   1.4379247260000476% used</span><br><span class="line">From Space: (Survivor中的From)</span><br><span class="line">   capacity = 85852160 (81.875MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 85852160 (81.875MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space: (Survivor中的To)</span><br><span class="line">   capacity = 85852160 (81.875MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 85852160 (81.875MB)</span><br><span class="line">   0.0% used</span><br><span class="line">concurrent mark-sweep generation: （老年代）</span><br><span class="line">   capacity = 3435986944 (3276.8125MB)</span><br><span class="line">   used     = 258117296 (246.1598358154297MB)</span><br><span class="line">   free     = 3177869648 (3030.6526641845703MB)</span><br><span class="line">   7.512173364067357% used</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查看GC的利器之一GCVIEWER</title>
      <link href="%E6%9F%A5%E7%9C%8BGC%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8B%E4%B8%80GCVIEWER/"/>
      <url>%E6%9F%A5%E7%9C%8BGC%E7%9A%84%E5%88%A9%E5%99%A8%E4%B9%8B%E4%B8%80GCVIEWER/</url>
      
        <content type="html"><![CDATA[<h1 id="Java的GC查看工具-GCVIEWER"><a href="#Java的GC查看工具-GCVIEWER" class="headerlink" title="Java的GC查看工具-GCVIEWER"></a>Java的GC查看工具-GCVIEWER</h1><h2 id="gcviews安装和使用"><a href="#gcviews安装和使用" class="headerlink" title="gcviews安装和使用"></a>gcviews安装和使用</h2><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/chewiebug/GCViewer.git</span></span><br><span class="line"></span><br><span class="line">mvn clean pacakge</span><br><span class="line"></span><br><span class="line">cd target</span><br></pre></td></tr></table></figure><h3 id="JVM开启gclog"><a href="#JVM开启gclog" class="headerlink" title="JVM开启gclog"></a>JVM开启gclog</h3><p>java的启动命令增加 -Xloggc:./gc.log参数下面是我的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:./gc.log xxx.jar</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>指定上面的gc.log的目录<br>java -jar gcviewer-1.36-SNAPSHOT.jar  ./gc.log<br>会看到如下的图表</p><h2 id="Chart的说明"><a href="#Chart的说明" class="headerlink" title="Chart的说明"></a>Chart的说明</h2><p>view能看到各GC的情况，右边是一些说明信息，summary查看具体的描述信息<br><img src="./gcviewer-1.png" alt="avatar"><br>EventDetail标识具体的GC的事件信息<br><img src="./gcviewer-2.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019学习计划</title>
      <link href="2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>2019%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="本年计划"><a href="#本年计划" class="headerlink" title="本年计划"></a>本年计划</h1><h2 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h2><ul><li>java并发编程</li><li>spring的源码</li><li>nio的学习<ul><li>netty的源</li><li>netty构建服务发现demo</li><li>netty聊天工具构建</li></ul></li><li>算法的学习</li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>rocketmq的源码，涉及到netty可以先看netty</li></ul><h2 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h2><ul><li>REDIS的源码学习</li></ul><h1 id="本周计划"><a href="#本周计划" class="headerlink" title="本周计划"></a>本周计划</h1><p>Netty聊天软件服务端demo</p><ul><li><del>协议的自定义（Encoder）</del></li><li><del>客户端和服务端通信</del></li><li><del>客户端注册和服务端注册</del></li><li>阶段性文档的整理（完成了哪些工作，有哪些坑）</li></ul><p>完成并发的学习和梳理</p><ul><li><del>完成HB原则和基础</del></li><li><del>完成synchroized关键字</del></li></ul><p><del>调研下限流和断路器</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习计划 </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountDownLatch</title>
      <link href="CountDownLatch/"/>
      <url>CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch解读"><a href="#CountDownLatch解读" class="headerlink" title="CountDownLatch解读"></a>CountDownLatch解读</h1><ul><li>是基于AQS原理，共享锁的一种实现，构造函数里的count值代表计数器，会将count赋值给state。</li><li>CountDownLatch不可重入。</li><li>通过await()来阻塞线程。countDown使计数器-1，当count为0时候所有await的线程会同时获取锁。</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>CountDownLatch有一个内部类Sync，该类继承了AQS,await()方法和countDown方法都是调用Sync的tryAcquireShared和tryReleaseShared</p><h2 id="共享锁获取锁-tryAcquireShared"><a href="#共享锁获取锁-tryAcquireShared" class="headerlink" title="共享锁获取锁-tryAcquireShared"></a>共享锁获取锁-tryAcquireShared</h2><p>CountDownLatch掉用await()实际上是调用sync的acquireSharedInterruptibly，最终会调用AQS中的doAcquireSharedInterruptiblyState，在该方法中调用doAcquireSharedInterruptibly，在改方法中，会调用CountDownLatch实现的tryAcquireShared方法如果state==0返回1，否则-1，其中代码和逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将当前线程封装成SHARDED类型的节点，加入到链表中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//自旋来获取锁，获取前置节点，如果前置节点是头结点，尝试获取锁，将当前节点设置为头节点，开始传播为后置节点解锁</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/**自旋解锁：唤醒头结点的线程并且开始根据链表顺序传播解锁。</span></span><br><span class="line"><span class="comment">                    *   因为是公平锁，所以无论现在在哪个线程都会根据链表顺序从head节点开始唤醒</span></span><br><span class="line"><span class="comment">                    **/</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通独占锁，根据前置节点的情况判断是否应该休眠（前置节点是SINGAL，当前节点的线程会block，如果前置节点是cancel会跳过所有cancel的节点）</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前的头节点当中间变量同时设置头结点</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//propagate&gt;0（这里是state==0），或者头结点为空，或者头结点不是CANCELED状态，或者现在的头节点为空，或者头结点不是CANCELED状态</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;<span class="comment">//把当前Node状态之后的节点Shared都唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">             <span class="comment">//自旋解锁，如果头结点的状态是SIGNAL，因为刚才将当前节点置为了Head，实际就是当前节点，同时一般ws也是SINGAL</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//cas成功后将头结点的线程解锁</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="comment">//刚才的setHead()方法已经将Thread=null所以，如果修改成功了会跳出循环</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面修改成功了node是</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享锁释放-tryAcquireShared"><a href="#共享锁释放-tryAcquireShared" class="headerlink" title="共享锁释放-tryAcquireShared"></a>共享锁释放-tryAcquireShared</h2><p>CountDownLatch调用countDown()时候回调用sync.releaseShared(1)，实际是AQS的releaseShared(int args)方法，如果返回true即state==0,在该方法中会调用doReleaseShared()，获取锁和传播获取锁的流程</p><p>CountDownLatch中的Sync的tryReleaseShared：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS中的releaseShared代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的队列同步器AQS</title>
      <link href="java%E7%9A%84%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/"/>
      <url>java%E7%9A%84%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8AQS/</url>
      
        <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>是java.util.concurrent.locks中最重要的类。翻译过来是“抽象队列同步器”,我们根据字面来理解：</p><ul><li>Abstract-它是抽象的，业务方根据自己的场景来实现tryAcqurie、tryRelease等方法。例如：CountDownLatch、CyclicBarrier、Semaphore、ReentrantLock等;</li><li>Queue-它维护了一个FIFO的队列，竞争锁的线程都会加入到这个对列中，排队竞争资源；</li><li>Synchronizer-它用来保证在并发情况下，线程安全。</li></ul><p>优点：<br>使用方便：满足日常线程调度的需求，通过CountDownLatch、CyclicBarrier、Semaphore，ReentrantLock很轻松实现了共享锁、公平锁等功能。<br>性能：在jdk1.6之前synchronized关键字很重，性能很不好（1.6之后引入偏向锁、自旋锁、轻量级锁性能已经替身了许多）</p><h2 id="主要逻辑"><a href="#主要逻辑" class="headerlink" title="主要逻辑"></a>主要逻辑</h2><p>以ReentrantLock为例，来解释加锁和释放锁的逻辑</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>调用acquire方法，对业务进行加锁，acquire流程如下：</p><ol><li>会调用tryAcquire(1)尝试获取锁，如果失败将当前线程加入到队列中；</li><li>addWatier将当前的线程封装成EXCLUSIVE模式的Node加入到队列中，其中为了避免失败采用了自旋的方法；</li><li>之后通过自旋acquireQueued获取锁资源，然后根据之前记录的线程是否被中断过的状态，进行线程中断，acquireQueued逻辑如下；<ul><li>获取当前节点的前置节点，如果前置节点是头结点，说明自己可以开始竞争锁资源了，如果成功，将当前节点置为头节点返回；</li><li>如果当前节点不是头结点，调用shouldParkAfterFailedAcquire判断该节点是否可以进入休眠状态，分支逻辑如下：<ul><li>前置节点如果的waitStatus如果是SIGNAL，说明后续节点可以休息返回ture；</li><li>如果前置节点的waitStatus是CANCELLED状态（&gt;0），通过循环跳过当前节点前置所有的CANCELLED节点；（之后结合释放锁来看）</li><li>否则将前置节点的状态CAS改为SIGNAL，acquireQueued下一次自旋，节点就会返回true；</li></ul></li></ul></li><li>如果返回允许挂起后调用parkAndCheckInterrupt()，通过LockSupport.lock()方法挂起当前线程；</li><li>获取锁资源后，判断线程是否被中断过调用：selfInterrupt()方法来中断线程。</li></ol><p>涉及的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">独占锁的获取锁方法</span></span><br><span class="line"><span class="comment">调用tryAcquire获取锁，如果失败将当前的节点和state加入到队列中，开始竞争/排队获取锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前线程封装成node(mode是独占模式)插入到队列末尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速插入将node插入到队列的末尾，只插入一次，失败后通过自旋重复插入直到成功</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//compareAndSetTail实现上是通过，修改tail字段的值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//失败后用自旋开始插入</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自旋插入队列尾</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果tail为空。初始化队列（tail=head=new Node）,然后下次循环将node插入到到tail后面，这时候 new Node()-&gt;node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//自旋找到头结点，获取锁</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果前置节点是头节点，tryAcquire获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//成功后将当前节点设置为头节点，interrupted=false</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果失败判断状态，并且挂起当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否该挂起线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置节点的类型</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果前置节点状态为SIGNAL，当前节点可以挂起</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//代码为什么不ws==Node.CANCELLED???</span></span><br><span class="line">        <span class="comment">//循环链表，跳过所有前置节点watiStatus是CANCELLED的节点，直到第一个不是CANCELLED的节点。</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//等待状态是是Propagated状态，CAS改为SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//具体实现见下面LockSupport.park详解</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>调用acquire方法，对业务进行加锁，acquire流程如下：</p><p>调用release方法多锁进行释放，其中逻辑如下，ps:ReentrantLock的公平锁模式会判断是否有前置节点，如果有才会修改state</p><ol><li>通过调用tryRelease(1)释放锁，成功后取到头head链表的head节点(一般head节点持有的线程都是自己)；</li><li>判断head节点的状态，不为空，同时waitStatus!=0，因为在acqureQueued如果有后置节点已经将他改为SIGNAL状态，所以如果为空说明没有后置节点；</li><li>调用unparkSuccessor(h)，唤醒后置节点，具体逻辑如下：<ul><li>获取头节点位置，见头节点位置将头节点waitStatus置为0；</li><li>找到后置节点，如果后置节点为空或者是CANCELLED，从尾部开始遍历链表，找到离头节点最近的一个不是CANCELLED状态的节点</li><li>通过LockSupport.unpark(s.thread)唤醒线程开始竞争锁；</li></ul></li><li>这时候这个被唤醒的线程回到acquireQueued的自旋中，走到“p == head &amp;&amp; tryAcquire(arg)”这个分支中，即时这时候p!=head，走入shouldParkAfterFailedAcquire方法中，由于这个节点到head之前的节点都赢是CANCELLED对象（见上报从尾部开始遍历链表），所以跳过所有CANCELLED节点，下次必然会p==head，获取锁。</li></ol><p>涉及的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒后置节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取头节点状态，置为0防止重复唤醒</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到后置节点，如果后置节点为空，或者状态是CANCELLED,从尾部开始遍历链表，找到离头节点最近的一个不是CANCELLED状态的节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS利用队列实现了在并发情况下，多线程之间的调度问题；并且合理利用了自旋和挂起笔名了线程之间上下文切换的损耗，和无效的竞争。</p><h2 id="其他相关知识"><a href="#其他相关知识" class="headerlink" title="其他相关知识"></a>其他相关知识</h2><h3 id="LockSupport对线程阻塞和唤醒（park-unpark）"><a href="#LockSupport对线程阻塞和唤醒（park-unpark）" class="headerlink" title="LockSupport对线程阻塞和唤醒（park/unpark）"></a>LockSupport对线程阻塞和唤醒（park/unpark）</h3><p>相比wait和notify的优势</p><ol><li>不用先用synchronized获取同步锁。</li><li>LockSupport是基于线程对象的，而wait和notify是基于锁对象的，所以不会遇到遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题</li></ol><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(Object blocker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程，并且设置parkBlocker对象，jstack查看时候就可以知道线程是在哪个对象上阻塞，这里是AQS的实现类</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    setBlocker(t, blocker);</span><br><span class="line">    <span class="comment">//阻塞线程，绝对时间，并且无限制的阻塞</span></span><br><span class="line">    UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//阻塞停止，将parkBlocker置为空。</span></span><br><span class="line">    setBlocker(t, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS中FIFO队列介绍，内部类Node"><a href="#AQS中FIFO队列介绍，内部类Node" class="headerlink" title="AQS中FIFO队列介绍，内部类Node"></a>AQS中FIFO队列介绍，内部类Node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议-UDP</title>
      <link href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-UDP/"/>
      <url>%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-UDP/</url>
      
        <content type="html"><![CDATA[<h1 id="UDP协议的定义"><a href="#UDP协议的定义" class="headerlink" title="UDP协议的定义"></a>UDP协议的定义</h1><p>UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，一种无连接的协议，不保证数据是否传输到，不保证数据包的顺序。特点是速度较快</p><h1 id="UDP的特点"><a href="#UDP的特点" class="headerlink" title="UDP的特点"></a>UDP的特点</h1><p>结合TCP来看UDP的特点</p><ol><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持并发的定时器+数据归档解决查询效率</title>
      <link href="%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/"/>
      <url>%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>客户的数据量徒增，每天1QWPV，1个月1张表的话大约这一个客户有30亿数据，页面上一些接口的响应变慢。</p><p>原因是：后端数据存在了ES中，ES特点是模糊查询很开，但是但是如果用到了一些叫复杂的聚合函数需要进行索引扫描，所以效率了堪忧。</p><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ul><li>每天，用定时器将客户网站数据归档，目前是采用mysql保存。</li><li>前端查询采用缓存数据+当天数据的方式呈现给客户，当日的数据很小所以可以满足性能上的要求。</li><li>考虑到将来会有很多客户，可能一个定时器执行效率慢，所以定时器要支持水平扩展。</li></ul><h2 id="具体执行"><a href="#具体执行" class="headerlink" title="具体执行"></a>具体执行</h2><ol><li>将数据库中所有的网站ID放到redis的zset中，为什么用zset？有序-支持分页，排重；</li><li>利用setNx做锁， 从zset取出一条数据锁住：setNx的key是：prefix:statslock:id:yyyyMMdd, ttl：1天；<ul><li>因为采用的是RedisTemplate不支持setNx和expire排异常轻快无法解锁，所以锁是按天锁住数据</li></ul></li><li>ES查询昨天的数据，归档</li><li>前端查询ES当钱数据+归档数据返回，测试从10sec请求变为了600ms</li></ol><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWafDataArchiveByDate</span><span class="params">(LocalDateTime localDateTime)</span> </span>&#123;</span><br><span class="line">    String dateFormater = localDateTime.format(YYYYMMDD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分页</span></span><br><span class="line">    Long total = statsRedis.domainSize();</span><br><span class="line">    Long pageNo = (total - <span class="number">1L</span>) / ZSET_PAGE_SIZE + <span class="number">1</span>;</span><br><span class="line">    Long curPage = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从redis获取数据</span></span><br><span class="line">        Long startIdx = (curPage - <span class="number">1L</span>) * ZSET_PAGE_SIZE;</span><br><span class="line">        Long endIdx = startIdx + ZSET_PAGE_SIZE - <span class="number">1L</span>;</span><br><span class="line">        Set&lt;String&gt; set = statsRedis.queryRange(startIdx, endIdx);</span><br><span class="line"></span><br><span class="line">        curPage++;</span><br><span class="line">        <span class="keyword">for</span> (String domainUuid : set) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//锁1天</span></span><br><span class="line">                <span class="keyword">if</span> (taskLock.lock(domainUuid, dateFormater)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//do logic</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                taskLock.unlock(domainUuid,dateFormater);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (curPage &lt;= pageNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遗留的坑以及方案"><a href="#遗留的坑以及方案" class="headerlink" title="遗留的坑以及方案"></a>遗留的坑以及方案</h2><p>待补充</p>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> redis </tag>
            
            <tag> 定时器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议-TCP</title>
      <link href="%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP/"/>
      <url>%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE-TCP/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-IP的三次握手"><a href="#TCP-IP的三次握手" class="headerlink" title="TCP/IP的三次握手"></a>TCP/IP的三次握手</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>第一次握手：client端建立链接视乎。client端发送包（SYN=1，seq=x），这时候客户端进入SYN_SENT状态</li><li>第二次握手：server端收到SYN包，需要确认client端的seq(ack=x+1)。server端发送SYN+ACK包(SYN=1,ACK=1,seq=y,ack=x+1)，这时候server端进入SYN_RECV状态</li><li>第三次握手：client端手server端SYN+ACK包，需要确认server端的seq(ack=y+1)。client端发送ACK包(ACK=1,ack=y+1)，这时候client和server都是ESTABLISHED</li></ol><p>至此完成链接，开始传输数据</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>建立安全的双工的通信通道，保证双方都能发送、收到数据。</p><h2 id="TCP-IP的四次挥手"><a href="#TCP-IP的四次挥手" class="headerlink" title="TCP/IP的四次挥手"></a>TCP/IP的四次挥手</h2><h3 id="四处挥手流程"><a href="#四处挥手流程" class="headerlink" title="四处挥手流程"></a>四处挥手流程</h3><ol><li>第一次挥手：client端发出断开链接请求。client发送包（FIN=1,seq=x），client端状态为FIN_WAIT_1</li><li>第二次挥手：server端收到FIN包，需要确认client端的seq(ack=x+1)。server端发送ACK包(ACK=1,seq=y,ack=x+1) ，server端状态为CLOSE_WAIT，client端收到后状态FIN_WAIT_2</li><li>第三次挥手：server端不会立刻关闭链接，会继续发送完到client端的数据，server端发送FIN包(FIN=1,seq=z,ack=x+1)，server端状态为LAST_ACK,client端状态为FIN_WAIT_2</li><li>第四次挥手：client端发送ACK包确认server端的FIN(ack=z+1)，client端发送ACK包(ACK=1,ack=z+1,seq=h),server端状态为CLOSED,client端状态为TIME_WAIT状态。</li></ol><p>至此4次挥手完成，客户端进入TIME_WAIT–2MSL–&gt;CLOSED。<br>  主要：如果client发送了FIN,服务端没有发送ACK直接发送了FIN,这时候客户端会变成CLOSEING。（比如FIN包由于网络原因丢失）</p><h3 id="四次挥手目的"><a href="#四次挥手目的" class="headerlink" title="四次挥手目的"></a>四次挥手目的</h3><p>实现双工链接关闭的安全性。防止客户端的端口重用后，还收到上次服务端的请求</p><h3 id="TIME-WAIT和CLOSE-WAIT状态"><a href="#TIME-WAIT和CLOSE-WAIT状态" class="headerlink" title="TIME_WAIT和CLOSE_WAIT状态"></a>TIME_WAIT和CLOSE_WAIT状态</h3><p>  TIME_WAIT状态：对于复杂的网络状态，TCP 的实现提出了多种应对措施，TIME_WAIT 状态的提出就是为了应对其中一种异常状况。为了理解 TIME_WAIT 状态的必要性，我们先来假设没有这么一种状态会导致的问题。暂以 A、B 来代指 TCP 连接的两端，A 为主动关闭的一端。</p><ul><li>四次挥手中，A 发 FIN， B 响应 ACK，B 再发 FIN，A 响应 ACK 实现连接的关闭。而如果 A 响应的 ACK 包丢失，B 会以为 A 没有收到自己的关闭请求，然后会重试向 A 再发 FIN 包。如果没有 TIME_WAIT 状态，A 不再保存这个连接的信息，收到一个不存在的连接的包，A 会响应 RST 包，导致 B 端异常响应。此时， TIME_WAIT 是为了保证全双工的 TCP 连接正常终止。</li><li><p>我们还知道，TCP 下的 IP 层协议是无法保证包传输的先后顺序的。如果双方挥手之后，一个网络四元组（src/dst ip/port）被回收，而此时网络中还有一个迟到的数据包没有被 B 接收，A 应用程序又立刻使用了同样的四元组再创建了一个新的连接后，这个迟到的数据包才到达 B，那么这个数据包就会让 B 以为是 A 刚发过来的。此时， TIME_WAIT 的存在是为了保证网络中迷失的数据包正常过期。</p><p>由以上两个原因，TIME_WAIT 状态的存在是非常有意义的。</p></li></ul><h3 id="为什么客户端要等待2MSL才能关闭"><a href="#为什么客户端要等待2MSL才能关闭" class="headerlink" title="为什么客户端要等待2MSL才能关闭"></a>为什么客户端要等待2MSL才能关闭</h3><p>协议规定主动关闭一方，进入FIN_WAIT_2-&gt;TIME_WAIT，必须等待2MSL（MSL为最大报文段生存时间，LWIP为1分钟，windows为2分钟）时间然后才进入CLOSED，删除TCP控制块。在2MSL等待时间内迟到的报文段将被抛弃。</p><ul><li>报文段有生存时间，当连接关闭时，有可能收到迟到的报文段。这时，若立马就建立新的连接（同一端口），那么新的连接就会接收迟到的报文，误以为是发给自己的。</li><li>另一个原因是可靠的实现全双工连接的终止：由于网络原因可能服务端没有收到ACK包，所有会在一段时间内重新发送FIN包和ACK包。</li></ul><p>不用等待2MSL的方法：使能SO_REUSEPORT(允许重用本地地址)，可以通过调用setsockopt函数来使能。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 计算机基础 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql自增ID用完了怎么办</title>
      <link href="Mysql%E8%87%AA%E5%A2%9EID%E7%94%A8%E5%AE%8C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
      <url>Mysql%E8%87%AA%E5%A2%9EID%E7%94%A8%E5%AE%8C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="表自增ID"><a href="#表自增ID" class="headerlink" title="表自增ID"></a>表自增ID</h1><ol><li>如果主键是auto_incrment，如果达到了最大值，不会在增长，这时候写入会报主键冲突</li><li>如果没指定，会用dict_sys.row_id的值，作为主键，长度6字节，如果达到最大值会从0开始循环写入</li></ol><p>所以，推荐这只auto_incrment，毕竟报主键冲突比覆盖以前的数据要好的多。</p><h1 id="XID"><a href="#XID" class="headerlink" title="XID"></a>XID</h1><p>mysql对应事物的ID，Mysql的内存中会维护一个golbal_query_id的变量，改变量在内存中重启会清0，每次执行语句会吧当前值赋值给Query_id，并且+1,<br>如果当前语句是事务中的一个语句那么会把这个Xid赋值给事物ID</p><p>Mysql在重启后由于会清零，同时会有一个新的binlog所以一个binlog中xid是不冲突的。但是如果执行时间过长，理论上也可能会冲突吗，因为XID到达最大值后会从0开始分配，只不过这个值太大了2E64-1,所以冲突只存在在理论中。</p><h1 id="Innodb-trxid"><a href="#Innodb-trxid" class="headerlink" title="Innodb trxid"></a>Innodb trxid</h1><p>  区别于XID，XID是Server层的trxId是innodb层的</p><p>  innodb内部维护了个max_trx_id，每次申请时候会获取当前的max_trx_id，然后max_trx_id+1；</p><p>  inndob的事务可见性核心思想是：每次更新都更新了数据的trx_id，当一个事务读到数据的时候判断一致性视图和当前trx_id的关系</p><p>  对于正在执行的事物可以通过：information_schema.innodb_trx表中看到当前事务的trx_id;</p><p>  注意trx_id的分配规则：</p><ol><li>只读事物不分配trx_id，把当前事物的trx_id变量的指针地址转成int+2e48<ol><li>这么做的好处是只读事物中，指针地址不会变，同一个只读事务在innodb_locks和innodb_trx查出来的trx_id是一致的；</li><li>不同的事务由于指针地址会变，查出来的trx_id一定是不同的</li><li>加上2e48也是能区别于读写事物</li></ol></li><li><p>同时trx_id可能看到不只加了1：</p><ol><li>因为update和delete操作也会+1，（标记删除，放到purge队列中）</li><li>innodb的后台操作比如表的索引信息统计等都会+1</li></ol><p>只读事务不分配trx_id的好处</p></li><li><p>减少事务视图中活跃事务数，innodb在创建一致性视图时候值需要copy读写事物的trx_id就好了</p></li><li><p>可以减少trx_id的申请次数</p><p>trx_id是被持久化不会清0的所以当到达最大值后，会从0开始，这时候就可能会出现脏读。因为后续的数据trx_id变小了，变成可见的了，但是因为这个值是2e48-1所以这个错误也只存在于理论上。（50万TPS，要跑17.8年）</p></li></ol><h1 id="thread-id"><a href="#thread-id" class="headerlink" title="thread_id"></a>thread_id</h1><p>mysql有个thread_id_counter每次分配完后+1，如果到达最大值后会从0开始，这时候会看到俩个一样的thread_id</p><p>不过mysql在分配时候有一个逻辑来处理这种情况</p><p>thread_ids是个唯一数组，添加失败后会一直循环（待验证）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  new_id= thread_id_counter++;</span><br><span class="line">&#125; <span class="keyword">while</span> (!thread_ids.insert_unique(new_id).second);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>要不要使用分区表</title>
      <link href="%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/"/>
      <url>%E8%A6%81%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%88%86%E5%8C%BA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql的分区表"><a href="#mysql的分区表" class="headerlink" title="mysql的分区表"></a>mysql的分区表</h1><p>分区表是什么？他有什么好处？有什么坏处？为什么不建议生产环境上使用分区表？</p><p>测试的脚本如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`ftime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">KEY</span> (<span class="string">`ftime`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(ftime))</span><br><span class="line">(<span class="keyword">PARTITION</span> p_2017 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2017</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2018 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2018</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"> <span class="keyword">PARTITION</span> p_2019 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">2019</span>) <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>,</span><br><span class="line"><span class="keyword">PARTITION</span> p_others <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="string">'2017-4-1'</span>,<span class="number">1</span>),(<span class="string">'2018-4-1'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>可以看到表空间下，有一个frm文件和4个ibd文件说明</p><ul><li>server层这是一个表</li><li>innodb的引擎层这是4个表</li></ul><h2 id="分区表引擎层行为"><a href="#分区表引擎层行为" class="headerlink" title="分区表引擎层行为"></a>分区表引擎层行为</h2><h3 id="对于innodb来说"><a href="#对于innodb来说" class="headerlink" title="对于innodb来说"></a>对于innodb来说</h3><p>因为mysql的间隙锁和行锁是在引擎层做的，所以同一张表，分区表和普通的表的加锁规则可能会有所不同。还是用咱们例子对于分区表加锁的流程如下<br><img src="./分区表1.png" alt="avator"></p><p>而如果一个普通表他的加锁规则如下<br><img src="./分区表1.jpg" alt="avator"></p><p>原因是2018-02-1这条数据是在另一个分区，所以SessionA的间隙锁范围没设计到，儿2017-12-1这条数据和SessionA在同一分区所以被block住</p><h3 id="对于myisam来说"><a href="#对于myisam来说" class="headerlink" title="对于myisam来说"></a>对于myisam来说</h3><p>由于myisam是表锁，但是这个由于引擎上分区表被分成了四张表所以，会造成下面的情况，破坏了引擎原生锁的规则<br><img src="./分区表1.png" alt="avator"></p><h3 id="其他的坑"><a href="#其他的坑" class="headerlink" title="其他的坑"></a>其他的坑</h3><p>对于mysisam表采用的是通用分区策略，第一次访问分区表，会把表分区都走一遍，所以如果一个分区很大比如超过1024个，而我们的句柄数只有1024，这时候很可能会报错<br>对于innodb没有这个问题，因为采用的是本地分区策略，在后续版本Myisam已经不支持分区表了（5.7 deprecated,8.0正式弃用）</p><h2 id="分区表对于Server层来说"><a href="#分区表对于Server层来说" class="headerlink" title="分区表对于Server层来说"></a>分区表对于Server层来说</h2><p>因为server层对于分区表看成是一张表，所以在MDL的时候不同分区的DDL会被block主。如图：<br><img src="./分区表3.png" alt="avator"></p><h2 id="分区表应用场景"><a href="#分区表应用场景" class="headerlink" title="分区表应用场景"></a>分区表应用场景</h2><p>对于业务来说只看到一张表，所以很简洁，并且可以随时添加新的分区，以及按照历史分区清理表数据</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于分区表的特性会破坏引擎层的锁的定义，所以不建议在生产环境使用，建议采用手工分区的方式</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grant后一定要flush privileges</title>
      <link href="grant%E5%90%8E%E4%B8%80%E5%AE%9A%E8%A6%81flush-privileges/"/>
      <url>grant%E5%90%8E%E4%B8%80%E5%AE%9A%E8%A6%81flush-privileges/</url>
      
        <content type="html"><![CDATA[<h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'ua'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'pa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">from</span> <span class="string">'ua'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure><p>这条命令有俩个含义</p><ol><li>磁盘中，数据库mysql.user表插入一个用户</li><li>内存中同步用户。</li></ol><p>这时候是不需要flush privileges的。只有当我们手动修改一张表时候为了让内存和数据库表同步才需要执行该命令。</p><p>添加权限的方式具体参加Mysql手册</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何最快的复制一张表</title>
      <link href="%E5%A6%82%E4%BD%95%E6%9C%80%E5%BF%AB%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/"/>
      <url>%E5%A6%82%E4%BD%95%E6%9C%80%E5%BF%AB%E7%9A%84%E5%A4%8D%E5%88%B6%E4%B8%80%E5%BC%A0%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="如何快速的复制一张表"><a href="#如何快速的复制一张表" class="headerlink" title="如何快速的复制一张表"></a>如何快速的复制一张表</h1><p>我们往往会采用insert … select。但是这种做法会对原表加锁。所以更稳妥的办法是将表导出到临时文件中。本文章会讨论如何快速的赋值一张表。测试数据如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br><span class="line">delimiter ;;</span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    while(i&lt;=1000)do</span><br><span class="line">      <span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(i,i,i);</span><br><span class="line">      <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db2;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> db2.t <span class="keyword">like</span> db1.t</span><br></pre></td></tr></table></figure><h1 id="mysqldump方法"><a href="#mysqldump方法" class="headerlink" title="mysqldump方法"></a>mysqldump方法</h1><p>例如命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">--add-locks=0 --no-create-info --single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --result-file=/client_tmp/t.sql</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>single-transaction 不对表db1 t 加锁， START TRANSACTION WITH CONSISTENT SNAPSHOT的方法；</li><li>add-locks 输出的文件不增加”LOCK TABLES t WRITE”</li><li>no-create-info 不需要导出表结构</li><li>set-gtid-purged 不需要gtid的信息</li><li>result-file 生成文件的位置，注意是客户机的位置</li></ol><p>这时候t.sql就是一条insert语句，我们在新表上执行t.sql就可以导入数据了，导入语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h127.0.0.1 -P13000  -uroot db2 -e "source /client_tmp/t.sql"</span><br></pre></td></tr></table></figure><p>注：source并不是Mysql的命令，真正的语句还是Insert</p><h1 id="导出CSV文件"><a href="#导出CSV文件" class="headerlink" title="导出CSV文件"></a>导出CSV文件</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> db1.t <span class="keyword">where</span> a&gt;<span class="number">900</span> <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'/server_tmp/t.csv'</span>;</span><br></pre></td></tr></table></figure><p>这条语句注意如下：</p><ol><li>受参数secure-file-priv控制<ol><li>如果是NULL，说明 outfile被进制</li><li>设置为empty，可写到任意地方，一般不建议这么设置这是不安全的</li><li>设置为目录，说明outfile只能到指定的目录</li></ol></li><li>t.csv没有覆盖功能，所以要保证目标目录下的t.csv不存在否则会报错</li><li>原则是一条数据行对应文本一行，但是如果数据行有换行符能会跟上“\”这个转义字符这样字段之间、数据行之间可能会分开</li></ol><p>导入命令如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/server_tmp/t.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> db2.t;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><ol><li>打开文件，”\t”区分字段，“\n”区分数据</li><li>校验csv文件的字段和新表字段是否一致，不一致会报错</li><li>循环写入到新表知道写入完成</li><li>如果binlog_format是statement<ol><li>主库完成后，将csv文件内容直接写到binlog中</li><li>binlog写入load data local infile ‘/tmp/SQL_LOAD_MB-1-0’ INTO TABLE <code>db2</code>.<code>t</code>。</li><li>这个binlog传到备库</li><li>备库apply接到这个binlog<ol><li>现将csv内容写入到SQL_LOAD_MB-1-0中</li><li>执行loaddate导入数据</li></ol></li></ol></li></ol><p>如图：<br><img src="./loaddata.jpg" alt="avtor"></p><p>注意：loaddata有俩种方式</p><ul><li>加local，读取的是服务器文件，受参数secure-file-priv控制</li><li>不加local，读取的是客户端文件，不收参数secure-file-priv控制</li></ul><p>还有csv里不包含表结构，所以可以用下面的语句导出表结构和csv数据文件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h$host -P$port -u$user <span class="comment">---single-transaction  --set-gtid-purged=OFF db1 t --where="a&gt;900" --tab=$secure_file_priv</span></span><br></pre></td></tr></table></figure><h1 id="物理copy法"><a href="#物理copy法" class="headerlink" title="物理copy法"></a>物理copy法</h1><p>优点：速度最快，适合大表的导入<br>缺点：只能在服务器copy表文件；并且没法导入部分数据；且双方都得是innodb表</p><p>流程如下</p><ol><li>执行create table r like t;</li><li>执行alter table r discard tablespace，这时候r.ibd会被删掉</li><li>执行flush table t for export，这时候db1会生成t.cfg文件</li><li>在db1目录下执行cp t.cfg r.cfg;cp t.ibd r.ibd</li><li>执行unlock tables，这时候t.cfg会被删除</li><li>执行alter table r import tablespace,将这个r.ibd作为表空间，由于是步骤4cp过来的所以就有了表数据</li></ol><p>如图<br><img src="./物理copy法.jpg" alt="avtor"></p><p>注意：</p><ul><li>在步骤3 flush 表之后，表是被lock的</li><li>执行import tablespace时候为了让表空间id和数据文件一直会刷新所有的数据页，import会有一定执行空间但是比逻辑导入会快很多。</li><li>一定要注意权限问题（尤其是执行步骤4时候要确认好是否对.ibd有读写权限）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert 语句的加锁</title>
      <link href="insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81/"/>
      <url>insert-%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%8A%A0%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="insert…select为什么要对目标表加锁"><a href="#insert…select为什么要对目标表加锁" class="headerlink" title="insert…select为什么要对目标表加锁"></a>insert…select为什么要对目标表加锁</h1><p>测试语句如下，注：隔离模式是RR，binlog_format=statement</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">like</span> t</span><br></pre></td></tr></table></figure><p>执行如下的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c,d <span class="keyword">from</span> t;</span><br></pre></td></tr></table></figure><p>这条语句是给表t所有的字段和间隙加锁，原因是考虑到数据的一致性例如下面的情况:</p><p><img src="./img1.png" alt="avator"></p><p>SessionA和SessionB同时执行，SessionB会给索引c的(-supernum,-1]加上nextkey-lock，原因是如果没有这个锁，很可能主库上B先执行，A后执行，但是binlog上回是A先执行，B后执行，导致从库会出现-1的值，造成主备不一致</p><p>当然了，目标表的锁其实是给涉及到的字段加锁，详见前面的加锁原理</p><p>见下面俩种情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2(c,d) <span class="keyword">select</span> c+<span class="number">1</span>,d <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这条语句实际上会对表t中的索引c(3,4]和(4,supernum)加锁。扫描行数只有2行</p><p>但是下面的语句就不是很好了,把表t最大值+1插入会原表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(c,d) <span class="keyword">select</span> c+<span class="number">1</span>,d <span class="keyword">from</span> t <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>原因是：</p><ul><li>在一张表中操作，mysql为了select时候读到insert的值，需要将select的结果导入到临时表中</li><li>临时表是memory类型的表，因为有limit 1，需要将表里的数据都导入到临时表中，排序取第一条</li><li>所以需要全表扫描，并且对全表所有的行加锁。</li></ul><p>优化的方法是：采用临时表来解决语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(c <span class="built_in">int</span>,d <span class="built_in">int</span>) <span class="keyword">engine</span>=<span class="keyword">memory</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t  (<span class="keyword">select</span> c+<span class="number">1</span>, d <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(c) <span class="keyword">order</span> <span class="keyword">by</span> c <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">select</span> * <span class="keyword">from</span> temp_t;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> temp_t;</span><br></pre></td></tr></table></figure><h1 id="insert违反唯一约束加锁"><a href="#insert违反唯一约束加锁" class="headerlink" title="insert违反唯一约束加锁"></a>insert违反唯一约束加锁</h1><p>见下图：<br><img src="./insert_block.png" alt="avator"></p><p>SessionA在第2次插入时候违反了唯一约束，这时候SessionB的语句并没有因为SessionA的insert失败开始执行反而是block住。原因是SessionA在后滚之前为冲突的索引(5,10]加了nextkey-lock读锁。</p><p>在并发情况下也会引起死锁，如图：<br><img src="./insert_dead_lock.png" alt="avator"></p><p>原因是：</p><ol><li>SessaionA为记录加行锁c=5。（唯一索引等值查询是行锁）</li><li>T2时刻SessionB和SessionC都对c=5加了读锁。（违反唯一约束）这时候都是等待状态</li><li>T3时刻SessionArollback，<ol><li>SessionB和SessionCD的读锁生效；</li><li>SessionB和SessionC要继续执行插入操作，这时候要对数据加写锁，这时候需要等待对方释放读锁，循环等待发生死锁。</li></ol></li></ol><p>见图:<br><img src="./insert_dead_lock2.jpg" alt="avator"><br>解决方法</p><ol><li>事务中唯一约束冲突后要尽快提交或者回滚，防止并发写循环等待；</li><li>采用insert into…duplicate key update的方式，因为这时候会加一个nextkey-lock写锁是互斥的。这样sessionB和sessionC不会循环等待。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自增主键相关-AUTO_INCREMENT</title>
      <link href="%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3-AUTO-INCREMENT/"/>
      <url>%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%9B%B8%E5%85%B3-AUTO-INCREMENT/</url>
      
        <content type="html"><![CDATA[<h1 id="自增主键的原理"><a href="#自增主键的原理" class="headerlink" title="自增主键的原理"></a>自增主键的原理</h1><p>首先创建测试表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>我们MySql的主键往往设置成auto_incrment</p><ul><li>原理是什么呢？</li><li>为什么会有不连续的情况？</li></ul><h2 id="自增字值保存在哪里"><a href="#自增字值保存在哪里" class="headerlink" title="自增字值保存在哪里"></a>自增字值保存在哪里</h2><p>不同的表引擎对于auto_incrment处理是不同的</p><ul><li>MyIsam表是保存在数据结构中</li><li>Innodb表是保存在内存中的<ul><li>5.7以及之前的版本是保存在内存中，每次数据库启动时候会查找表的max(id)，然后+1。如果这时候有auto_incrment=11,id=10,如果这条id=10的数据被删除后从起mysql，Auto_incrment的值又变成10</li><li>在Mysql 8.0中auto_incrment的值保存在redolog中，依靠redolog来恢复</li></ul></li></ul><h2 id="自增值的修改方式"><a href="#自增值的修改方式" class="headerlink" title="自增值的修改方式"></a>自增值的修改方式</h2><p>如果一个值被设置为auto_incrment，当一条插入语句时候</p><ol><li>如果这个值是null或者0，会把当前的auto_incrment值设置进去</li><li>如果手动设置了值，就是用设置的值</li></ol><p>这时候auto_incrment的变化如下，插入值是X，auto_incrment的值是Y，</p><ol><li>如果X &lt; Y，自增值不变</li><li>如果X &ge; Y，自增值变为新的自增值，计算方法是：当前的auto_incrment_offset+auto_incrment_increment知道比X大。</li></ol><h2 id="自增值的修改时机来看为什么自增值不连续"><a href="#自增值的修改时机来看为什么自增值不连续" class="headerlink" title="自增值的修改时机来看为什么自增值不连续"></a>自增值的修改时机来看为什么自增值不连续</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>主要看第2条语句的执行流程</p><ol><li>Innodb调用引擎写入一条数据(null, 1, 1)</li><li>因为id是null所以获取当前的auto_incrment，现在是2</li><li>改变auto_incrment，变为3</li><li>这时候插入（2,1,1）;</li><li>所以C冲突插入失败</li><li>语句结束</li></ol><p>可以看到这时候auto_incrment是没有变回2。原因是，因为有可能这时候并发写入，如果回滚了后续的写入都会报主键冲突，同理事物的回滚也类似。</p><h1 id="自增锁的优化"><a href="#自增锁的优化" class="headerlink" title="自增锁的优化"></a>自增锁的优化</h1><p>为了增加并发能力，Mysql为自增字段加锁不是一个事务锁，每次申请完了都会释放。但是在Mysql5.1之前不是这样的。</p><p>在5.1.22版本中增加了一个新策略inoodb_autoinc_lock_mode,默认值是1</p><ul><li>0，类似之前的设计直到每个语句执行结束才会释放</li><li>1，普通的insert会立刻释放，select。。。。insert ，load等批量操作需要等语句执行完</li><li>2，都会立刻释放</li></ul><p>推荐设置成2，同事binlog格式设置成row，既能保证并发度，又能保证主备数据不一致。原理是</p><p>当binlog的格式是statement时候，select。。。。insert 在并发阶段很可能造成主从数据不一致。比如下图：</p><p><img src="./批量并发.png" alt="avator"></p><ul><li>很可能涉及sessionB的binlog拿到从库执行由于id都是null，是没法保证执行顺序的造成主备不一致。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们是否还需要用Memory引擎的表</title>
      <link href="%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E8%BF%98%E9%9C%80%E8%A6%81%E7%94%A8Memory%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%A8/"/>
      <url>%E6%88%91%E4%BB%AC%E6%98%AF%E5%90%A6%E8%BF%98%E9%9C%80%E8%A6%81%E7%94%A8Memory%E5%BC%95%E6%93%8E%E7%9A%84%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Memory引擎表的特点"><a href="#Memory引擎表的特点" class="headerlink" title="Memory引擎表的特点"></a>Memory引擎表的特点</h1><ul><li>Memory表是堆组织表，对应的Iondb是索引组织表。</li><li>Memory索引顺序是按照写入顺序，Innodb是按照主键顺序</li><li>Memory的索引存放规则决定这他所有索引是一样的没有主键概念</li><li>Memory的索引和数据是分开存放的，在主键ID索引里，存的是每个数据的位置，且顺序是按照hash顺序。Innodb是按照B+树存放的</li><li>Memory不支持blog和Text字段，所有行数的长度都相同。（要充分的利用内存嘛~）</li><li>Memory数据出现空洞时候可以任意位置插入数据，Innodb为了保证索引顺序只能在后面递增插入数据</li><li>Memory数据位置发生改变需要改所有的索引，而Innodb只需要改主键位置，</li></ul><h1 id="不推荐用Mermory在生产环境的原因"><a href="#不推荐用Mermory在生产环境的原因" class="headerlink" title="不推荐用Mermory在生产环境的原因"></a>不推荐用Mermory在生产环境的原因</h1><ol><li>锁粒度不够：不支持行锁，性能会很差，往往不如Innodb</li><li>由于Mysql重启后会删除Memory表数据，数据持久性会有问题<ol><li>尤其是双M架构，当备库重启后，会同步binlog给主库把表清空</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysq何时会用到内部临时表</title>
      <link href="Mysq%E4%BD%95%E6%97%B6%E4%BC%9A%E7%94%A8%E5%88%B0%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
      <url>Mysq%E4%BD%95%E6%97%B6%E4%BC%9A%E7%94%A8%E5%88%B0%E5%86%85%E9%83%A8%E4%B8%B4%E6%97%B6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql何时会使用内部临时表"><a href="#Mysql何时会使用内部临时表" class="headerlink" title="Mysql何时会使用内部临时表"></a>Mysql何时会使用内部临时表</h1><p>Mysql除了我们显式的创建临时表外，在某些情况下会用到内部临时表，在开始之前可以先用下面脚本创建一个测试库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>, a <span class="built_in">int</span>, b <span class="built_in">int</span>, <span class="keyword">index</span>(a));</span><br><span class="line">delimiter ;;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> idata()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">  while(i&lt;=1000)do</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(i, i, i);</span><br><span class="line">    <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line"><span class="keyword">end</span>;;</span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> idata();</span><br></pre></td></tr></table></figure><h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>如下面的语句，取俩条语句结果的并集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> <span class="number">1000</span> <span class="keyword">as</span> f) <span class="keyword">union</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>执行计划如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line">| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br><span class="line">|  1 | PRIMARY      | NULL       | NULL       | NULL  | NULL          | NULL    | NULL    | NULL | NULL |     NULL | No tables used  |</span><br><span class="line">|  2 | UNION        | t1         | NULL       | index | NULL          | PRIMARY | 4       | NULL |    2 |   100.00 | Using index     |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+<span class="comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span></span><br></pre></td></tr></table></figure><p>最后的Extra字段Using temporary表示使用了临时表</p><p>该语句流程如下：</p><ol><li>创建一个内存临时表，只有一个字段是f，f是主键;</li><li>将第一条查询语句结果插入到临时表中</li><li>执行第2个子查询<ol><li>将符合条件的插入到临时表中，如果是union取并集，违反唯一约束写入失败；</li><li>继续插入直到不符合规则</li></ol></li><li>返回结果，删除临时表</li><li>注:如果是union all因为没有计算并集的需求也就没有唯一约束就不用临时表了</li></ol><h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>例如下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>%<span class="number">10</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p>执行计划如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                        |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | PRIMARY,a     | a    | 5       | NULL | 1000 |   100.00 | Using index; Using temporary; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+----------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>通过Extra字段可以看到3个信息</p><ul><li>Using index 因为需要遍历索引树，这里没选PRIMARY原因是因为a索引够用（只取count），并且相对PK更小</li><li>Using temporary 用了临时表</li><li>Using filesort 排序</li></ul><p>流程如下：</p><ol><li>创建内存临时表，创建俩个字段（m,c），且m为主键</li><li>将id%10，然后得到m，写入到临时表<ol><li>如果m不存在，insert m,1</li><li>如果m存在，update c字段+1；</li></ol></li><li>然后临时表通过filesort排序，内存临时表rowid排序，见前面的文章</li><li>返回结果，移除临时表。</li></ol><p>上面提到里都是创建一个内存临时表，这是由参数tmp_table_size值控制的默认是16M，如果超过这个值就采用磁盘临时表了</p><h3 id="group-by优化方案"><a href="#group-by优化方案" class="headerlink" title="group by优化方案"></a>group by优化方案</h3><p>临时表会消耗内存，甚至是磁盘。所以在生产环境上我们哟啊尽量避免这种内部临时表的产生，针对上面说的group by有如下几点优化建议</p><h4 id="通过索引"><a href="#通过索引" class="headerlink" title="通过索引"></a>通过索引</h4><p>上面的例子，我们可以创建一个id%10的字段,然后根据这个字段group by</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">column</span> z <span class="built_in">int</span> <span class="keyword">generated</span> <span class="keyword">always</span> <span class="keyword">as</span>(<span class="keyword">id</span> % <span class="number">100</span>), <span class="keyword">add</span> <span class="keyword">index</span>(z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> z, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> z;</span><br><span class="line"></span><br><span class="line">执行计划会告诉这你这条语句走的是索引z</span><br></pre></td></tr></table></figure><h4 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h4><p>原理是，因为mysql会默认走临时表，但是我们可以通过SQL_BIG_RESULT来提示mysql这个结果集很大，让mysql直接选择磁盘临时表，mysql发现这个临时表是b+tree结构，不如数组方式排序效率高，就不会采用临时表而是至用filesortset了</p><p>sql语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">SQL_BIG_RESULT</span> <span class="keyword">id</span>%<span class="number">100</span> <span class="keyword">as</span> m, <span class="keyword">count</span>(*) <span class="keyword">as</span> c <span class="keyword">from</span> t1 <span class="keyword">group</span> <span class="keyword">by</span> m;</span><br></pre></td></tr></table></figure><p>执行计划如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | PRIMARY,a     | a    | 5       | NULL | 1000 |   100.00 | Using index; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------+---------+------+------+----------+-----------------------------+</span></span><br></pre></td></tr></table></figure><p>语句执行流程是：</p><ol><li>初始化sort_buffer，去顶放入整形字段m</li><li>扫秒表t1索引树a,将id%100值放入sort_buffer中</li><li>在sort_buffer对m排序</li><li>返回数组</li></ol><h1 id="总结mysql何时会用临时表呢"><a href="#总结mysql何时会用临时表呢" class="headerlink" title="总结mysql何时会用临时表呢"></a>总结mysql何时会用临时表呢</h1><ol><li>如果mysql一边读数据，一边直接获取结果不需要额外的内存保存结果，否则会需要额外内存；</li><li>join_buffer是无序数据，sort_buffer是有序数组，临时表是二维表结构</li><li>如果执行逻辑需要二维表特性，就优先使用临时表，比如:Union需要唯一约束，groupby需要额外保存计数</li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql临时表的用法</title>
      <link href="Mysql%E4%B8%B4%E6%97%B6%E8%A1%A8/"/>
      <url>Mysql%E4%B8%B4%E6%97%B6%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="外部临时表"><a href="#外部临时表" class="headerlink" title="外部临时表"></a>外部临时表</h1><p>本问主要解决如下的问题：</p><ol><li>临时表为什么能重名</li><li>什么情况下使用临时表</li></ol><h2 id="临时表和引擎是Mermory表的区别"><a href="#临时表和引擎是Mermory表的区别" class="headerlink" title="临时表和引擎是Mermory表的区别"></a>临时表和引擎是Mermory表的区别</h2><ul><li>首先内存表的数据是保存到内存中的，当数据库关闭后数据会消失，只保留表结构。</li><li>而临时表是可以指定任意表引擎的，且临时表和当前Mysql的htread现关，当一个session关闭后临时表会被删掉。</li><li>不同session的临时表可以重名</li></ul><h2 id="为什么临时表能重名"><a href="#为什么临时表能重名" class="headerlink" title="为什么临时表能重名"></a>为什么临时表能重名</h2><p>临时表是和当前的线程相关：</p><ul><li>Mysql5.6包含5.6之前，Mysql会在临时文件目录下建立一个”前缀.ibd”的文件，用来存放数据文件</li><li>Mysql5.7之后的版本，引入了一个临时表空间，专门用来存放练市文件，不需要在创建ibd文件了。</li><li>前缀是：库名+表名+serverid名+线程id。</li></ul><p>Mysql每个名都有一个def_table_name，临时表的表明就是”库名+表名+serverid名+线程id”，所以不同线程之间的临时表是可以重名的。</p><p>注：innodb类型的临时表会在临时文件目录下，文件名的是#sql{进程 id}+{线程 id}+序列号，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t(<span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>)<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span><br></pre></td></tr></table></figure><h2 id="如何使用临时表"><a href="#如何使用临时表" class="headerlink" title="如何使用临时表"></a>如何使用临时表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#建表语法是：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">temporary</span> <span class="keyword">table</span> temp_t <span class="keyword">like</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看临时表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> temp_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">#对临时表操作</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> temp_t <span class="keyword">add</span> <span class="keyword">index</span>(b);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> temp_t <span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> b&gt;=<span class="number">1</span> <span class="keyword">and</span> b&lt;=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">join</span> temp_t <span class="keyword">on</span> (t1.b=temp_t.b);</span><br></pre></td></tr></table></figure><p>mysql每个库都维护一个表名的链表，临时表排在前面，查找表名时候会轮训链表，发现表名对应的表是临时表时候会优先使用临时表。</p><h1 id="临时表的使用场景"><a href="#临时表的使用场景" class="headerlink" title="临时表的使用场景"></a>临时表的使用场景</h1><p>分库分表：比如我们按照字段对一个表进行分库分表，当有一个查询条件不是按照分表规则进行查询时候有俩种解决方法</p><ol><li>proxy来做聚合</li><li>通过临时表聚合</li></ol><h1 id="临时表的主备库处理"><a href="#临时表的主备库处理" class="headerlink" title="临时表的主备库处理"></a>临时表的主备库处理</h1><ul><li>当binlog格式是state时候，主从同步时候要把临时表涉及的binglo都同步过去</li><li>如果是row格式则不用。</li><li>另外删除临时表的binlog会在一条语句中完成，所以只有drop语句binlog会格式化，crud的语句statement会原封不懂的传递给从库</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>join的使用</title>
      <link href="join%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>join%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql的join"><a href="#MySql的join" class="headerlink" title="MySql的join"></a>MySql的join</h1><p>我们在考虑sql语句用join的时候往往基于以下两点来看：</p><ol><li>业务是否能用join</li><li>哪个表是驱动表</li></ol><h1 id="Index-Nested-Loop-Join（NLJ）"><a href="#Index-Nested-Loop-Join（NLJ）" class="headerlink" title="Index Nested-Loop Join（NLJ）"></a>Index Nested-Loop Join（NLJ）</h1><p>见下面的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a有索引</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.a);</span><br></pre></td></tr></table></figure><p>这条语句的执行顺序如下：</p><ol><li>表T读出一行数据R</li><li>用数据R到t2中找</li><li>取出t2中的一行作为结果集</li><li>重复1-3步骤,t1循环结束</li></ol><p>这里先对是t1的全表扫描,t2查找相关数据，时间复杂度（N+N*2log2N 注意N是驱动表，2log2N是采用2级索引），如果是采用这种nlj算法，显然join会比用程序一行行循环查找要好。因为减少了和数据库的交互次数</p><p>同时因为时间复杂度是N+N*2log2N ，所以N越小越好，也就是驱动表是小表。</p><h1 id="Block-Nested-Loop-Join（BNL）"><a href="#Block-Nested-Loop-Join（BNL）" class="headerlink" title="Block Nested-Loop Join（BNL）"></a>Block Nested-Loop Join（BNL）</h1><p>如果join的字段如果没有所以呢?如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">straight_join</span> t2 <span class="keyword">on</span> (t1.a=t2.b);</span><br></pre></td></tr></table></figure><p>这时候mysql为了防止多次扫描驱动表，会用到join_buffer，通过参数join_buffer_size，默认是256K</p><p>执行的过程如下：</p><ol><li>扫描表t1，顺序读取t1，数据放到join_buffer中，如果超过join_buffer就放一部分</li><li>扫描表t2，把t2中的每一行取出来，跟join_buffer做对比，满足条件的当结果集返回</li><li>清空join_buffer</li><li>继续扫描表t1,执行步骤2-3直到结束。</li></ol><p>当t1表数据不超过join_buffer_size时候，谁当驱动表都无所谓；否则的话小表当驱动表，减少写join_buffer次数。</p><p>BNL的坏处：</p><ol><li>多次扫描被驱动表，增大磁盘的IO负担</li><li>内存中计算的时间复杂度可能是M*N,增大CPU负担</li><li>影响buffer_pool：对于大的冷数据表的join查询，可能会将这些数据移到buffer_pool的young区，影响业务的buff_pool命中率，而1、2在语句结束后会停止影响，可是3的影响是持续的需要后面业务主键淘汰掉这些数据页的buffer</li></ol><h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h1><h2 id="对于NLJ"><a href="#对于NLJ" class="headerlink" title="对于NLJ"></a>对于NLJ</h2><p>可以开启mrr（multi-range-read）和bka(batch-key-access)</p><ul><li>原理是 原来是需要从驱动表找到一条数据，然后一条去被驱动表查询。且是随机读，速度很慢；</li><li>开启mrr和bak<ul><li>mrr原理是在查询的索引上做一次排序，然后把随机度改为顺序读。</li><li>bak是基于mrr，将join时候从驱动表中尽量多取出一些行（只保留必要字段），放到join_buffer中如果超过join_buffer_size会分多段，然后去被驱动表中查询。批量的顺序读</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span>;</span><br></pre></td></tr></table></figure><h2 id="对于BNL"><a href="#对于BNL" class="headerlink" title="对于BNL"></a>对于BNL</h2><p>通过建立索引的方式转成NLJ的方式<br>对于不适合建立索引的，通过业务拆分优化</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我查这么多数据，会不会把数据库内存打爆?</title>
      <link href="%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/"/>
      <url>%E6%88%91%E6%9F%A5%E8%BF%99%E4%B9%88%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BC%9A%E4%B8%8D%E4%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AD%98%E6%89%93%E7%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="全表扫描对server的影响"><a href="#全表扫描对server的影响" class="headerlink" title="全表扫描对server的影响"></a>全表扫描对server的影响</h1><h2 id="一条返回值聚到的sql语句是怎么处理的"><a href="#一条返回值聚到的sql语句是怎么处理的" class="headerlink" title="一条返回值聚到的sql语句是怎么处理的"></a>一条返回值聚到的sql语句是怎么处理的</h2><p>假设我们执行下面的语句执行全表扫描，这条sql语句从server到客户端的流程如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$host -P$port -u$user -p$pwd -e "<span class="keyword">select</span> * <span class="keyword">from</span> db1.t<span class="string">" &gt; $target_file</span></span><br></pre></td></tr></table></figure><ol><li>结果先写入到net_buffer中，由参数net_buffer_lenght决定（def:16m）</li><li>net_buffer写满后，通过网络接口发送出去</li><li>接续写入新的数据到net_buffer</li><li>如果发送函数遇到返回值EAGAIN状态，或者WSAEWOULDBLOCK，说明本地网络栈被写满了，进入等待状态，知道网络栈可用继续写入。</li></ol><p>可见mysql对于查询结果的发送是边读取边写的这样防止了大的sql语句一次性读写导致oom</p><p>如图所示：</p><p><img src="./查询数据流程.jpg" alt="avator"></p><h2 id="send-data-to-client和sending-data的区别"><a href="#send-data-to-client和sending-data的区别" class="headerlink" title="send data to client和sending data的区别"></a>send data to client和sending data的区别</h2><p>上面发送数据给client过程中sql语句状态会被置为send data to client状态，要和sending data区分开</p><p>sending data是当一条sql语句执行时候就被设置为该状态，知道这条语句结束，所以sending data并不能表示这条语句正在往客户端发送数据</p><p>当数据继续开始往客户端发送时候数据处于send data to client阶段。<br>当执行器开始执行sql语句时候，这条sql语句处于sending data阶段</p><h2 id="mysql-store-result"><a href="#mysql-store-result" class="headerlink" title="mysql_store_result"></a>mysql_store_result</h2><p>一般我们都会采用参数：mysql_store_result直接把查询结果保存到本地，而不是mysql_use_result,读一行处理一行，因为如果一个事务逻辑很复杂很可能要处理很久才会去读下一行</p><h1 id="全表扫描对innodb的影响"><a href="#全表扫描对innodb的影响" class="headerlink" title="全表扫描对innodb的影响"></a>全表扫描对innodb的影响</h1><p>还记得Mysql更新采用了BUFF_POOL+WAL的顺序写机制替代了，随机写，加速了写的性能么？其实BUFF_POOL的这个机制还加速了查询的性能。比如一个sql语句查询数据的时候，如果数据页在内存中，那么就不用扫描磁盘了，一般一个稳定的线上业务buff_pool的磁盘命中率都会很高我们可以用命令show engine innodb status来查看命中率。</p><p>那么如果全表扫描一个很大的表，触发了buff_pool的Lru算法是否很极大的降低buff_pool的命中率，增大磁盘的开销呢？mysql是采用什么策略优化这种情况的呢？</p><p>Mysql的lru算法如图：</p><ol><li>mysql吧buff_pool分了young和old代，占比是5:3</li><li>如果命中的数据页在young代会被移动到链表的head处</li><li>如果新插入了一个数据页，Px,会淘汰最靠近tail的pm,这时候px会插入到old代的头部；</li><li>处于old区域的数据页被访问时候，Mysql会有一个策略<ol><li>发现数据页已经在old区存在了1秒以上了，会移动到young</li><li>反之，不移动，慢慢被淘汰</li></ol></li></ol><p>mysql用这种策略来优化全表扫描，因为全表扫描时候这些数据页会顺序读，所以肯定不会超过1秒，所以不会移动到young，只会在old代慢慢被淘汰，而且淘汰只会限制在old代，对young完全无影响（正常业务的查询）</p><p><img src="./lru_mysql.png" alt="avator"></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>误删数据后的处理</title>
      <link href="%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>%E8%AF%AF%E5%88%A0%E6%95%B0%E6%8D%AE%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="误删数据的几种情况"><a href="#误删数据的几种情况" class="headerlink" title="误删数据的几种情况"></a>误删数据的几种情况</h1><p>对于误删除数据进行了简单的分类：</p><ol><li>使用delete语句误删除数据航；</li><li>使用droptable或者truncate table误删除表数据；</li><li>使用dropdatabase语句误删除数据库；</li><li>使用rm命令删除整个mysql实例；</li></ol><h2 id="误删行–用delete"><a href="#误删行–用delete" class="headerlink" title="误删行–用delete"></a>误删行–用delete</h2><ul><li>方法：可使用工具Flashback来恢复误删除的数据；</li><li>条件：使用FalshBack的条件，binlog_format=row和 binlog_row_image=FULL</li><li>原理：解析binlog，并且把binlog的逆向修改，那会原数据库重放；</li><li>注意：<ul><li>逆向后不要重新那回主库重放，要先从一个林水库开始，然后由临时库在恢复到主库上，防止直接在一个在线的主库上还原，破坏了数据关联，造成数据2次破坏；</li><li>数据库的防范于未然：sql语句的安全模式：set [global] sql_safe_updates = 1，这样当update delete没有where条件时候就会报错；</li></ul></li></ul><h2 id="drop-table或者truncate-table"><a href="#drop-table或者truncate-table" class="headerlink" title="drop table或者truncate table"></a>drop table或者truncate table</h2><p>  delete删除全表往往性能会很差，因为要写undolog redolog binlog等，这时候如果有删除全表的需求就可以考虑用：drop table或者truncate table来删除<br>。<br>  当使用这几个命令时候我们的binlog是statement格式的，所以也没法用上面的方法恢复数据。</p><p>  误删库表恢复的流程是怎样的呢？</p><ol><li>去最后一次全量备份的库，恢复出一个临时库；</li><li>在日志备份里，取当前备份点之后的日志，除了误删除的语句，应用到临时库中；</li></ol><p>如图：<br><img src="误删数据后的处理/误删库恢复流程.png" alt="avator"></p><p>注意：</p><ol><li>如果临时库的实例上有多个数据库，在使用mysqlbinlog命令可以加上–database参数，来指定误删除库；</li><li>恢复数据跳过误删除的binlog的方法上：<ol><li>如果原实例没有GTID模式:我们只能在备份日志中先找到误删除的那个操作用-stop-position参数执行前的日志，在用-start-position从误删除之后的操作执行；</li><li>GTID模式:我们可以在临时库上执行：set gtid_next=gtid1;begin;commit；先把这个gtid加到临时库的gtidset中，之后重放binlog会自动跳过这个操作</li></ol></li></ol><h3 id="恢复表和库的加速"><a href="#恢复表和库的加速" class="headerlink" title="恢复表和库的加速"></a>恢复表和库的加速</h3><p>上面的做法还是不够快，因为：</p><ol><li>如果是误删表：我们期望只恢复这张表的数据，但是mysqlbinlog工具不能只解析一张表的日志；</li><li>用mysqlbinlog恢复出的应用日志，只能是单线程恢复，无法利用并行复制的功能；</li></ol><p>解决方案：</p><p>第一种方法：临时库在被全量恢复（设置了gtid后）后，将这个临时库置为主库的从库，然后这个临时库在执行start salve之前执行；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#让临时库只同步误删除的表，同时主-&gt;备可以利用并行复制</span></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">replication</span> filter replicate_do_table = (tbl_name)</span><br></pre></td></tr></table></figure><p>如图：<br><img src="误删数据后的处理/误删库加速.png" alt="avator"></p><h3 id="mysql的binlog丢失"><a href="#mysql的binlog丢失" class="headerlink" title="mysql的binlog丢失"></a>mysql的binlog丢失</h3><p>有一种情况，如果要恢复的是个很久远的库，备库上又不能无限制的保存binlog,导致需要的binlog备库没有log的情况该如何操作呢？</p><ol><li>假设临时库上需要的master.000005，而备库上从master.000007开始的，意味这我们要从备份系统上下载master.000005，master.000006放到备库上</li><li>之后打开备库的master.index文件上（根据配置名字可能不同），加上”./master.000005”，”./master.000006”</li><li>重启备库，让备库识别这俩个文件</li><li>建立主备关系开始同步数据</li></ol><p>综上：误删库的恢复是通过定期全量备份+增量备份来恢复数据库，建议DBA把流程做成自动化，同时定期演练减伤损失。</p><h2 id="搭建延迟复制备库"><a href="#搭建延迟复制备库" class="headerlink" title="搭建延迟复制备库"></a>搭建延迟复制备库</h2><p>假设：当一个大库的备份周期是1周一备份，同时在第6天发生了误操作，这时候就要恢复6天的binlog，恢复时间可能是按天计的，对于在线业务是不允许的。这时候我们可以通过搭建一个延迟赋值的备库来解决。</p><ol><li>这个机制是mysql5.6之后引入的有一个机制，我们在备库可以通过命令CHANGE MASTER TO MASTER_DELAY=N（单位：秒），即延迟N秒同步命令。</li><li>比如：CHANGE MASTER TO MASTER_DELAY=3600，那么当一个误操作发生后，这个备库会在一个小时以后收到这条命令，我们可以在这段时间内stop salve;</li><li>然后恢复这一个小时的数据并且跳过这个命令即可；</li></ol><h2 id="预防误删除库-表的方法"><a href="#预防误删除库-表的方法" class="headerlink" title="预防误删除库/表的方法"></a>预防误删除库/表的方法</h2><p>我们应该尽量最大化的目标误删除操作：</p><ol><li><p>账号分离：</p><ol><li>业务账号应该只有MDL权限</li><li>日常的数据查询值用只读账号</li></ol></li><li><p>指定操作规范：</p><ol><li>删除表前线对表改名，观察一段时间</li><li>该表明要有命名规范比如_to_be_deleted</li></ol></li></ol><h2 id="rm删除"><a href="#rm删除" class="headerlink" title="rm删除"></a>rm删除</h2><p>HA会选取一个从库作为主库，我们只需要回复这个机器即可；<br>为防止这个事情发生可以做跨机房或者跨城市备份</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的索引--草稿</title>
      <link href="mysql/mysql%E7%B4%A2%E5%BC%95/"/>
      <url>mysql/mysql%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql的索引-草稿"><a href="#mysql的索引-草稿" class="headerlink" title="mysql的索引-草稿"></a>mysql的索引-草稿</h1><p>唯一索引和普通索引区别<br>  读：<br>    唯一索引在查询上和普通索引的差距不大<br>    原因：mysql是将整个数据页加载到内存中，1个数据页有16KB，可以加载很多数据（都是索引和主键指针），儿唯一索引和普通索引的区别就是查询完后是break还是continue<br>  写：<br>    唯一索引，需要在每次写入时候读取数据判断是否唯一，所以不能利用changebuffer。所以更新需要将数据页cp到内存中更新。（如果数据页不巧没在内存中，性能消耗就会很大，数据页加载涉及到随机读）<br>    数据更新，只需要将数据写到changebuffer中，然后在下次用到数据（或者定时）将changebuffer，merge到数据页，所以会很快。</p><p>索引的使用上<br>  索引使用是在优化器上进行的。优化器使用索引的依据是索引的基数（不重复的数据，可以用show index xxx看索引基数），使用基数大的索引。当频繁的删除，有可能导致基数不准选错索引。<br>  同时优化器在判断索引时候回考虑，会表的可能有可能会因为回表导致，选错索引</p><p>  方法<br>  用ANALYZE TABLE table;优化索引<br>  删除不需要的索引</p><p>有什么情况用不到索引<br>  原则：对于索引字段进行计算不会走上索引，会采用全索引遍历或者全表扫描<br>  例如：</p><pre><code>1. 索引字段加减；a+1=10002. 字段类型转化 比如 id=&apos;1111&apos;---&gt;CAST(id ,varchar)=&apos;1111&apos;3. 字段隐式类型转化：比如CAST(id,utf8mb4)=&apos;xxx&apos;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql的锁-全局锁、表锁、行锁、间隙锁</title>
      <link href="mysql/mysql%E7%9A%84%E9%94%81/"/>
      <url>mysql/mysql%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql的锁"><a href="#mysql的锁" class="headerlink" title="mysql的锁"></a>mysql的锁</h1><h2 id="全局锁（FTWRL）"><a href="#全局锁（FTWRL）" class="headerlink" title="全局锁（FTWRL）"></a>全局锁（FTWRL）</h2><p>Mysql提供的针对数据库级别的对数据加读锁的功能:Flush tables with read lock。之后针对这个数据库的增删改、DDL、事物提交语句都会被堵塞住。他主要的用途是用于数据库全库的逻辑备份。</p><ul><li>优点：<ul><li>全局锁是数据库级别的，所有表引擎都支持，在数据的导出对库实例加锁，保持导出数据逻辑的一致性。</li><li>和设置数据库只读（set global readonly=true）相比，全局锁在当前链接异常或者中断的情况下可以自动释放，而设置数据库只读不能。</li></ul></li><li>缺点：导出操作如果对数据库加锁，数据库的变更操作会被lock住，解决方案：对于Innodb引擎，可以用mysql自带的mysqldump工具使用参数–single-transaction.</li></ul><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>mysql的表级锁分俩种，一种是表锁，一种是元数据锁（meta data lock MDL）</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>预发是 lock tables … read/write。可以用unlock主动释放锁。也可以在链接中断时候自动释放。<br>表锁对于自己和其他线程读写操作的限制如下：如果对一个表进行read/write锁。其他线程在写or读/写时都会堵塞；同时本线程也只能读or读写该表，其他表无法访问。</p><h3 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h3><p>该锁不用显示的使用，在访问表的时候会自动加上，他用来保证访问数据时候数据表结构的稳定性，他有如下特点：</p><ul><li>对一个表的数据CRUD时候，加MDL读锁；当修改表结构时候，加MDL写锁</li><li>读锁是不互斥的，因为这些操作不会该表结构，所以可以多个线程同时对表做CRUD；</li><li>读写锁之间，写锁之间是互斥的，也就是说当对表进行CRUD时候，为了保证返回数据的稳定性，DDL操作是堵塞的。</li></ul><p>由于上面MDL的读写锁机制，就会有下面这种情况，修改一个访问量很高的小表，会导致整个库挂掉：<br>比如:</p><ol><li>大量的select语句，加了MDL读锁，这时候是不会堵塞的;</li><li>这时候有一条alter表的语句需要执行，加了MDL写锁，开始block。</li><li>由于select量很大，alter会一直堵塞，这时候后续的select也会堵塞，很块连接池就被用完了。</li></ol><p>解决方法：<br>MariaDB 已经合并了 AliSQL的方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>为了加强数据库的并发度引入的锁的机制，他有如下几个特点：</p><ul><li>行锁是由mysql的表引擎决定，Innodb支持行锁，MyISM不支持行锁。</li><li>Innodb的行锁是两阶段锁：即数据需要锁的时候对数据涉及到的行加锁；在事务结束后才释放行锁；</li></ul><h3 id="如何减少行锁的锁冲突"><a href="#如何减少行锁的锁冲突" class="headerlink" title="如何减少行锁的锁冲突"></a>如何减少行锁的锁冲突</h3><p>为了减少锁的冲突，我们在事务中要把会引起锁冲突的语句往后放。因为事务是原子性的所以，在一个事务中，要么都成功要么都失败，所以我们在一个事务中根据业务需求可以把一些没有锁冲突的操作或者语句放在事务的前面先只是，可能会造成锁冲突的语句放在后面，减少锁冲突加大并发。</p><h3 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h3><ul><li>出现原因：循环的资源等待。举个例子：俩个事务，事务1:用户uid=1点赞,事务2：用户uid=1取消赞。如下：这时候在并发时候可能会造成死锁当事务1、事务2都执行完第一条语句时候，这时候事务1等待事务2执行完第二条语句释放，这时候事务2执行完第二条语句等待事务一释放</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#事务1 点赞</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> reply <span class="keyword">SET</span> like_ammount=like_ammount+<span class="number">1</span> <span class="keyword">WHERE</span> reply_id=<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> user_sum <span class="keyword">SET</span> like_sum=like_sum+<span class="number">1</span> <span class="keyword">WHERE</span> uid=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#事务2取消赞</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> user_sum <span class="keyword">SET</span> like_sum=like_sum<span class="number">-1</span> <span class="keyword">WHERE</span> uid=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> reply <span class="keyword">SET</span> like_ammount=like_ammount<span class="number">-1</span> <span class="keyword">WHERE</span> reply_id=<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><ul><li>解决方法<ul><li>等待锁超时，用innodb_lock_wait_timeout来设置；（默认50s）</li><li>用死锁检查的方式innodb_deadlock_detect设置为on，表示开启，一旦发生死锁回滚死锁链条中的某个事务让其他事务可以进行；</li></ul></li></ul><h3 id="死锁检查真的很美好么？"><a href="#死锁检查真的很美好么？" class="headerlink" title="死锁检查真的很美好么？"></a>死锁检查真的很美好么？</h3><p>死锁检查是一个O(n*n)的时间复杂度的操作，因为每一个被堵塞的线程都会检查是否是自己导致了死锁。导致会有大量的线程做无谓的死锁检查，最终现象是CPU很高，但是并发度很低。</p><p>解决方案：</p><ul><li>粗暴的做法：如果确定没有死锁情况，关掉死锁检查。</li><li>控制并发度：客户端自己控制，最多只有N个线程同时进行修改，但是不排除一个库有多个客户端（比如多连接池）</li><li>中间件开发：如果发现请求数据一样的，进行排队减少冲突。（成本高）</li></ul><h2 id="间隙锁-gap-lock-与幻读"><a href="#间隙锁-gap-lock-与幻读" class="headerlink" title="间隙锁(gap lock) 与幻读"></a>间隙锁(gap lock) 与幻读</h2><p>什么是幻读？为什么会出现幻读？幻读有什么危害？</p><ul><li>事物在RR隔离级别下；</li><li>一个事物中，俩次查询涉及的条件相同，后面的语句出现了之前查询没有存在的数据。（注意：出现了新增的数据）；</li><li>为什么出现幻读：RR隔离级别下，当数据发生改变，采用当前读的原则</li><li>幻读的危害：破坏了业务的语意；违反了数据的一致性</li></ul><p>为什么需要间隙锁？当数据库的隔离级别是RR的情况下，由于Mysql的行锁在为数据上锁的时候需要数据在表中，也就是说对于新插入的数据mysql是无法上锁的。这样就会出现幻读的情况。innodb为了解决幻读引入了间隙锁。</p><h2 id="innodb是如何加间隙锁的"><a href="#innodb是如何加间隙锁的" class="headerlink" title="innodb是如何加间隙锁的"></a>innodb是如何加间隙锁的</h2><ol><li>当一个涉及到为数据加锁的语句执行时候，会为涉及到的数据加行锁，同时为整个表的数据之间加间隙锁（gap lock）,这个行锁+间隙锁也叫next-key-lock。</li><li>间隙锁是个左开，右闭的空间。比如一张表有如下数据  </li><li>间隙锁只会锁插入语句，其他的操作是不互斥的。</li></ol><p>具体例子说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#表t(id, c(有索引))有数据（1，3），（1，5），（1，7），有如下3个事物，是不冲突的 t1 ,t2锁不冲突， t3会被间隙锁block</span></span><br><span class="line"><span class="comment">#间隙锁是(-∞,3],(3,5],(5,7],(7,supernum]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#t1</span></span><br><span class="line">begion transaction;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span>  t <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#t2</span></span><br><span class="line">begion transaction;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> c=<span class="number">1</span> <span class="keyword">where</span> c=<span class="number">5</span> <span class="keyword">for</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#t3</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="间隙锁的缺点"><a href="#间隙锁的缺点" class="headerlink" title="间隙锁的缺点"></a>间隙锁的缺点</h3><p>间隙锁也并不是万能的在某些情况下会造成死锁比如，下面的情况：</p><ol><li>判断断C=5是否存在；</li><li>不存在就insert,存在就update；</li><li>图中在并发的情况下，且c=5不存在，行锁无效，触发间隙锁，这时候事物2的insert需要等待事物1commit之后释放间隙锁。</li><li>但是事物1，因为也insert导致了，不能释放锁就触发了死锁。</li></ol><table><thead><tr><th>事物1</th><th>事物2</th></tr></thead><tbody><tr><td>begin transaction;</td><td>begin transaction;</td></tr><tr><td>select * from t where c=5 for update ;</td><td>select * from t where c=5  for share update;</td></tr><tr><td>select * from t where c=5 for update ;</td><td>select * from t where c=5  for share update;</td></tr><tr><td>-</td><td>insert into t values(5,5);</td></tr><tr><td>insert into t values(5,5);（dead lock）</td><td>-</td></tr></tbody></table><p>这种方式的解决方案，在满足业务的前提下，将事物的隔离级别改为RC，并且将binlog置为row。</p><h3 id="innodb对于数据加锁的原则"><a href="#innodb对于数据加锁的原则" class="headerlink" title="innodb对于数据加锁的原则"></a>innodb对于数据加锁的原则</h3><p>Q:锁是加在数据上还是加载索引中？<br>A:锁是加载索引中。（因为Mysql的数据是在磁盘中的，而索引是在内存中切有序的。所以按照mysql的能用内存用内存的原则是锁索引的）</p><ol><li>加锁的基本单位是next key lock；</li><li>查找到访问的对象会加锁；</li><li>对于查询等值唯一索引的数据加锁，会退化成行锁；</li><li>对于查询等值非唯一索引的数据加锁，当向右扫描到第一个不符合索引的数据时候，会退化成间隙锁；</li><li>注意：对于范围查找唯一索引，会访问到不满足条件的第一个值位置；</li></ol><p>所以准确的说，innodb在对数据加锁不是简单的为涉及到的数据加行锁，而是对要访问的数据加一个nextKeyLock，然后innodb在根据如上条件判断哪些数据加行锁，哪些数据不是行锁是间隙锁；（确定是查询范围锁的数据是x锁，中间不存在的数据间隙锁）</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>其他</title>
      <link href="mysql/%E5%85%B6%E4%BB%96/"/>
      <url>mysql/%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>查询长事物的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql更新数据的原理和流程-草稿</title>
      <link href="mysql/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%9B%B4%E6%96%B0/"/>
      <url>mysql/mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql更新数据的原理和流程-草稿"><a href="#mysql更新数据的原理和流程-草稿" class="headerlink" title="mysql更新数据的原理和流程-草稿"></a>mysql更新数据的原理和流程-草稿</h1><p>本文介绍mysql更新数据的原理和流程</p><h2 id="为什么mysql更新的效率很高？"><a href="#为什么mysql更新的效率很高？" class="headerlink" title="为什么mysql更新的效率很高？"></a>为什么mysql更新的效率很高？</h2><ol><li>WAL机制：即更新内存中数据页，同时写redolog+binglog然后返回。后台慢慢将数据页刷到磁盘中。（随机写改为顺序写）</li><li>mysql的chagenbuffer。</li></ol><h2 id="为什么mysql偶尔会抖一下"><a href="#为什么mysql偶尔会抖一下" class="headerlink" title="为什么mysql偶尔会抖一下"></a>为什么mysql偶尔会抖一下</h2><p>刷新脏页<br>什么叫脏页？<br>什么时候触发脏页的flush。</p><ol><li>redolog写满；（尽量避免，因为这时候所有更新都被block主）</li><li>内存不足：需要加载新的数据页但是内存不够，将数据页淘汰，如果是脏页，就flush到磁盘；（至于为什么不直接淘汰，下次读的时候从redologmerge是出于性能考虑，每次加载的都是干净的数据页）</li><li>正常的时候，定时刷新</li><li>正常关闭mysql时候</li></ol><p>2是抖一下的原因<br>buf1fpool数据页三种状态（未使用，使用了但是干净页，使用了但是脏页）。<br>当数据页没在内存中时候，申请一个页面，如果没有未使用页面就需要淘汰页面，俩种情况，如果淘汰的页面过多，会影响性能</p><ol><li>干净页直接淘汰</li><li><p>脏页flush，淘汰</p><p>fio -filename=$filename -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size=500M -numjobs=10 -runtime=10 -group_reporting -name=mytest</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断MySql的主从出现问题</title>
      <link href="mysql/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADmysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/"/>
      <url>mysql/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADmysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断MySql的主从出现问题"><a href="#如何判断MySql的主从出现问题" class="headerlink" title="如何判断MySql的主从出现问题"></a>如何判断MySql的主从出现问题</h1><p>本章主要介绍如何对MySql主从进行健康检查</p><h2 id="SELECT-1"><a href="#SELECT-1" class="headerlink" title="SELECT 1"></a>SELECT 1</h2><p>定期在数据库上执行“SELECT 1”,缺点是指能判断MySql的进程是否存在，不能判断实际的使用情况，因为Mysql的并发度往往受参数innodb_thread_concurrency影响：</p><blockquote><p>innodb_thread_concurrency代表数据库的并发度，即同一时间有多少线程并发执行任务；默认是0即无限制，但是为了防止CPU被打满我们往往设置64~1·28中的一个值；<br>注意一下俩点：</p><ul><li>innodb_thread_concurrency和最大连接数不一样，最大连接数只是保持了链接状态，并没有多消耗CPU资源；</li><li>当链接进入sleep状态的时候，innodb_thread_concurrency参数会减一，即释放一个并发度；</li></ul></blockquote><h2 id="查表"><a href="#查表" class="headerlink" title="查表"></a>查表</h2><p>我们可以在mysql中创建一个表比如讲heal_check，定期执行下面的语句：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from mysql.health_check;</span><br></pre></td></tr></table></figure><p>但是依然有个缺点，我们不能检查出MySql写的能力。</p><h2 id="定期执行修改的方式"><a href="#定期执行修改的方式" class="headerlink" title="定期执行修改的方式"></a>定期执行修改的方式</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update mysql.health_check set t_modified=now();</span><br></pre></td></tr></table></figure><p>缺点从库无法判断,我们可以修改下我们的语句用如下的方式定期轮训</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `health_check` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `t_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测命令 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql.health_check(<span class="keyword">id</span>, t_modified) <span class="keyword">values</span> (@@server_id, <span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> t_modified=<span class="keyword">now</span>();</span><br></pre></td></tr></table></figure><p>缺点，只能被动的轮询无法及时发现问题。</p><h2 id="内部统计–performance-schema库"><a href="#内部统计–performance-schema库" class="headerlink" title="内部统计–performance_schema库"></a>内部统计–performance_schema库</h2><p>我们可以利用performance_schema，注意如果打开会因为检测导致性能下降10%左右。</p><p>我们执行语句可以看到如下内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> performance_schema.file_summary_by_event_name <span class="keyword">where</span> event_name=<span class="string">'wait/io/file/innodb/innodb_log_file'</span>\G</span><br><span class="line"></span><br><span class="line">*************************** <span class="number">1.</span> <span class="keyword">row</span> ***************************</span><br><span class="line">               EVENT_NAME: <span class="keyword">wait</span>/io/<span class="keyword">file</span>/<span class="keyword">innodb</span>/innodb_log_file</span><br><span class="line">               COUNT_STAR: <span class="number">107</span>  <span class="comment">#IO总次数</span></span><br><span class="line">           SUM_TIMER_WAIT: <span class="number">101355337720</span> <span class="comment">#单位皮秒</span></span><br><span class="line">           MIN_TIMER_WAIT: <span class="number">498680</span></span><br><span class="line">           AVG_TIMER_WAIT: <span class="number">947245845</span></span><br><span class="line">           MAX_TIMER_WAIT: <span class="number">81456567920</span></span><br><span class="line">               COUNT_READ: <span class="number">7</span> <span class="comment">#读</span></span><br><span class="line">           SUM_TIMER_READ: <span class="number">1321141640</span></span><br><span class="line">           MIN_TIMER_READ: <span class="number">498680</span></span><br><span class="line">           AVG_TIMER_READ: <span class="number">188734455</span></span><br><span class="line">           MAX_TIMER_READ: <span class="number">790074740</span></span><br><span class="line"> SUM_NUMBER_OF_BYTES_READ: <span class="number">70144</span> <span class="comment">#字节</span></span><br><span class="line">              COUNT_WRITE: <span class="number">47</span> <span class="comment">#写</span></span><br><span class="line">          SUM_TIMER_WRITE: <span class="number">874801200</span></span><br><span class="line">          MIN_TIMER_WRITE: <span class="number">12836460</span></span><br><span class="line">          AVG_TIMER_WRITE: <span class="number">18612685</span></span><br><span class="line">          MAX_TIMER_WRITE: <span class="number">33429760</span></span><br><span class="line">SUM_NUMBER_OF_BYTES_WRITE: <span class="number">40960</span></span><br><span class="line">               COUNT_MISC: <span class="number">53</span> <span class="comment">#fsync次数--其他</span></span><br><span class="line">           SUM_TIMER_MISC: <span class="number">99159394880</span></span><br><span class="line">           MIN_TIMER_MISC: <span class="number">891800</span></span><br><span class="line">           AVG_TIMER_MISC: <span class="number">1870931790</span></span><br><span class="line">           MAX_TIMER_MISC: <span class="number">81456567920</span></span><br></pre></td></tr></table></figure><p>为了节省性能，我们可以只打开我们需要的统计项，执行如下命令，打开redolog和binlog的统计项</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update setup_instruments set ENABLED='YES', Timed='YES' where name like '%wait/io/file/innodb/innodb_log_file%';</span><br></pre></td></tr></table></figure><p>检测性能方式如下，比如监控binlog和redolog超过200ms时，即监控MAX_TIMER_WAIT值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select event_name,MAX_TIMER_WAIT  FROM performance_schema.file_summary_by_event_name where event_name in ('wait/io/file/innodb/innodb_log_file','wait/io/file/sql/binlog') and MAX_TIMER_WAIT&gt;200*1000000000;</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取异常信息时候可以清空表，继续累计</span></span><br><span class="line">mysql&gt; truncate table performance_schema.file_summary_by_event_name;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql的排序</title>
      <link href="mysql/mysql%E7%9A%84%E6%8E%92%E5%BA%8F/"/>
      <url>mysql/mysql%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql排序-order-by的原理"><a href="#mysql排序-order-by的原理" class="headerlink" title="mysql排序 order by的原理"></a>mysql排序 order by的原理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>下面的语句用按照姓名排序，我们看下执行计划，Extra有一段‘Using filesort’，说明Mysql用的用到了排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行计划</span></span><br><span class="line">1 SIMPLE t NULL ref city city 66 const 1 100.00 Using index condition; Using filesort</span><br></pre></td></tr></table></figure><h2 id="排序的过程"><a href="#排序的过程" class="headerlink" title="排序的过程"></a>排序的过程</h2><p>mysql在排序操作中会用到sort_buffer和临时文件，sort_buffer的大小由sort_buffer_size参数决定</p><ul><li>sort_buffer:是Mysql为排序操作开辟的一块内存空间，会将需要查询的字段以及排序字段放在内存空间中，进行排序操作。</li><li>临时文件：如果字段太多sort_buffer容量不够了会借用到临时文件进行存储，会将需要排序的文件分成N份，同时排序排序完成后在进行合并。</li></ul><h3 id="全字段排序"><a href="#全字段排序" class="headerlink" title="全字段排序"></a>全字段排序</h3><p>全字段排序需要的流程</p><ol><li>初始化sort_buffer,确定要放进去的字段</li><li>根据索引等条件取出满足条件的主键ID</li><li>回表查询出需要显示的字段，将需要的字段放到sort_buffer中，如果用到临时文件，加载到临时文件中</li><li>内存中排序</li><li>返回结果</li></ol><h3 id="rowid排序"><a href="#rowid排序" class="headerlink" title="rowid排序"></a>rowid排序</h3><p>如果Mysql判断单行占用的空间很大，会采用rowid方式进行排序,可以用如下方式进行设置。受max_length_for_sort_data指标来控制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> max_length_for_sort_data = <span class="number">16</span>;</span><br></pre></td></tr></table></figure><ol><li>初始化sort_buffer,确定排序字段和主键ID</li><li>根据索引等条件取出满足条件的主键ID</li><li>将需要排序和主键ID放到sort_buffer中，如果用到临时文件，加载到临时文件中</li><li>内存中排序，得到排好序的排序字段值–主键ID</li><li>回表查询数据</li><li>返回结果</li></ol><h3 id="全字段排序-vs-rowid-排序"><a href="#全字段排序-vs-rowid-排序" class="headerlink" title="全字段排序 vs rowid 排序"></a>全字段排序 vs rowid 排序</h3><p>rowid比全字段排序多了一次回表操作，理论上来说mysql能用内存尽量用内存，减少磁盘操作，所以理论上来说rowid排序性能会低于全字段排序</p><h3 id="如何优化排序"><a href="#如何优化排序" class="headerlink" title="如何优化排序"></a>如何优化排序</h3><p>使用索引：因为索引本身是有序的，合理利用索引，这样排序就可以用索引避免使用临时文件和sort_buffer进行排序。如例子中的语句可以创建（city,name）的索引，可以用执行计划看出来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建索引（city,name）注意顺序</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>  ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行计划</span></span><br><span class="line">1 SIMPLE t NULL ref idx idx 66 const 1 100.00 Using index condition</span><br></pre></td></tr></table></figure><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>判断排序语句是否用了临时文件，是那种排序方式的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 打开 optimizer_trace，只对本线程有效 */</span></span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">'enabled=on'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @a 保存 Innodb_rows_read 的初始值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @a <span class="keyword">from</span>  performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="keyword">select</span> city, <span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">'杭州'</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看 OPTIMIZER_TRACE 输出 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`information_schema`</span>.<span class="string">`OPTIMIZER_TRACE`</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">/* @b 保存 Innodb_rows_read 的当前值 */</span></span><br><span class="line"><span class="keyword">select</span> VARIABLE_VALUE <span class="keyword">into</span> @b <span class="keyword">from</span> performance_schema.session_status <span class="keyword">where</span> variable_name = <span class="string">'Innodb_rows_read'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 计算 Innodb_rows_read 差值 */</span></span><br><span class="line"><span class="keyword">select</span> @b-@a;</span><br></pre></td></tr></table></figure><p>如何判断排序类型</p><ol><li>SELECT * FROM <code>information_schema</code>.<code>OPTIMIZER_TRACE</code>\G，之后的json对象看filesort_summary段<ol><li>sort_mode是sort_key, rowid是全字段排序</li><li>sort_mode是sort_key, packed_additional_fields采用全字段排序</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            "filesort_summary": &#123;</span><br><span class="line">              "rows": 1001, <span class="comment">#取的字段</span></span><br><span class="line">              "examined_rows": 110501, <span class="comment">#扫描行数</span></span><br><span class="line">              "number_of_tmp_files": 0, <span class="comment">#历史文件个数</span></span><br><span class="line">              "sort_buffer_size": 17024,</span><br><span class="line">              "sort_mode": "&lt;sort_key, rowid&gt;"</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">#如果是rowid排序实际扫描行数是examined_rows+rows（因为回了一次表）</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql读写分离的坑</title>
      <link href="mysql/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
      <url>mysql/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E9%82%A3%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql读写分离的坑"><a href="#mysql读写分离的坑" class="headerlink" title="mysql读写分离的坑"></a>mysql读写分离的坑</h1><p>本章主要介绍mysql读写分离的架构，读写分离遇到的问题，以及解决方案。</p><h2 id="mysql读写分离结构介绍"><a href="#mysql读写分离结构介绍" class="headerlink" title="mysql读写分离结构介绍"></a>mysql读写分离结构介绍</h2><h3 id="直连架构"><a href="#直连架构" class="headerlink" title="直连架构"></a>直连架构</h3><p>见图：<br><img src="/images/mysql/mysql读写分离架构直连.png" alt="avator"></p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>见图：<br><img src="/images/mysql/mysql读写分离架构proxy.png" alt="avator"></p><p>小结：</p><ul><li>直连的架构，往往后端会有一个管理器（zookeeper）来管理所有的节点，动态的做主从切换，踢掉失联节点，和动态更新节点。</li><li>客户端链接proxy，业务往往只关注业务逻辑即可。<em>现在大多采用此方案</em></li></ul><h2 id="mysql读写分离架构遇到的挑战以及解决方案"><a href="#mysql读写分离架构遇到的挑战以及解决方案" class="headerlink" title="mysql读写分离架构遇到的挑战以及解决方案"></a>mysql读写分离架构遇到的挑战以及解决方案</h2><p>无论采用直连还是proxy架构都会遇到主从不同步的问题，这里我们叫过期读，我们该采用什么方式解决呢？</p><h3 id="强制走主库"><a href="#强制走主库" class="headerlink" title="强制走主库"></a>强制走主库</h3><p>业务方自己判断某些查询走主库某些查询走备库。比如：刚修改的数据立刻就获取的最新的数据从主库查询；数据分析等离线的情况走从库；</p><ul><li>优点：比较简单，由业务自己掌控，大部分情况都可以用此种方式解决；</li><li>缺点：可能会遇到所有查询都需要从主库查询的情况，这样一主多从的架构就失去了作用；</li></ul><h3 id="sleep方案"><a href="#sleep方案" class="headerlink" title="sleep方案"></a>sleep方案</h3><p>修改和插入数据时候等待一段时间，然后在从备库查询，例如：页面ajax提交了修改请求，页面直接返回结果，当下次刷新时候从从库取出数据；</p><ul><li>优点：业务方决定，比较简单，且可以利用一主多从</li><li>缺点：过期时间的不确定性，可能会导致数据一致性有问题</li></ul><h3 id="判断主备无延迟方案"><a href="#判断主备无延迟方案" class="headerlink" title="判断主备无延迟方案"></a>判断主备无延迟方案</h3><p>在sql语句执行前线判断主库和从库是否有延迟，没延迟读取从库，有延迟读取主库。</p><h4 id="判断seconds-behind-master参数"><a href="#判断seconds-behind-master参数" class="headerlink" title="判断seconds_behind_master参数"></a>判断seconds_behind_master参数</h4><p>当参数为0说明无延迟，可以从从库读取，但是时间不精确只能精确到秒</p><h4 id="通过位点来判断"><a href="#通过位点来判断" class="headerlink" title="通过位点来判断"></a>通过位点来判断</h4><p>从库通过show slave status命令取得如下俩对参数：Master_Log_File和Read_Master_Log_Pos，Relay_Master_Log_File和Exec_Master_Log_Pos，当这俩对参数相等说明主备无延迟，</p><h4 id="通过gtid来判断"><a href="#通过gtid来判断" class="headerlink" title="通过gtid来判断"></a>通过gtid来判断</h4><ul><li>Auto_Position=1 ，表示这对主备关系使用了GTID</li><li>Retrieved_Gtid_Set，表示备库收到的日志GTID_SET</li><li>Executed_Gtid_Set，表示备库执行完成的GTID_SET</li></ul><p>当着俩个集合相等说明主备无延迟</p><p>但是，这种方案有个缺点就是，备库判断的是自己的,relaylog和binlog的差异，但是如果这时候主库提交了个事物，备库还没有转成relaylog，备库会认为没有延迟，但是依然从备库差不到刚才主库刚提交的事务的数据，如下图：</p><p><img src="/images/mysql/判断主备无延迟方案badcase.png" alt="avator"></p><p>tx3事务的数据主库提交了，但是备库会看不到</p><h3 id="结合semi-sync方案"><a href="#结合semi-sync方案" class="headerlink" title="结合semi-sync方案"></a>结合semi-sync方案</h3><p>上图的问题，结合semi-sync（办同步）方案可解决，semi-sync原理是什么呢？</p><ol><li>开启semi-sync后，主库在提交时候后会发送binlog给备库</li><li>备库收到binlog以后，发给主库一个ack信号，说明已经收到</li><li>主库收到这个信号后才能给客户端返回事务已经提交</li></ol><p>这种方案会有如下俩个缺点：</p><ol><li>对于一主多从的结构，当一个从库发送ack信号给主库，主库会返回一个事务已经提交，这时候如果从其他从库查询还是有可能出现过期读；</li><li>如果数据库更新频繁，你会发现g</li><li>tid或者位点主从会一直不相等，这样就失去了从库读写分离的意义。</li></ol><h3 id="等主库位点（gtid）"><a href="#等主库位点（gtid）" class="headerlink" title="等主库位点（gtid）"></a>等主库位点（gtid）</h3><p>我们针对上面的痛点可以采用等主库位点或者gtid的方式来处理这种情况</p><h4 id="等主库位点"><a href="#等主库位点" class="headerlink" title="等主库位点"></a>等主库位点</h4><p>命令:select master_pos_wait(file, pos[, timeout]);</p><ul><li>该命令含义：返回从命令执行开始，经过timeout秒后，从库执行到file（binlog）的pos位置执行了多少个事物。</li><li>返回值含义:<ul><li>NULL:失联</li><li>-1：超时</li><li>0：执行即到了改位置。执行了0个事物</li><li>N：从库到这个位置执行了N个事物。</li></ul></li></ul><p>具体流程如图:<br><img src="/images/mysql/等主库位点case.png" alt="avator"></p><ol><li>tx1提交后，在master上执行show master status;获取主库的binlog和binlog_pos。</li><li>在从库上执行查询语句前，先执行select master_pos_wait(file, pos[, timeout]);</li><li>如果返回&gt;=0,slect在从库执行，否则主库执行</li></ol><h4 id="等GTID"><a href="#等GTID" class="headerlink" title="等GTID"></a>等GTID</h4><p>命令:select wait_for_executed_gtid_set(gtid_set, timeout);</p><ul><li>该命令含义：等待从库timeout秒后，执行的gtid_set包含了gtid_set</li><li>返回值含义:<ul><li>0：包含</li><li>1：超时</li></ul></li></ul><p>具体流程如图:<br><img src="/images/mysql/等主库gtidcase.png" alt="avator"></p><ol><li>tx1提交后，在master上执行show master status;获取主库的gtid_set。（5.7后可以通过函数直接获取该事务返回的gtid,具体见后面）</li><li>在从库上执行查询语句前，先执行select wait_for_executed_gtid_set(gtid_set, timeout);</li><li>如果返回0从库，1主库</li></ol><p>注：5.7之后获取事务提交后gtid的方法</p><blockquote><p>set session_track_gtids=OWN_GTID<br>执行事务并且提交<br>客户端通过函数：mysql_session_track_get_first <em>这个函数只针对客户端调用</em></p></blockquote><p>注：开启semi-sync<em>待完善</em></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shell的积累</title>
      <link href="shell%E7%9A%84%E7%A7%AF%E7%B4%AF/"/>
      <url>shell%E7%9A%84%E7%A7%AF%E7%B4%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="shell的积累"><a href="#shell的积累" class="headerlink" title="shell的积累"></a>shell的积累</h2><p>日常工作中linux的命令的积累</p><h2 id="删除N天的文件的命令-用于清理log"><a href="#删除N天的文件的命令-用于清理log" class="headerlink" title="删除N天的文件的命令-用于清理log"></a>删除N天的文件的命令-用于清理log</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -mtime +1 -name "*.log*" -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><h2 id="按天筛选log"><a href="#按天筛选log" class="headerlink" title="按天筛选log"></a>按天筛选log</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -n '/2018-10-15 16:55:00/,/2018-10-15 23:59:59/p' log_path |grep "condition"</span><br></pre></td></tr></table></figure><h2 id="合并redis，用于单机环境的redis导入"><a href="#合并redis，用于单机环境的redis导入" class="headerlink" title="合并redis，用于单机环境的redis导入"></a>合并redis，用于单机环境的redis导入</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">redis-cli -h srcIp -p 6379 -n 0 keys "*" | while read key</span><br><span class="line">do</span><br><span class="line">    redis-cli -h srcIp -p 6379 -n 0 --raw dump $key | perl -pe 'chomp if eof' | redis-cli -h dest -p 6379 -n 1 -x restore $key 0</span><br><span class="line">    echo "migrate key $key"</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 经验积累 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务隔离级别</title>
      <link href="mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>mysql/mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql事务的隔离级别以及实现原理"><a href="#mysql事务的隔离级别以及实现原理" class="headerlink" title="mysql事务的隔离级别以及实现原理"></a>mysql事务的隔离级别以及实现原理</h1><h2 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h2><p>启动事务的几种方式</p><ol><li>显式启动事务语句， begin 或 start transaction，提交是commit，回滚是rollback</li><li>set autocommit=0,每个CURD都会启动事务且需要手动commit/rollback。</li><li>在实际使用用，我们一般不采用2这种方式启动事务。</li></ol><p>如何查看mysql事务的隔离级别，下面说明事务的隔离级别是读提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'transaction_isolation'</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| Variable_name | Value |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br><span class="line"></span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------------------+----------------+</span></span><br></pre></td></tr></table></figure><h2 id="事务的几种隔离级别"><a href="#事务的几种隔离级别" class="headerlink" title="事务的几种隔离级别"></a>事务的几种隔离级别</h2><p>mysql的事务隔离级别分为：读未提交、读已提交（RC）、可重复读（RR）、串行，他们具体表现如下：</p><ul><li>读未提交：事务中每个查询语句都获取当前数据的最新值。</li><li>读已提交：事务中每个查询语句获取的都是其他事务提交后的相关数据的最新值，Oracle的默认事务隔离级别。</li><li>可重复读：Mysql的Innodb的默认事务隔离级别。</li><li>串行：每个事务需要一个一个的执行。</li></ul><h2 id="mysql事务隔离方式的实现方式（只讨论RC-和-RR）"><a href="#mysql事务隔离方式的实现方式（只讨论RC-和-RR）" class="headerlink" title="mysql事务隔离方式的实现方式（只讨论RC 和 RR）"></a>mysql事务隔离方式的实现方式（只讨论RC 和 RR）</h2><p>mysql的事务隔离实现机制采用的是一致性读视图（consistent read view）。即Mysql在事务启动时对整个数据库拍了一个快照。</p><ul><li>RR是在事务开始时候创建一致性视图</li><li>RC是在事务中的每条sql语句执行前执行</li></ul><p>具体的实现逻辑如下：</p><ol><li>Innodb对没个每个事务会分配一个transaction id,该ID是严格自增的ID。</li><li>Innodb中每行数据是有多版本的，每个版本的数据会包含一个row_txid。将修改成这个版本数据的transaction id赋值给row_txid。</li><li>这个版本不是物理存在的是虚拟的，即在一个事务中一旦发现该行数据不可见，则需要根据row_txid对象的事务+undolog找到可见的数据，具体见下面5。</li><li>当一个事务启动时候会，会维护一个数组，这个数组包含这个事务开始之后，这时候所有活跃的transaction id（所谓即未提交的事务）。数组的取值范围如下：低水位是当前事务中最小的transId，高水位数组中最大的transaction id+1；数组关系可见下图：</li><li>当这个事务去读数据时候，会有如下情况：<ol><li>判断如果这条数据row tx_id&lt;低水位，说明当前的数据在本事务创建前已经被提交过了，所以可见；</li><li>判断如果这条数据row tx_id&gt;高水位，说明当前的数据在本事务创建之后被提交过了，所以不可见，需要通过undolog找回之前的版本；</li><li>判断如果这条数据row tx_id在数组区间，如果row tx_id是数组范围内的值，说明事务未提交过，所以不可见；发只，说明该数据是已经被其他事务提交生成的，所以可见；</li></ol></li></ol><p><img src="/images/mysql/mysql_tx_array.png" alt="avatar"></p><p>上面的规则比较拗口，翻译过来就是：如果数据的版本是先于本事务开始前生成的可见，如果后于本事务开始前生成的本可见。</p><h2 id="mysql如何保证多个事务同时修改一条数据的准确性"><a href="#mysql如何保证多个事务同时修改一条数据的准确性" class="headerlink" title="mysql如何保证多个事务同时修改一条数据的准确性"></a>mysql如何保证多个事务同时修改一条数据的准确性</h2><p>思考下面问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为mysql在update时候实际上是先select在更新，所以在RR隔离级别中。</span><br><span class="line">俩个同时开始未提交的事务修改同一条语句这时候因为一致性视图，会不会导致一个事务的修改是无效的呢？</span><br></pre></td></tr></table></figure><p>答案是不会的。<br>因为mysql在修改时会遵循一个原则：读当前值，当更新数据时候都是先读后写，所以这时候值能读当前值。俩个事务同时更新一条数据的流程和原理如下：</p><ol><li>当并发进行更新时，对数据进行加x锁，后面的更新操作会block住，直到其他的事务提交后才继续下去；</li><li>由于更新是当前读，所以数据被本事务被更新过后，由于row tx_id就是当前事务，所以读到的值是新的值；</li></ol><h2 id="隔离级别RR如此那RC呢"><a href="#隔离级别RR如此那RC呢" class="headerlink" title="隔离级别RR如此那RC呢"></a>隔离级别RR如此那RC呢</h2><p>其实原理是一样的。只是RR是每一次事务开始时候创建一致性视图，而隔离级别RC则是在事务中每一条sql语句在执行前都要创建一个一致性视图，这样视图是动态的，每条sql语句根据上面提到的规则都要去确定数据的可见性。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据的完整性</title>
      <link href="mysql/mysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/"/>
      <url>mysql/mysql%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql的主从切换"><a href="#MySql的主从切换" class="headerlink" title="MySql的主从切换"></a>MySql的主从切换</h1><p>大部分业务数据库都是读多写少，我们在实际使用情况上往往会遇到读性能，本章主要讲述如何解决读延迟</p><h2 id="一主多从的架构"><a href="#一主多从的架构" class="headerlink" title="一主多从的架构"></a>一主多从的架构</h2><p>我们一般会采取一主多从架构，主库承担所有的写和一部分读的任务，丛库根据承担读的任务。</p><p>如图：<br><img src="/images/mysql/mysql一主多从架构.png" alt="avatar"></p><ol><li>A和A’互为主备</li><li>B、C、D是A的从库</li></ol><p>下面我们来通论下当主库A发生故障后，A’成为主库，BCD的主库也要都指向A’，下面我们来讨论下遇到这种情况，mysql是如何做主从切换的。<br>如图：<br><img src="/images/mysql/mysql一主多从故障.png" alt="avatar"></p><h3 id="基于位点的主备切换"><a href="#基于位点的主备切换" class="headerlink" title="基于位点的主备切换"></a>基于位点的主备切换</h3><p>当把B置为A’的从库时候要执行如下命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST=$host_name</span><br><span class="line">MASTER_PORT=$port</span><br><span class="line">MASTER_USER=$user_name</span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span></span><br><span class="line">MASTER_LOG_FILE=$master_log_name</span><br><span class="line">MASTER_LOG_POS=$master_log_pos</span><br></pre></td></tr></table></figure><ul><li>host_name、port、user_name、password主库的IP、端口、用于主从同步的数据库用户名、密码</li><li>master_log_name，和master_log_pos就是A’库binlog的文件名和位置成为位点；</li></ul><p>原来的B是A的从库，所以B中记录的是A的位点，在change master之后，B要将位点置为A’的位点，由于A和A’记录的位点不一样，所以要大概估算出一个靠前一点的位点，在忽略掉主从不同步的情况。为什么要靠前一点的主要是有下面这种情况，下面语句是分析mysqlbinlog找到位点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog File <span class="comment">--stop-datetime=T --start-datetime=T</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#比如这是看到了pos是123，我们B在chenagemaster时候可以往前一点比如110；</span></span><br></pre></td></tr></table></figure><blockquote><p>在A插入了一行R，同时同步给B和A’这时候A出现故障，B和A’都已经有了R行数据，如果这时候changemaster会提示主键冲突，停止同步。</p></blockquote><p>解决的方案：</p><ol><li>主动跳过1个事务,如下的命令，每次遇到这样的错误都跳过知道最后没有错误为止</li><li>通过设置slave_skip_errors参数，直接跳过指定错误，常见的错误如下，可以直接跳过“1062，1032”<ol><li>1062 错误是插入数据时唯一键冲突；</li><li>1032 错误是删除数据时找不到行。</li></ol></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> sql_slave_skip_counter=N;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><p>注意：前提是这俩种操作是对业务无损的。</p><h3 id="GTID–-since-v5-6"><a href="#GTID–-since-v5-6" class="headerlink" title="GTID– since v5.6"></a>GTID– since v5.6</h3><p>基于位面做主从切换比较复杂且很容易出错，所以mysql在5.6后引入了gtid彻底解决了这个问题。</p><p>GTID全程是Global Transaction Identifier,即全局事物ID，即一个事物提交后生成的全局唯一ID，他有俩个部分组成</p><blockquote><p>GTID=server_uuid:gno（官方定义：GTID=source_id:transaction_id）<br>其中：</p></blockquote><ol><li>server_uuid是mysql的实例ID</li><li>gno是一个递增的整数，</li></ol><p>如何启动gtid呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br></pre></td></tr></table></figure><p>下图就是我在主库上执行了一条插入看到的binlog,其中SET @@SESSION.GTID_NEXT= ‘b01b34d1-25cf-11e9-8e68-9ec1c2413262:1’就是这条事物的GTID</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show binlog events IN 'mysql-bin.000028';</span><br><span class="line">+<span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span></span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                                              |</span><br><span class="line">+<span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span></span><br><span class="line">| mysql-bin.000028 |   4 | Format_desc    |         1 |         123 | Server ver: 5.7.25-log, Binlog ver: 4                             |</span><br><span class="line">| mysql-bin.000028 | 123 | Previous_gtids |         1 |         154 |                                                                   |</span><br><span class="line">| mysql-bin.000028 | 154 | Gtid           |         1 |         219 | <span class="keyword">SET</span> @@SESSION.GTID_NEXT= <span class="string">'b01b34d1-25cf-11e9-8e68-9ec1c2413262:1'</span> |</span><br><span class="line">| mysql-<span class="keyword">bin</span><span class="number">.000028</span> | <span class="number">219</span> | <span class="keyword">Query</span>          |         <span class="number">1</span> |         <span class="number">293</span> | <span class="keyword">BEGIN</span>                                                             |</span><br><span class="line">| mysql-<span class="keyword">bin</span><span class="number">.000028</span> | <span class="number">293</span> | Table_map      |         <span class="number">1</span> |         <span class="number">340</span> | table_id: <span class="number">108</span> (liuhao.t)                                          |</span><br><span class="line">| mysql-<span class="keyword">bin</span><span class="number">.000028</span> | <span class="number">340</span> | Write_rows     |         <span class="number">1</span> |         <span class="number">384</span> | table_id: <span class="number">108</span> flags: STMT_END_F                                   |</span><br><span class="line">| mysql-<span class="keyword">bin</span><span class="number">.000028</span> | <span class="number">384</span> | Xid            |         <span class="number">1</span> |         <span class="number">415</span> | <span class="keyword">COMMIT</span> <span class="comment">/* xid=23 */</span>                                               |</span><br><span class="line">+<span class="comment">------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>gtid的分配方式:</p><ol><li>当gtid_next=automatic时候，代表使用默认值:<ol><li>记录binlog时候先记录一行SET @@SESSION.GTID_NEXT=</li><li>把这个gtid加入到本地实例的gtid集合中（Executed_Gtid_set）</li></ol></li><li>如果gtid_next=是一个指定的gtid值时候，比如通过set gtid_next=’current_gtid’指定为当前的current_gtid时候，<ol><li>如果current_gtid已经存在于gtid集合，接下来执行这个事务会跳过这个事务；</li><li>如果current_gtid不存在于gtid这个集合中，将这个current_gtid分配给新的事务，说明系统不需要分配新的gtid,gno也不需要加1</li></ol></li></ol><p>gtid的使用方法</p><p>加入一个库X是有一条数据（1,1),他的的gtid=aaaaaaaa-cccc-dddd-eeee-0000000000000:1<br>同时X作为了Y的从库，Y写入了一条数据（1,1）,他的gtid=aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10</p><p>我们在X上执行如下的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将X的gtid_next置为Y库的aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10</span></span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="string">'aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10'</span>;</span><br><span class="line"><span class="comment">#提交一个空事物，把“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:10”这个gtid置为X的Executed_Gtid_set中，遇到冲突可以跳过</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">#置gtid_next为automatic,下一个事物就变为了“aaaaaaaa-cccc-dddd-eeee-ffffffffffff:11”</span></span><br><span class="line"><span class="keyword">set</span> gtid_next=<span class="keyword">automatic</span>;</span><br><span class="line"><span class="comment">#开启从库</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure><h4 id="基于GTID的主备切换"><a href="#基于GTID的主备切换" class="headerlink" title="基于GTID的主备切换"></a>基于GTID的主备切换</h4><p>执行如下命令注意,master_auto_position表示的这个主备关系支持GTID协议，我们之前的MASTER_LOG_FILE和MASTER_LOG_POS已经不需要指定了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">MASTER_HOST=$host_name</span><br><span class="line">MASTER_PORT=$port</span><br><span class="line">MASTER_USER=$user_name</span><br><span class="line">MASTER_PASSWORD=$<span class="keyword">password</span></span><br><span class="line">master_auto_position=<span class="number">1</span></span><br></pre></td></tr></table></figure><p>B通过CHANGE MASTER变为A’的从库，B的gtid_set为set_b，A的gtid_set为set_a，在start slave时候逻辑如下：</p><ol><li>A和B建立主备关系;</li><li>B把set_b发个A’;</li><li>A’计算set_a和set_b的差集，差集说明是B需要执行的binlog,同时判断A是否包含了这些binlog<ol><li>不包含，直接报错，说明A已经把这些BINLOG删除了</li><li>如果全部包含，A’从自己的binlog里找出第一个差集中的binlog开始同步</li></ol></li><li>之后从这个事务开始一直往B同步</li></ol><p>这种方式，由之前通过位点同步的，由从库来决定从哪里同步，到主库通过获取从库的gtid来计算出从哪里开始同步。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Schedule多线程</title>
      <link href="spring/spring-scheduled/"/>
      <url>spring/spring-scheduled/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring多线程执行任务"><a href="#Spring多线程执行任务" class="headerlink" title="Spring多线程执行任务"></a>Spring多线程执行任务</h1><p>用Spring执行定时任务，spring默认是单线程执行的也就是说，多个任务会存在等待阻塞情况</p><h2 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h2><p>用如下方法注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfigure</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设定一个长度10的定时任务线程池</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql数据的完整性--草稿</title>
      <link href="mysql/mysql%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-%E9%87%8A%E6%94%BE%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
      <url>mysql/mysql%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-%E9%87%8A%E6%94%BE%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql的数据删除的原理"><a href="#mysql的数据删除的原理" class="headerlink" title="mysql的数据删除的原理"></a>mysql的数据删除的原理</h1><p>我的数据删除了为什么表还是这么大？</p><h2 id="mysql删除数据的原理"><a href="#mysql删除数据的原理" class="headerlink" title="mysql删除数据的原理"></a>mysql删除数据的原理</h2><p>  mysql采用标记删除法，即并不是物理删除而是采用标记删除。<br>  delete数据时候：数据标记为可服用，如果插入的数据在这个数据页，可复用这个空间，例如：索引页的范围内可复用，超过了则需要插入新的空间。<br>  delete整个数据页：如果数据页上所有数据被删除，则整个数据页可复用。</p><h2 id="数据页的分裂和合并"><a href="#数据页的分裂和合并" class="headerlink" title="数据页的分裂和合并"></a>数据页的分裂和合并</h2><p>  如果数据页利用率小，数据页会合并。<br>  如果数据页满了，中间插入会导致数据页分裂。</p><h2 id="释放表空间"><a href="#释放表空间" class="headerlink" title="释放表空间"></a>释放表空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE t ENGINE=innodb;</span><br></pre></td></tr></table></figure><p>在mysql5.5会有MDL锁，不能Online执行</p><p>在mysql5.6会有online ddl机制，但是会小号CPU和IO（因为扫表），大表请谨慎。</p><p>这两种区别<br>5.5是在server层,copy出tmp_table，这时候不能对原表进行操作，然后copy到老表中。<br>5.6是在innodb层,copy出tmp_file,改的写row_log,然后重放生成逻辑一直的新表，tmp_file inplace操作到老表中。（tmp_file是个inplace操作）</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql是怎么保证高可用的</title>
      <link href="mysql/mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/"/>
      <url>mysql/mysql%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql是怎么保证高可用的–如何解决主备延迟"><a href="#mysql是怎么保证高可用的–如何解决主备延迟" class="headerlink" title="mysql是怎么保证高可用的–如何解决主备延迟"></a>mysql是怎么保证高可用的–如何解决主备延迟</h1><p>mysql的主从同步会保证主库到从库的最终一致性，但是mysql的高可用，光有最终一致性是远远不够的。下面会讨论影响mysql主备高可用的因素以及解决方法。</p><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><ul><li>我们在备库上可以执行命令：seconds_behind_master来查看备库的状态，会显示备库同步数据和主库的时间差（单位：秒），这个时间差计算方式是：同一事物，备库执行完binlog的时间-主库产生binlog的时间备库执行的binlog的时间，当然这个值越小越好。</li><li>在网络正常的情况下，主备同步binlog的时间往往很短，真正造成主备延迟的原因往往是relylog的消费赶不上binlog的生产。那么是什么造成主备延迟的呢</li></ul><h3 id="主备延迟的原因"><a href="#主备延迟的原因" class="headerlink" title="主备延迟的原因"></a>主备延迟的原因</h3><ol><li>主备库，备库的性能要不主库所在的的机器性能差；–目前很少见了，因为大多是双M配置，所以备库可能会变为主，所以在部署时候都会选择对称部署；</li><li>备库压力大，备库上很多的查询需求，比如备份数据，运营统计等会放在备库执行。在同步binlog时候往往也会占用查询的资源，导致备库的眼里很大，引起主备延迟</li><li>大事物，由于mysql是在主库上事物提交之后才开始传输binlog给备库，这样如果1个很大的事物在主库执行N长时间后，在同步给备库，备库在执行这个事物时候就会造成主从不一致。<ol><li>一次删除很多的数据，如：数据库快满了删除数据；</li><li>大表的DDL</li></ol></li><li>库的并行复制能力,具体放在<a href="./mysql是如何降低主备延迟的.html">mysql是如何降低主备延迟的</a></li></ol><h3 id="主备延迟的解决方案"><a href="#主备延迟的解决方案" class="headerlink" title="主备延迟的解决方案"></a>主备延迟的解决方案</h3><ol><li>首先对于双M架构，主备库建议对称部署，保证切换朱备库时候性能没有打的差别</li><li>建议根据需要一主多从，比如说：一个主备做为切换，一个从库作为数据备份，一个从库作为数据分析以及运营支持；</li><li>根本上杜绝大事物，对于删除可以考虑分批删除数据；DDL可以采用开源的工具进行入：gh-ost方案</li></ol><h2 id="主备切换的几种策略"><a href="#主备切换的几种策略" class="headerlink" title="主备切换的几种策略"></a>主备切换的几种策略</h2><h3 id="可靠性优先"><a href="#可靠性优先" class="headerlink" title="可靠性优先"></a>可靠性优先</h3><p>该策略可能会有一段时间服务不可用，流程如下：</p><ol><li>判断备库的seconds_behind_master的值，当相于一个值的时候进行第二步，否则一直重试；</li><li>主库设置readonly=true，即只读；</li><li>备库等待seconds_behind_master=0为止；</li><li>备库设置readonly=fase，即可写；</li><li>切换业务到备库；</li></ol><p>注：第一步的作用实际上是希望主库和从库的延时在小于一个阈值时候开始做切换，否则如果相差30分钟，直接切换，那么服务就会有30分钟不可用，业务方一般是不可忍受的。（当然。。。。某些时候我也作为业务方我也就忍了）</p><h3 id="可用性优先"><a href="#可用性优先" class="headerlink" title="可用性优先"></a>可用性优先</h3><p>和上面相比，保证业务的可用，但是会牺牲掉数据的一致性</p><ol><li>备库设置readonly=fase，即可写；</li><li>切换业务到备库；</li><li>主库设置eadonly=true</li></ol><p>注：在下面的情况会导致数据不一致，原因如下：（老的主库是A,备库是B）</p><ol><li>A插入了数据c(4)，还没有同步到B时候进行切换</li><li>这时候B变为主，B库插入数据c(5)，这条数据是（4，5）</li><li>然后B从A通过relylog重放数据是c(4)那条数据，这时候B库中(5，4)</li><li>A库通过重放relylog获取刚才c(5)的数据，这时候数据是（5，5）</li></ol><p><img src="/images/mysql/主备_高可用性切换_数据不一致.png" alt="avatar"></p><p>总结，Mysql作为数据的存储，还是应该优先保证数据的一致性，所以建议采用可靠性优先方案保证数据的一致性。否则，对于一些依赖写入的业务，可能因为在切换主备时候数据不一致引起逻辑的错误，而且由于往往写入不是一个单一的操作，这一次的不一致会导致后续的引发更多的问题，最终导致数据无法修复。</p><p>其他的好的建议：如果业务不依赖mysql的写入可以针对写入进行降级，比如：让数据先写到临时文件中，然后切换后慢慢的同步到mysql中。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ByteBuf</title>
      <link href="netty/ByteBuf/"/>
      <url>netty/ByteBuf/</url>
      
        <content type="html"><![CDATA[<h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><p>介绍Netty中的ByteBuf</p><h2 id="byteBuf种类"><a href="#byteBuf种类" class="headerlink" title="byteBuf种类"></a>byteBuf种类</h2><p>netty中的byteBuf除了JDK中的heapBuffer和directBuffer还有compositeBuffer类型</p><p>传统的Java的nio操作都是ByteBuffer.allocate(int capacity)实际上是神了一个HeapBuffer。当通过Socket传输对象时候我们实际上是申请了一块临时的DirectBuffer（堆外内存），将数据copy到DirectBuffer,在write出去。所以HeapBuffer传输数据会有数据copy,DirectBuffer没有数据copy。但是申请和管理DirectBuffer会更复杂更慢。</p><h3 id="Heap-Buffer-堆缓冲区"><a href="#Heap-Buffer-堆缓冲区" class="headerlink" title="Heap Buffer 堆缓冲区"></a>Heap Buffer 堆缓冲区</h3><p>ByteBuf将数据存储在JVM的堆空间，通过将数据存储在数组中实现的。<br>  优点是：由于数据存储在JVM的堆中可以快速创建和快速释放，并且提供了数组的直接快速访问的方法。<br>  缺点是：每次读写数据都要先将数据拷贝到直接缓冲区再进行传递。</p><h3 id="Direct-Buffer-直接缓冲区"><a href="#Direct-Buffer-直接缓冲区" class="headerlink" title="Direct Buffer 直接缓冲区"></a>Direct Buffer 直接缓冲区</h3><p>在堆之外直接分配内存，直接缓冲区不会占用堆的容量。<br>  优点是：在使用Socket传递数据时性能很好，由于数据直接在内存中，不存在从JVM拷贝数据到直接缓冲区的过程，性能好。<br>  缺点是：因为Direct Buffer是直接在内存中，所以分配内存空间和释放内存比堆缓冲区更复杂和慢</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql是如何保证数据不丢失的</title>
      <link href="mysql/mysql%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/"/>
      <url>mysql/mysql%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql是如何保证数据不丢失的"><a href="#Mysql是如何保证数据不丢失的" class="headerlink" title="Mysql是如何保证数据不丢失的"></a>Mysql是如何保证数据不丢失的</h1><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><ol><li>事务执行过程中binlog写入到binlog cache,事务提交时写入到binlog文件中。</li><li>事务的原子性决定这无论事务有多大，binlogcahe都要一次性完整的写入到binlog文件中，写入方式如下：<ol><li>系统为每个binlog_cache开辟了一片内存（每个线程都有一个），参数是blong_cache_size,超过这个阈值的会保存在临时文件中</li><li>事务提交时候，出于性能的考虑回将bionlog_cache都write到文件系统的page_cache中，在通过fsync刷新到磁盘文件中。如下图所示是binlog的同步机制。</li></ol></li></ol><p>如图：<br><img src="/images/mysql/binglog_写入.png" alt="avatar"></p><ul><li>只有fsnyc刷盘这不操作才会占用IOPS。</li><li>write和fsync的时机是用binglog_sync参数来控制的<ul><li>=0 每次事务提交时候都只write不sync</li><li>=1 每次事务提交都sync</li><li>=N（N&gt;1） 每次事务提交都write，积攒到N时候才会fsync</li></ul></li></ul><p>在IO出现瓶颈时候我们可以设置一个较大的值来提升性能（个人不是很推荐做，如果出现这种情况建议从业务考虑优化数据库）</p><h2 id="redolog的写入机制"><a href="#redolog的写入机制" class="headerlink" title="redolog的写入机制"></a>redolog的写入机制</h2><p>redolog从写入到最终写入到磁盘中会经历如下的阶段：写入redolog-buffer中–&gt;在事务提交、或者一定时机（见下面）下：redolog-buffer写入到文件系统的pagecache(write)–&gt;文件系统pagecache写入到磁盘中(fsnyc)，这样的操作的意义是为了提高mysql的吞吐的，具体的机制见下面：</p><p><img src="/images/mysql/redolog_3种状态.png" alt="avatar"></p><ol><li>一个事务会产生很多条redolog如果每次直接持久化磁盘会消耗大量的磁盘IO，所以redolog会先写入redolog-buffer中，之后在write文件系统的到pagecache中，这俩步是内存操作很快。</li><li>是否会影响数据的持久化，比如mysql在事务进行中crash了，这时候redolog-buffer中的数据丢失怎么办？答案是由于事物没有提交，所以事物会进行回滚。</li><li>redolog-buffer持久化的条件和机制：<ol><li>受参数innodb_flush_log_at_tx_commit的控制：<ol><li>=0：每次提交都只停留在redolog-buffer中；</li><li>=1：每次提交都会持久化到磁盘中；</li><li>=2：每次提交都只会写入到文件的pagecache中；</li></ol></li><li>innodb后台会有一个线程每秒一次，会把redolog-buffer中的日志，调用write写到pagecahe中，在fsync到磁盘中；</li><li>其他场景触发redolog的持久化<ol><li>当redolog-buffer占到了innodb_log_buffer_size的一半时候，会调用write将buffer中的log写入到文件系统的pagecache中</li><li>另一种是并行事物提交时候，如果innodb_flush_log_at_tx_commit设置为1时候会，即时当前事物没有commit，也会将redolog写入到文件系统中。</li></ol></li></ol></li></ol><h3 id="双1设置"><a href="#双1设置" class="headerlink" title="双1设置"></a>双1设置</h3><p>即：binlogsnyc=1，innodb_flush_log_at_tx_commit也设置为1。<br>  由于innodb的事物提交redolog和binlog是2PC。<br>     所以当redolog在prepare时候，为了故障恢复一定会持久化一次，所以这时候需要fsync到磁盘中。<br>     binlog在进行fsync到磁盘中<br>     这时候事物在redolog在commit时候，mysql由于有奔溃恢复机制和后台线程每秒轮训一次刷盘会认为redolog没有必要在fsync一次到磁盘了，只会写入到文件的pagecache中。</p><h3 id="gourp-commit机制"><a href="#gourp-commit机制" class="headerlink" title="gourp commit机制"></a>gourp commit机制</h3><p>一个事物的提交由于redolog和binglog都要持久化，磁盘IO还是很大Mysql是如何优化这部分呢。这里mysql采用了组提交（group commit）的方式。<br>如图所示：<br><img src="/images/mysql/group_commit机制.png" alt="avatar"></p><ul><li>首先介绍下LSN(log sequence number)，一个单调递增的序号，用来对应redolog的一个个写入点。当然也会写入到数据页中，用于flush脏盘时候避免重复执行（不在讨论范围内）</li><li>如图，当3个事务同时都写完redolog-buffer 并且处于prepare阶段时候，这时候就构成了一个gourp<ol><li>第一个先到达的trx1，成为组里的leader，LSN=50;</li><li>等trx1开始写盘时候，组里已经有其他俩个事物，这时候LSN=160;</li><li>trx1开始写盘，所有lsn&lt;160的日志都会被写入到磁盘中；</li><li>trx3,trx4就可以直接返回了；</li></ol></li></ul><p>所以在并发事物中，当写完redolog，越晚调用fsync，带的log越多性能也就越好；mysql在这方法采用的是拖时间的策略，即:在双1配置下<br>  redolog-prepare(write)–&gt;binglog(write)–&gt;redolog-prepare(fsync)–&gt;binlog(fsnyc)–&gt;redolog commit(write)</p><p>如图：<br><img src="/images/mysql/redolog_binlog_groupcommit.png" alt="avatar"></p><ul><li>如上图所示，由于redolog在write和fsnyc中有一个binlog-write的过程，所以在持久化磁盘时候你可以带上更多的log；</li><li>另外：binlog也可以采用组提交，只不过由于这俩个阶段间隔短可能没有redolog那么明显<ul><li>binlog的gruop commit的参数如下：<ul><li>binlog_group_commit_sync_delay:表示延迟多少微妙后就会调用fsnyc</li><li>binlog_gourp_commit_sync_no_delay_count:表示累计多少次后才调用fsync</li><li>俩个参数是or的关系，不过如果binlog_group_commit_sync_delay设置为0，binlog_gourp_commit_sync_no_delay_count就无效了</li></ul></li></ul></li></ul><p>综上所述：</p><ul><li>mysql的WAL机制是由于redolog和binlog都是顺序写，保证了高吞吐；</li><li>同时采用了组提交的方式，来减少了IOPS;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySql是如何降低主备延迟的</title>
      <link href="mysql/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E7%9A%84/"/>
      <url>mysql/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E4%B8%BB%E5%A4%87%E5%BB%B6%E8%BF%9F%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="MySql是如何降低主备延迟的"><a href="#MySql是如何降低主备延迟的" class="headerlink" title="MySql是如何降低主备延迟的"></a>MySql是如何降低主备延迟的</h1><p>上一章<a href="./mysql是怎么保证高可用的.html">MySQL是怎么保证高可用的</a>，中提到了主库的并行复制能力会影响主备的延迟。在mysql5.6之前，rely_log被sql_thread重放写入备库，这里的sql_thread只能单线程消费，所以会很大程度降低mysql数据库的吞吐，在TPS高的时候就会有很大的延迟。如果想增强吞吐就要多sql_thread并行处理relay_log，如图：</p><p><img src="/images/mysql/mysql_多sqlthread.png" alt="avatar"></p><p>但是mysql并行的主从并行复制要遵守如下原则：</p><ol><li>对于不同的事务的binlog如果修改同一行数据，为了避免相互覆盖，不能并行运行只能串行</li><li>对于相同事务的binlog，为了保证事务的完整性，不能并行复制，</li></ol><h2 id="5-5之前的主从复制策略"><a href="#5-5之前的主从复制策略" class="headerlink" title="5.5之前的主从复制策略"></a>5.5之前的主从复制策略</h2><p>在5.5的时候，为了增强mysql的从库消费relay_log的吞吐，使用者自己实现了主从复制的策略主要有俩种：</p><h3 id="按表并行复制"><a href="#按表并行复制" class="headerlink" title="按表并行复制"></a>按表并行复制</h3><ul><li>每个work维护一个hash_table，key是binlog的dbname+tablename；</li><li>当一个binlog分配给coordainator，coordainator会循环检查这个binlog的key(dbname+tablename)，是否在work的hash_table中，如果出现说明这个binlog和这个worker冲突；<ul><li>如果只有一个冲突，交给这个work处理；</li><li>如果大于一个冲突，coordainator进入等待；</li><li>如果没有冲突，交给空闲的worker处理；</li></ul></li><li>当worker处理完后会把key从hash_table中删掉；</li></ul><h3 id="按行并行复制"><a href="#按行并行复制" class="headerlink" title="按行并行复制"></a>按行并行复制</h3><p>和上面类似，只不过这次并行控制的粒度更细，只要保证binlog不是修改的同一行数据即可并行复制，那么hash_table的key就变为binlog的dbname+table+唯一健的值（主键+唯一索引），光有主键不够一定要带上唯一索引的值，否则如下情况会报唯一建冲突。</p><p>注：c=原有的值是1,当备库并行复制时候先执行sessionB,由于这时候sessionA还没执行，会报唯一建冲突<br>| sessionA | sessionB |<br>| —— | —— |<br>| update t set c=5 where id=1 ; | - |<br>| - | update t set c=1 where id=1; |</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>必须要能通过解析binlog获取dbname,tablename,pk,uniqekey，所以binlog要是row类型；</li><li>必须有主键；</li><li>不能有外键；(因为外键的级联更新不在binlog中，所以建冲突就不准确)</li><li>按表的策略：在对热点表的时候coordainator会频繁进入等待，又变成了单线程复制；</li><li>按行的策略：要计算hashtable的key需要额外解析pk和uniquekey所以需要额外的开销；</li></ol><h2 id="Mysql5-6的并行复制策略"><a href="#Mysql5-6的并行复制策略" class="headerlink" title="Mysql5.6的并行复制策略"></a>Mysql5.6的并行复制策略</h2><h3 id="按照库名并行复制"><a href="#按照库名并行复制" class="headerlink" title="按照库名并行复制"></a>按照库名并行复制</h3><p>优点：</p><ol><li>构造hash很快，只需要库名；</li><li>binlog即使不是row也能很方便获取库名；</li></ol><p>缺点：</p><ol><li>若果服务器上只有一个库，优化效果不明显；</li></ol><h2 id="MariaDB的并行复制策略"><a href="#MariaDB的并行复制策略" class="headerlink" title="MariaDB的并行复制策略"></a>MariaDB的并行复制策略</h2><p>它的思想是思想是模拟主库运行：利用group commit,每一组事务能同时提交一定是不冲突的；那么主库commit之后就将一组的binlog一起并行执行</p><ul><li>为每个group commit分配个递增的commit_id；</li><li>将commit_id写入到binlog中</li><li>同一个commit_id的binglog分到不同的worker上去。</li><li>执行完这个commit_id后在执行下一个commit_id的binlog。</li></ul><p>缺点：</p><ol><li>并不是真正的象主库并行，主库当一组事物在commit阶段时候，下一组事物是在运行中的。而从库消费的时候只能是一组一组的消费，所以还是会造成主备的延迟。</li><li>当一组有一个很大的事物在worker中运行时候看，其他的worker先运行完了也只能等在哪里。</li></ol><h2 id="MySql5-7的并行复制的策略"><a href="#MySql5-7的并行复制的策略" class="headerlink" title="MySql5.7的并行复制的策略"></a>MySql5.7的并行复制的策略</h2><p>采用类似的MariaDb的类似的赋值策略由slave-parallel-type参数控制：</p><ul><li>DATABASE时候采用类似5.6的并行复制策略</li><li>LOGICAL_CLOCK时候采用MariaDb的并行复制策略，但是做了优化；</li></ul><p>和MariaDb相比，将binlog的执行时期从commit阶段放到了2PC的redolog的prepare阶段，mysql认为事物进入prepare阶段就说明数据是可靠的可以进行主从复制了。</p><ul><li>同时处于 prepare 状态的事务，在备库执行时是可以并行的</li><li>处于 prepare 状态的事务，与处于 commit 状态之间，在备库执行时也是可以并行的。</li></ul><p>我们可以通过binlog_group_commit_sync_delay和binlog_group_commit_sync_no_delay参数故意拉长主库的binlog从write到fsync的时间，减少binlog的写盘次数，制造更多同时在prepare时期的binlog，加大并行度。</p><h3 id="MySql5-7-22的并行复制优化"><a href="#MySql5-7-22的并行复制优化" class="headerlink" title="MySql5.7.22的并行复制优化"></a>MySql5.7.22的并行复制优化</h3><p>增加参数binlog-transaction-dependency-tracking。</p><ol><li>COMMIT_ORDER:和上面说的策略一样；但是如果是追历史数据还是会退化成单线程，所以适合线上库。</li><li>WRITESET：对于事务更新的每一行计算hash值，组成集合writeset，如果俩个事务没有操作相同的行，也就是writeset没有交集，就可以并行。</li><li>WRITESET_SESSION：多了一个约束，即在主库上同一个线程先后执行的事务，在从库上也要保证同样的顺序。</li></ol><p>和之前5.5的按行并行复制策略很类似但是有几点优化：</p><ol><li>hash值提前算好了，减少了主从同步时候的压力；</li><li>不需要在从库每次都把所有woker遍历一遍找出是否冲突；</li><li>备库不用解析binlog对备库的binlog格式无要求；</li></ol><p>思考如下：<br>假设一个 MySQL 5.7.22 版本的主库，单线程插入了很多数据，3小时候，搭建从库开始同步数据binlog-transaction-dependency-tracking改如何设置？<br>答：建议采用 WRITESET，因为是单线程插入，如果采用WRITESET_SESSION，那么会退化成单线程同步relaylog。COMMIT_ORDER因为是追历史数据，所以会退化成单线程</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise 和 Future</title>
      <link href="netty/Promise%E5%92%8CFuture/"/>
      <url>netty/Promise%E5%92%8CFuture/</url>
      
        <content type="html"><![CDATA[<h1 id="Promise-和-Future"><a href="#Promise-和-Future" class="headerlink" title="Promise 和 Future"></a>Promise 和 Future</h1><p>netty中的I/O操作大部分为异步，netty在Java的Future的基础上封装了Future和Promise</p><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>继承java.util.concurrent.Future接口，并且在Future基础上做了如下的强化。<br>future是read-only的。我们没有办法在Future中改变状态，只能获取状态。进行后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断I/O是否成功,和Future的isDone()相比,能得到是否真正完成的结果（有可能成功、失败、取消）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否已经中断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法表示如果I/O操作失败，返回异常信息</span></span><br><span class="line"><span class="comment">     * Returns the cause of the failed I/O operation if the I/O operation has</span></span><br><span class="line"><span class="comment">     * failed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the cause of the failure.</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> null&#125; if succeeded or this future is not</span></span><br><span class="line"><span class="comment">     *         completed yet.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Throwable <span class="title">cause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用观察者模式对future操作进行更精准的管理调用，如果get(),需要在代码中显示的调用在完成后续操作，如果用Listerner可以通过noify完成后续操作。</span></span><br><span class="line"><span class="comment">     * Adds the specified listener to this future.  The</span></span><br><span class="line"><span class="comment">     * specified listener is notified when this future is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> #isDone() done&#125;.  If this future is already</span></span><br><span class="line"><span class="comment">     * completed, the specified listener is notified immediately.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Future&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><p>ChannelFuture可以通过添加ChannelFutureListener监听器，当I/O操作完成的时候来通知调用。相比于wait()方式也更推荐这种方式来获取结果状态或者执行后续操作。<br>此外，不建议在ChannelHandler中调用await（），因为ChannelHandler中事件驱动的方法被一个I/O线程调用，可能一直不回完成，那么await（）也可能被I/O线程调用，同样会一直block，因此会产生死锁。<br>另外在，在Future的基础上增加了获取channle的方法</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>对比Future，Promise是writeable的，可以修改状态，调用noify执行Future(Promis)的listerner方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Promise</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一下是定义了标记了Future状态的方法，有且只能标记一次，</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span></span>;</span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryFailure</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setUncancellable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">removeListeners</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt;... listeners)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Promise&lt;V&gt; <span class="title">syncUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultPromise"><a href="#DefaultPromise" class="headerlink" title="DefaultPromise"></a>DefaultPromise</h2><p>在DefaultChannelPromise中会，改变状态会通知listerner</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</span><br><span class="line">        <span class="comment">//todo notify</span></span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListeners</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">       ...</span><br><span class="line">                notifyListenersNow();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            notifyListenersNow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyListenersNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listeners <span class="keyword">instanceof</span> DefaultFutureListeners) &#123;</span><br><span class="line">            notifyListeners0((DefaultFutureListeners) listeners);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            notifyListener0(<span class="keyword">this</span>, (GenericFutureListener&lt;?&gt;) listeners);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eg:在register过程中<br>AbstactServerBootstrap.initAndRegister<br>    –&gt;register()<br>        –&gt;SingleThreadEventLoop.register(channel)<br>            –&gt;SingleThreadEventLoop.register(new DefaultChannelPromise(channel, this))<br>                –&gt;AbstractUnsafe.register(promise,evenlop)–&gt;AbstractUnsafe.resiter0(promise)–&gt;safeSetSuccess(promise)</p><p>在safeSetSuccess调用promise.traSuccess()。notifyPromise中的listerner</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础知识--草稿</title>
      <link href="mysql/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>mysql/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql的基础知识"><a href="#Mysql的基础知识" class="headerlink" title="Mysql的基础知识"></a>Mysql的基础知识</h1><p> Mysql的基础知识</p><h2 id="一条sql语句从提交到返回结果经过哪几步"><a href="#一条sql语句从提交到返回结果经过哪几步" class="headerlink" title="一条sql语句从提交到返回结果经过哪几步"></a>一条sql语句从提交到返回结果经过哪几步</h2><p>客户端–&gt;连接器–&gt;查询缓存（如果有直接返回，8.0会被废除）–&gt;分析器–&gt;优化器–&gt;执行器–&gt;存储引擎–&gt;server数据。</p><h2 id="我们经常用到的查询语句"><a href="#我们经常用到的查询语句" class="headerlink" title="我们经常用到的查询语句"></a>我们经常用到的查询语句</h2><p>select * from t where t=1 ordey by date desc limit 0 ,1;</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql是如何保证主从同步的（binlog）--草稿</title>
      <link href="mysql/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%88binlog%EF%BC%89/"/>
      <url>mysql/mysql%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%88binlog%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql是如何保证主从同步的（binlog）–草稿"><a href="#mysql是如何保证主从同步的（binlog）–草稿" class="headerlink" title="mysql是如何保证主从同步的（binlog）–草稿"></a>mysql是如何保证主从同步的（binlog）–草稿</h1><ol><li><p>mysql的主从搭建</p></li><li><p>mysql的主从数据同步的流程（图）</p></li><li><p>查看binlog方式：mysql&gt; show binlog events in ‘master.000001’;</p></li><li><p>mysql的binlog的几种形式</p><ol><li>row。<ol><li>优点：可做数据恢复</li><li>缺点：可能会很大，因为是每一条数据一个log,所以如果一个涉及很多行修改的sql语句会有很多row的log。</li><li>恢复的话：相应的事件逆序即可</li><li>查看用：mysqlbinlog  -vv data/master.000001 –start-position=8900;</li></ol></li><li>statement。（优点：节省空间只是一条sql语句，缺点：无法做数据恢复）线上不会用<ol><li>在某些情况下可能会导致数据不一致比如limit和默认排序根据选择的索引不同数据会不一样。（warn）</li></ol></li><li>mixed（前两种混合 一般用这种）</li></ol></li><li><p>数据重放的方法</p><ol><li>badcase:mysqlbinlog解析日志，直接copy出statement重发，由于mysql语句是依赖上下文的所以会有风险。</li><li>goodcase:mysqlbinlog解析日志，吧解析结果发给mysql执行，如：<ol><li>mysqlbinlog master.000001  –start-position=2738 –stop-position=2973 | mysql -h127.0.0.1 -P13000 -u$user -p$pwd;</li></ol></li></ol></li><li><p>mysql的双M架构（对比M-S）(如何解决主从循环复制的问题)</p><ol><li>生产上使用较多的数据库，好处是主从切换不用修改节点状态，因为都是主</li><li>如何解决循环复制的：因为双M,所以另一个主一般会开启log_slave_updates(on)<ol><li>说明情况：server1写一条binlog,同步到server2这时候server2也会产生一条binlog，这时候如果同步到server1就会循环同步，mysql如何解决？</li><li>解决方案：<ol><li>俩个server的serverid不一样，一样的话不能成为主备；</li><li>第一次生产binlog的库带着serverid</li><li>备库接到binlog在重放的时候带着主库的serverid</li><li>这条log同步到主库时候，主库发现这个serverid和自己一样说明是自己产生的直接丢弃</li></ol></li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
          <category> Mysql高可用架构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>源代码说明</title>
      <link href="netty/%E8%AF%B4%E6%98%8E/"/>
      <url>netty/%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="netty-源码的学习"><a href="#netty-源码的学习" class="headerlink" title="netty 源码的学习"></a>netty 源码的学习</h1><p>netty源码学习的git地址：<a href="https://github.com/liuhao163/netty.git" target="_blank" rel="noopener">https://github.com/liuhao163/netty.git</a></p><p>branch:4.1-ericliu</p>]]></content>
      
      
      <categories>
          
          <category> netty </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
